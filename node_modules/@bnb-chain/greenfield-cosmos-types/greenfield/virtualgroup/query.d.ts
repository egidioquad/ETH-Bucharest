import { PageRequest, PageRequestAmino, PageRequestSDKType, PageResponse, PageResponseAmino, PageResponseSDKType } from "../../cosmos/base/query/v1beta1/pagination";
import { Params, ParamsAmino, ParamsSDKType } from "./params";
import { GlobalVirtualGroup, GlobalVirtualGroupAmino, GlobalVirtualGroupSDKType, GlobalVirtualGroupFamily, GlobalVirtualGroupFamilyAmino, GlobalVirtualGroupFamilySDKType } from "./types";
import * as _m0 from "protobufjs/minimal";
import { Rpc } from "../../helpers";
export declare const protobufPackage = "greenfield.virtualgroup";
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
export interface QueryParamsRequestProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryParamsRequest";
    value: Uint8Array;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestAmino {
}
export interface QueryParamsRequestAminoMsg {
    type: "/greenfield.virtualgroup.QueryParamsRequest";
    value: QueryParamsRequestAmino;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestSDKType {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
export interface QueryParamsResponseProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryParamsResponse";
    value: Uint8Array;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseAmino {
    /** params holds all the parameters of this module. */
    params?: ParamsAmino;
}
export interface QueryParamsResponseAminoMsg {
    type: "/greenfield.virtualgroup.QueryParamsResponse";
    value: QueryParamsResponseAmino;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseSDKType {
    params: ParamsSDKType;
}
export interface QueryGlobalVirtualGroupRequest {
    globalVirtualGroupId: number;
}
export interface QueryGlobalVirtualGroupRequestProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupRequest";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupRequestAmino {
    global_virtual_group_id?: number;
}
export interface QueryGlobalVirtualGroupRequestAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupRequest";
    value: QueryGlobalVirtualGroupRequestAmino;
}
export interface QueryGlobalVirtualGroupRequestSDKType {
    global_virtual_group_id: number;
}
export interface QueryGlobalVirtualGroupResponse {
    globalVirtualGroup?: GlobalVirtualGroup;
}
export interface QueryGlobalVirtualGroupResponseProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupResponse";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupResponseAmino {
    global_virtual_group?: GlobalVirtualGroupAmino;
}
export interface QueryGlobalVirtualGroupResponseAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupResponse";
    value: QueryGlobalVirtualGroupResponseAmino;
}
export interface QueryGlobalVirtualGroupResponseSDKType {
    global_virtual_group?: GlobalVirtualGroupSDKType;
}
export interface QueryGlobalVirtualGroupByFamilyIDRequest {
    globalVirtualGroupFamilyId: number;
}
export interface QueryGlobalVirtualGroupByFamilyIDRequestProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupByFamilyIDRequest";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupByFamilyIDRequestAmino {
    global_virtual_group_family_id?: number;
}
export interface QueryGlobalVirtualGroupByFamilyIDRequestAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupByFamilyIDRequest";
    value: QueryGlobalVirtualGroupByFamilyIDRequestAmino;
}
export interface QueryGlobalVirtualGroupByFamilyIDRequestSDKType {
    global_virtual_group_family_id: number;
}
export interface QueryGlobalVirtualGroupByFamilyIDResponse {
    globalVirtualGroups: GlobalVirtualGroup[];
}
export interface QueryGlobalVirtualGroupByFamilyIDResponseProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupByFamilyIDResponse";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupByFamilyIDResponseAmino {
    global_virtual_groups?: GlobalVirtualGroupAmino[];
}
export interface QueryGlobalVirtualGroupByFamilyIDResponseAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupByFamilyIDResponse";
    value: QueryGlobalVirtualGroupByFamilyIDResponseAmino;
}
export interface QueryGlobalVirtualGroupByFamilyIDResponseSDKType {
    global_virtual_groups: GlobalVirtualGroupSDKType[];
}
export interface QueryGlobalVirtualGroupFamilyRequest {
    familyId: number;
}
export interface QueryGlobalVirtualGroupFamilyRequestProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamilyRequest";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupFamilyRequestAmino {
    family_id?: number;
}
export interface QueryGlobalVirtualGroupFamilyRequestAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamilyRequest";
    value: QueryGlobalVirtualGroupFamilyRequestAmino;
}
export interface QueryGlobalVirtualGroupFamilyRequestSDKType {
    family_id: number;
}
export interface QueryGlobalVirtualGroupFamilyResponse {
    globalVirtualGroupFamily?: GlobalVirtualGroupFamily;
}
export interface QueryGlobalVirtualGroupFamilyResponseProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamilyResponse";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupFamilyResponseAmino {
    global_virtual_group_family?: GlobalVirtualGroupFamilyAmino;
}
export interface QueryGlobalVirtualGroupFamilyResponseAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamilyResponse";
    value: QueryGlobalVirtualGroupFamilyResponseAmino;
}
export interface QueryGlobalVirtualGroupFamilyResponseSDKType {
    global_virtual_group_family?: GlobalVirtualGroupFamilySDKType;
}
export interface QueryGlobalVirtualGroupFamiliesRequest {
    pagination?: PageRequest;
}
export interface QueryGlobalVirtualGroupFamiliesRequestProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamiliesRequest";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupFamiliesRequestAmino {
    pagination?: PageRequestAmino;
}
export interface QueryGlobalVirtualGroupFamiliesRequestAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamiliesRequest";
    value: QueryGlobalVirtualGroupFamiliesRequestAmino;
}
export interface QueryGlobalVirtualGroupFamiliesRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryGlobalVirtualGroupFamiliesResponse {
    gvgFamilies: GlobalVirtualGroupFamily[];
    pagination?: PageResponse;
}
export interface QueryGlobalVirtualGroupFamiliesResponseProtoMsg {
    typeUrl: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamiliesResponse";
    value: Uint8Array;
}
export interface QueryGlobalVirtualGroupFamiliesResponseAmino {
    gvg_families?: GlobalVirtualGroupFamilyAmino[];
    pagination?: PageResponseAmino;
}
export interface QueryGlobalVirtualGroupFamiliesResponseAminoMsg {
    type: "/greenfield.virtualgroup.QueryGlobalVirtualGroupFamiliesResponse";
    value: QueryGlobalVirtualGroupFamiliesResponseAmino;
}
export interface QueryGlobalVirtualGroupFamiliesResponseSDKType {
    gvg_families: GlobalVirtualGroupFamilySDKType[];
    pagination?: PageResponseSDKType;
}
export interface AvailableGlobalVirtualGroupFamiliesRequest {
    globalVirtualGroupFamilyIds: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesRequestProtoMsg {
    typeUrl: "/greenfield.virtualgroup.AvailableGlobalVirtualGroupFamiliesRequest";
    value: Uint8Array;
}
export interface AvailableGlobalVirtualGroupFamiliesRequestAmino {
    global_virtual_group_family_ids?: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesRequestAminoMsg {
    type: "/greenfield.virtualgroup.AvailableGlobalVirtualGroupFamiliesRequest";
    value: AvailableGlobalVirtualGroupFamiliesRequestAmino;
}
export interface AvailableGlobalVirtualGroupFamiliesRequestSDKType {
    global_virtual_group_family_ids: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesResponse {
    globalVirtualGroupFamilyIds: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesResponseProtoMsg {
    typeUrl: "/greenfield.virtualgroup.AvailableGlobalVirtualGroupFamiliesResponse";
    value: Uint8Array;
}
export interface AvailableGlobalVirtualGroupFamiliesResponseAmino {
    global_virtual_group_family_ids?: number[];
}
export interface AvailableGlobalVirtualGroupFamiliesResponseAminoMsg {
    type: "/greenfield.virtualgroup.AvailableGlobalVirtualGroupFamiliesResponse";
    value: AvailableGlobalVirtualGroupFamiliesResponseAmino;
}
export interface AvailableGlobalVirtualGroupFamiliesResponseSDKType {
    global_virtual_group_family_ids: number[];
}
export declare const QueryParamsRequest: {
    typeUrl: string;
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
    fromSDK(_: QueryParamsRequestSDKType): QueryParamsRequest;
    toSDK(_: QueryParamsRequest): QueryParamsRequestSDKType;
    fromAmino(_: QueryParamsRequestAmino): QueryParamsRequest;
    toAmino(_: QueryParamsRequest): QueryParamsRequestAmino;
    fromAminoMsg(object: QueryParamsRequestAminoMsg): QueryParamsRequest;
    fromProtoMsg(message: QueryParamsRequestProtoMsg): QueryParamsRequest;
    toProto(message: QueryParamsRequest): Uint8Array;
    toProtoMsg(message: QueryParamsRequest): QueryParamsRequestProtoMsg;
};
export declare const QueryParamsResponse: {
    typeUrl: string;
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            depositDenom?: string;
            gvgStakingPerBytes?: string;
            maxLocalVirtualGroupNumPerBucket?: number;
            maxGlobalVirtualGroupNumPerFamily?: number;
            maxStoreSizePerFamily?: string | number | import("long").Long;
        };
    } & {
        params?: {
            depositDenom?: string;
            gvgStakingPerBytes?: string;
            maxLocalVirtualGroupNumPerBucket?: number;
            maxGlobalVirtualGroupNumPerFamily?: number;
            maxStoreSizePerFamily?: string | number | import("long").Long;
        } & {
            depositDenom?: string;
            gvgStakingPerBytes?: string;
            maxLocalVirtualGroupNumPerBucket?: number;
            maxGlobalVirtualGroupNumPerFamily?: number;
            maxStoreSizePerFamily?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["params"]["maxStoreSizePerFamily"], keyof import("long").Long>, never>);
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
    fromSDK(object: QueryParamsResponseSDKType): QueryParamsResponse;
    toSDK(message: QueryParamsResponse): QueryParamsResponseSDKType;
    fromAmino(object: QueryParamsResponseAmino): QueryParamsResponse;
    toAmino(message: QueryParamsResponse): QueryParamsResponseAmino;
    fromAminoMsg(object: QueryParamsResponseAminoMsg): QueryParamsResponse;
    fromProtoMsg(message: QueryParamsResponseProtoMsg): QueryParamsResponse;
    toProto(message: QueryParamsResponse): Uint8Array;
    toProtoMsg(message: QueryParamsResponse): QueryParamsResponseProtoMsg;
};
export declare const QueryGlobalVirtualGroupRequest: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupRequest;
    toJSON(message: QueryGlobalVirtualGroupRequest): unknown;
    fromPartial<I extends {
        globalVirtualGroupId?: number;
    } & {
        globalVirtualGroupId?: number;
    } & Record<Exclude<keyof I, "globalVirtualGroupId">, never>>(object: I): QueryGlobalVirtualGroupRequest;
    fromSDK(object: QueryGlobalVirtualGroupRequestSDKType): QueryGlobalVirtualGroupRequest;
    toSDK(message: QueryGlobalVirtualGroupRequest): QueryGlobalVirtualGroupRequestSDKType;
    fromAmino(object: QueryGlobalVirtualGroupRequestAmino): QueryGlobalVirtualGroupRequest;
    toAmino(message: QueryGlobalVirtualGroupRequest): QueryGlobalVirtualGroupRequestAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupRequestAminoMsg): QueryGlobalVirtualGroupRequest;
    fromProtoMsg(message: QueryGlobalVirtualGroupRequestProtoMsg): QueryGlobalVirtualGroupRequest;
    toProto(message: QueryGlobalVirtualGroupRequest): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupRequest): QueryGlobalVirtualGroupRequestProtoMsg;
};
export declare const QueryGlobalVirtualGroupResponse: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupResponse;
    toJSON(message: QueryGlobalVirtualGroupResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        };
    } & {
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroup"]["secondarySpIds"], keyof number[]>, never>;
            storedSize?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["globalVirtualGroup"]["storedSize"], keyof import("long").Long>, never>);
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & Record<Exclude<keyof I["globalVirtualGroup"], keyof GlobalVirtualGroup>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroup">, never>>(object: I): QueryGlobalVirtualGroupResponse;
    fromSDK(object: QueryGlobalVirtualGroupResponseSDKType): QueryGlobalVirtualGroupResponse;
    toSDK(message: QueryGlobalVirtualGroupResponse): QueryGlobalVirtualGroupResponseSDKType;
    fromAmino(object: QueryGlobalVirtualGroupResponseAmino): QueryGlobalVirtualGroupResponse;
    toAmino(message: QueryGlobalVirtualGroupResponse): QueryGlobalVirtualGroupResponseAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupResponseAminoMsg): QueryGlobalVirtualGroupResponse;
    fromProtoMsg(message: QueryGlobalVirtualGroupResponseProtoMsg): QueryGlobalVirtualGroupResponse;
    toProto(message: QueryGlobalVirtualGroupResponse): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupResponse): QueryGlobalVirtualGroupResponseProtoMsg;
};
export declare const QueryGlobalVirtualGroupByFamilyIDRequest: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupByFamilyIDRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupByFamilyIDRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupByFamilyIDRequest;
    toJSON(message: QueryGlobalVirtualGroupByFamilyIDRequest): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamilyId?: number;
    } & {
        globalVirtualGroupFamilyId?: number;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamilyId">, never>>(object: I): QueryGlobalVirtualGroupByFamilyIDRequest;
    fromSDK(object: QueryGlobalVirtualGroupByFamilyIDRequestSDKType): QueryGlobalVirtualGroupByFamilyIDRequest;
    toSDK(message: QueryGlobalVirtualGroupByFamilyIDRequest): QueryGlobalVirtualGroupByFamilyIDRequestSDKType;
    fromAmino(object: QueryGlobalVirtualGroupByFamilyIDRequestAmino): QueryGlobalVirtualGroupByFamilyIDRequest;
    toAmino(message: QueryGlobalVirtualGroupByFamilyIDRequest): QueryGlobalVirtualGroupByFamilyIDRequestAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupByFamilyIDRequestAminoMsg): QueryGlobalVirtualGroupByFamilyIDRequest;
    fromProtoMsg(message: QueryGlobalVirtualGroupByFamilyIDRequestProtoMsg): QueryGlobalVirtualGroupByFamilyIDRequest;
    toProto(message: QueryGlobalVirtualGroupByFamilyIDRequest): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupByFamilyIDRequest): QueryGlobalVirtualGroupByFamilyIDRequestProtoMsg;
};
export declare const QueryGlobalVirtualGroupByFamilyIDResponse: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupByFamilyIDResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupByFamilyIDResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupByFamilyIDResponse;
    toJSON(message: QueryGlobalVirtualGroupByFamilyIDResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroups?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        }[];
    } & {
        globalVirtualGroups?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        }[] & ({
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroups"][number]["secondarySpIds"], keyof number[]>, never>;
            storedSize?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["globalVirtualGroups"][number]["storedSize"], keyof import("long").Long>, never>);
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & Record<Exclude<keyof I["globalVirtualGroups"][number], keyof GlobalVirtualGroup>, never>)[] & Record<Exclude<keyof I["globalVirtualGroups"], keyof {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | import("long").Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroups">, never>>(object: I): QueryGlobalVirtualGroupByFamilyIDResponse;
    fromSDK(object: QueryGlobalVirtualGroupByFamilyIDResponseSDKType): QueryGlobalVirtualGroupByFamilyIDResponse;
    toSDK(message: QueryGlobalVirtualGroupByFamilyIDResponse): QueryGlobalVirtualGroupByFamilyIDResponseSDKType;
    fromAmino(object: QueryGlobalVirtualGroupByFamilyIDResponseAmino): QueryGlobalVirtualGroupByFamilyIDResponse;
    toAmino(message: QueryGlobalVirtualGroupByFamilyIDResponse): QueryGlobalVirtualGroupByFamilyIDResponseAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupByFamilyIDResponseAminoMsg): QueryGlobalVirtualGroupByFamilyIDResponse;
    fromProtoMsg(message: QueryGlobalVirtualGroupByFamilyIDResponseProtoMsg): QueryGlobalVirtualGroupByFamilyIDResponse;
    toProto(message: QueryGlobalVirtualGroupByFamilyIDResponse): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupByFamilyIDResponse): QueryGlobalVirtualGroupByFamilyIDResponseProtoMsg;
};
export declare const QueryGlobalVirtualGroupFamilyRequest: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupFamilyRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamilyRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupFamilyRequest;
    toJSON(message: QueryGlobalVirtualGroupFamilyRequest): unknown;
    fromPartial<I extends {
        familyId?: number;
    } & {
        familyId?: number;
    } & Record<Exclude<keyof I, "familyId">, never>>(object: I): QueryGlobalVirtualGroupFamilyRequest;
    fromSDK(object: QueryGlobalVirtualGroupFamilyRequestSDKType): QueryGlobalVirtualGroupFamilyRequest;
    toSDK(message: QueryGlobalVirtualGroupFamilyRequest): QueryGlobalVirtualGroupFamilyRequestSDKType;
    fromAmino(object: QueryGlobalVirtualGroupFamilyRequestAmino): QueryGlobalVirtualGroupFamilyRequest;
    toAmino(message: QueryGlobalVirtualGroupFamilyRequest): QueryGlobalVirtualGroupFamilyRequestAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupFamilyRequestAminoMsg): QueryGlobalVirtualGroupFamilyRequest;
    fromProtoMsg(message: QueryGlobalVirtualGroupFamilyRequestProtoMsg): QueryGlobalVirtualGroupFamilyRequest;
    toProto(message: QueryGlobalVirtualGroupFamilyRequest): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupFamilyRequest): QueryGlobalVirtualGroupFamilyRequestProtoMsg;
};
export declare const QueryGlobalVirtualGroupFamilyResponse: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupFamilyResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamilyResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupFamilyResponse;
    toJSON(message: QueryGlobalVirtualGroupFamilyResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamily?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        };
    } & {
        globalVirtualGroupFamily?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        } & {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroupFamily"]["globalVirtualGroupIds"], keyof number[]>, never>;
            virtualPaymentAddress?: string;
        } & Record<Exclude<keyof I["globalVirtualGroupFamily"], keyof GlobalVirtualGroupFamily>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamily">, never>>(object: I): QueryGlobalVirtualGroupFamilyResponse;
    fromSDK(object: QueryGlobalVirtualGroupFamilyResponseSDKType): QueryGlobalVirtualGroupFamilyResponse;
    toSDK(message: QueryGlobalVirtualGroupFamilyResponse): QueryGlobalVirtualGroupFamilyResponseSDKType;
    fromAmino(object: QueryGlobalVirtualGroupFamilyResponseAmino): QueryGlobalVirtualGroupFamilyResponse;
    toAmino(message: QueryGlobalVirtualGroupFamilyResponse): QueryGlobalVirtualGroupFamilyResponseAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupFamilyResponseAminoMsg): QueryGlobalVirtualGroupFamilyResponse;
    fromProtoMsg(message: QueryGlobalVirtualGroupFamilyResponseProtoMsg): QueryGlobalVirtualGroupFamilyResponse;
    toProto(message: QueryGlobalVirtualGroupFamilyResponse): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupFamilyResponse): QueryGlobalVirtualGroupFamilyResponseProtoMsg;
};
export declare const QueryGlobalVirtualGroupFamiliesRequest: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupFamiliesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamiliesRequest;
    fromJSON(object: any): QueryGlobalVirtualGroupFamiliesRequest;
    toJSON(message: QueryGlobalVirtualGroupFamiliesRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>);
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryGlobalVirtualGroupFamiliesRequest;
    fromSDK(object: QueryGlobalVirtualGroupFamiliesRequestSDKType): QueryGlobalVirtualGroupFamiliesRequest;
    toSDK(message: QueryGlobalVirtualGroupFamiliesRequest): QueryGlobalVirtualGroupFamiliesRequestSDKType;
    fromAmino(object: QueryGlobalVirtualGroupFamiliesRequestAmino): QueryGlobalVirtualGroupFamiliesRequest;
    toAmino(message: QueryGlobalVirtualGroupFamiliesRequest): QueryGlobalVirtualGroupFamiliesRequestAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupFamiliesRequestAminoMsg): QueryGlobalVirtualGroupFamiliesRequest;
    fromProtoMsg(message: QueryGlobalVirtualGroupFamiliesRequestProtoMsg): QueryGlobalVirtualGroupFamiliesRequest;
    toProto(message: QueryGlobalVirtualGroupFamiliesRequest): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupFamiliesRequest): QueryGlobalVirtualGroupFamiliesRequestProtoMsg;
};
export declare const QueryGlobalVirtualGroupFamiliesResponse: {
    typeUrl: string;
    encode(message: QueryGlobalVirtualGroupFamiliesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalVirtualGroupFamiliesResponse;
    fromJSON(object: any): QueryGlobalVirtualGroupFamiliesResponse;
    toJSON(message: QueryGlobalVirtualGroupFamiliesResponse): unknown;
    fromPartial<I extends {
        gvgFamilies?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        };
    } & {
        gvgFamilies?: {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        }[] & ({
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        } & {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[] & number[] & Record<Exclude<keyof I["gvgFamilies"][number]["globalVirtualGroupIds"], keyof number[]>, never>;
            virtualPaymentAddress?: string;
        } & Record<Exclude<keyof I["gvgFamilies"][number], keyof GlobalVirtualGroupFamily>, never>)[] & Record<Exclude<keyof I["gvgFamilies"], keyof {
            id?: number;
            primarySpId?: number;
            globalVirtualGroupIds?: number[];
            virtualPaymentAddress?: string;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryGlobalVirtualGroupFamiliesResponse>, never>>(object: I): QueryGlobalVirtualGroupFamiliesResponse;
    fromSDK(object: QueryGlobalVirtualGroupFamiliesResponseSDKType): QueryGlobalVirtualGroupFamiliesResponse;
    toSDK(message: QueryGlobalVirtualGroupFamiliesResponse): QueryGlobalVirtualGroupFamiliesResponseSDKType;
    fromAmino(object: QueryGlobalVirtualGroupFamiliesResponseAmino): QueryGlobalVirtualGroupFamiliesResponse;
    toAmino(message: QueryGlobalVirtualGroupFamiliesResponse): QueryGlobalVirtualGroupFamiliesResponseAmino;
    fromAminoMsg(object: QueryGlobalVirtualGroupFamiliesResponseAminoMsg): QueryGlobalVirtualGroupFamiliesResponse;
    fromProtoMsg(message: QueryGlobalVirtualGroupFamiliesResponseProtoMsg): QueryGlobalVirtualGroupFamiliesResponse;
    toProto(message: QueryGlobalVirtualGroupFamiliesResponse): Uint8Array;
    toProtoMsg(message: QueryGlobalVirtualGroupFamiliesResponse): QueryGlobalVirtualGroupFamiliesResponseProtoMsg;
};
export declare const AvailableGlobalVirtualGroupFamiliesRequest: {
    typeUrl: string;
    encode(message: AvailableGlobalVirtualGroupFamiliesRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AvailableGlobalVirtualGroupFamiliesRequest;
    fromJSON(object: any): AvailableGlobalVirtualGroupFamiliesRequest;
    toJSON(message: AvailableGlobalVirtualGroupFamiliesRequest): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamilyIds?: number[];
    } & {
        globalVirtualGroupFamilyIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroupFamilyIds"], keyof number[]>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamilyIds">, never>>(object: I): AvailableGlobalVirtualGroupFamiliesRequest;
    fromSDK(object: AvailableGlobalVirtualGroupFamiliesRequestSDKType): AvailableGlobalVirtualGroupFamiliesRequest;
    toSDK(message: AvailableGlobalVirtualGroupFamiliesRequest): AvailableGlobalVirtualGroupFamiliesRequestSDKType;
    fromAmino(object: AvailableGlobalVirtualGroupFamiliesRequestAmino): AvailableGlobalVirtualGroupFamiliesRequest;
    toAmino(message: AvailableGlobalVirtualGroupFamiliesRequest): AvailableGlobalVirtualGroupFamiliesRequestAmino;
    fromAminoMsg(object: AvailableGlobalVirtualGroupFamiliesRequestAminoMsg): AvailableGlobalVirtualGroupFamiliesRequest;
    fromProtoMsg(message: AvailableGlobalVirtualGroupFamiliesRequestProtoMsg): AvailableGlobalVirtualGroupFamiliesRequest;
    toProto(message: AvailableGlobalVirtualGroupFamiliesRequest): Uint8Array;
    toProtoMsg(message: AvailableGlobalVirtualGroupFamiliesRequest): AvailableGlobalVirtualGroupFamiliesRequestProtoMsg;
};
export declare const AvailableGlobalVirtualGroupFamiliesResponse: {
    typeUrl: string;
    encode(message: AvailableGlobalVirtualGroupFamiliesResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): AvailableGlobalVirtualGroupFamiliesResponse;
    fromJSON(object: any): AvailableGlobalVirtualGroupFamiliesResponse;
    toJSON(message: AvailableGlobalVirtualGroupFamiliesResponse): unknown;
    fromPartial<I extends {
        globalVirtualGroupFamilyIds?: number[];
    } & {
        globalVirtualGroupFamilyIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroupFamilyIds"], keyof number[]>, never>;
    } & Record<Exclude<keyof I, "globalVirtualGroupFamilyIds">, never>>(object: I): AvailableGlobalVirtualGroupFamiliesResponse;
    fromSDK(object: AvailableGlobalVirtualGroupFamiliesResponseSDKType): AvailableGlobalVirtualGroupFamiliesResponse;
    toSDK(message: AvailableGlobalVirtualGroupFamiliesResponse): AvailableGlobalVirtualGroupFamiliesResponseSDKType;
    fromAmino(object: AvailableGlobalVirtualGroupFamiliesResponseAmino): AvailableGlobalVirtualGroupFamiliesResponse;
    toAmino(message: AvailableGlobalVirtualGroupFamiliesResponse): AvailableGlobalVirtualGroupFamiliesResponseAmino;
    fromAminoMsg(object: AvailableGlobalVirtualGroupFamiliesResponseAminoMsg): AvailableGlobalVirtualGroupFamiliesResponse;
    fromProtoMsg(message: AvailableGlobalVirtualGroupFamiliesResponseProtoMsg): AvailableGlobalVirtualGroupFamiliesResponse;
    toProto(message: AvailableGlobalVirtualGroupFamiliesResponse): Uint8Array;
    toProtoMsg(message: AvailableGlobalVirtualGroupFamiliesResponse): AvailableGlobalVirtualGroupFamiliesResponseProtoMsg;
};
/** Query defines the gRPC query service. */
export interface Query {
    /** Parameters queries the parameters of the module. */
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** Queries a global virtual group by its id. */
    GlobalVirtualGroup(request: QueryGlobalVirtualGroupRequest): Promise<QueryGlobalVirtualGroupResponse>;
    /** Queries a list of global virtual groups by family id. */
    GlobalVirtualGroupByFamilyID(request: QueryGlobalVirtualGroupByFamilyIDRequest): Promise<QueryGlobalVirtualGroupByFamilyIDResponse>;
    /** Queries a global virtual group family by its id. */
    GlobalVirtualGroupFamily(request: QueryGlobalVirtualGroupFamilyRequest): Promise<QueryGlobalVirtualGroupFamilyResponse>;
    /** Queries a list of GlobalVirtualGroupFamilies items. */
    GlobalVirtualGroupFamilies(request?: QueryGlobalVirtualGroupFamiliesRequest): Promise<QueryGlobalVirtualGroupFamiliesResponse>;
    /** AvailableGlobalVirtualGroupFamilies filters a list of GlobalVirtualGroupFamilies ID which are qualified to create bucket on */
    AvailableGlobalVirtualGroupFamilies(request: AvailableGlobalVirtualGroupFamiliesRequest): Promise<AvailableGlobalVirtualGroupFamiliesResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    GlobalVirtualGroup(request: QueryGlobalVirtualGroupRequest): Promise<QueryGlobalVirtualGroupResponse>;
    GlobalVirtualGroupByFamilyID(request: QueryGlobalVirtualGroupByFamilyIDRequest): Promise<QueryGlobalVirtualGroupByFamilyIDResponse>;
    GlobalVirtualGroupFamily(request: QueryGlobalVirtualGroupFamilyRequest): Promise<QueryGlobalVirtualGroupFamilyResponse>;
    GlobalVirtualGroupFamilies(request?: QueryGlobalVirtualGroupFamiliesRequest): Promise<QueryGlobalVirtualGroupFamiliesResponse>;
    AvailableGlobalVirtualGroupFamilies(request: AvailableGlobalVirtualGroupFamiliesRequest): Promise<AvailableGlobalVirtualGroupFamiliesResponse>;
}
