/// <reference types="long" />
import { PageRequest, PageRequestAmino, PageRequestSDKType, PageResponse, PageResponseAmino, PageResponseSDKType } from "../../cosmos/base/query/v1beta1/pagination";
import { Params, ParamsAmino, ParamsSDKType } from "./params";
import { StorageProvider, StorageProviderAmino, StorageProviderSDKType, SpStoragePrice, SpStoragePriceAmino, SpStoragePriceSDKType, GlobalSpStorePrice, GlobalSpStorePriceAmino, GlobalSpStorePriceSDKType, MaintenanceRecord, MaintenanceRecordAmino, MaintenanceRecordSDKType } from "./types";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.sp";
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
export interface QueryParamsRequestProtoMsg {
    typeUrl: "/greenfield.sp.QueryParamsRequest";
    value: Uint8Array;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestAmino {
}
export interface QueryParamsRequestAminoMsg {
    type: "/greenfield.sp.QueryParamsRequest";
    value: QueryParamsRequestAmino;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestSDKType {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
export interface QueryParamsResponseProtoMsg {
    typeUrl: "/greenfield.sp.QueryParamsResponse";
    value: Uint8Array;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseAmino {
    /** params holds all the parameters of this module. */
    params?: ParamsAmino;
}
export interface QueryParamsResponseAminoMsg {
    type: "/greenfield.sp.QueryParamsResponse";
    value: QueryParamsResponseAmino;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseSDKType {
    params: ParamsSDKType;
}
export interface QueryStorageProvidersRequest {
    /** pagination defines an optional pagination for the request. */
    pagination?: PageRequest;
}
export interface QueryStorageProvidersRequestProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProvidersRequest";
    value: Uint8Array;
}
export interface QueryStorageProvidersRequestAmino {
    /** pagination defines an optional pagination for the request. */
    pagination?: PageRequestAmino;
}
export interface QueryStorageProvidersRequestAminoMsg {
    type: "/greenfield.sp.QueryStorageProvidersRequest";
    value: QueryStorageProvidersRequestAmino;
}
export interface QueryStorageProvidersRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryStorageProvidersResponse {
    sps: StorageProvider[];
    /** pagination defines the pagination in the response. */
    pagination?: PageResponse;
}
export interface QueryStorageProvidersResponseProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProvidersResponse";
    value: Uint8Array;
}
export interface QueryStorageProvidersResponseAmino {
    sps?: StorageProviderAmino[];
    /** pagination defines the pagination in the response. */
    pagination?: PageResponseAmino;
}
export interface QueryStorageProvidersResponseAminoMsg {
    type: "/greenfield.sp.QueryStorageProvidersResponse";
    value: QueryStorageProvidersResponseAmino;
}
export interface QueryStorageProvidersResponseSDKType {
    sps: StorageProviderSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QuerySpStoragePriceRequest {
    /** operator address of sp */
    spAddr: string;
}
export interface QuerySpStoragePriceRequestProtoMsg {
    typeUrl: "/greenfield.sp.QuerySpStoragePriceRequest";
    value: Uint8Array;
}
export interface QuerySpStoragePriceRequestAmino {
    /** operator address of sp */
    sp_addr?: string;
}
export interface QuerySpStoragePriceRequestAminoMsg {
    type: "/greenfield.sp.QuerySpStoragePriceRequest";
    value: QuerySpStoragePriceRequestAmino;
}
export interface QuerySpStoragePriceRequestSDKType {
    sp_addr: string;
}
export interface QuerySpStoragePriceResponse {
    spStoragePrice: SpStoragePrice;
}
export interface QuerySpStoragePriceResponseProtoMsg {
    typeUrl: "/greenfield.sp.QuerySpStoragePriceResponse";
    value: Uint8Array;
}
export interface QuerySpStoragePriceResponseAmino {
    sp_storage_price?: SpStoragePriceAmino;
}
export interface QuerySpStoragePriceResponseAminoMsg {
    type: "/greenfield.sp.QuerySpStoragePriceResponse";
    value: QuerySpStoragePriceResponseAmino;
}
export interface QuerySpStoragePriceResponseSDKType {
    sp_storage_price: SpStoragePriceSDKType;
}
export interface QueryGlobalSpStorePriceByTimeRequest {
    /** unix timestamp in seconds. If it's 0, it will return the latest price. */
    timestamp: Long;
}
export interface QueryGlobalSpStorePriceByTimeRequestProtoMsg {
    typeUrl: "/greenfield.sp.QueryGlobalSpStorePriceByTimeRequest";
    value: Uint8Array;
}
export interface QueryGlobalSpStorePriceByTimeRequestAmino {
    /** unix timestamp in seconds. If it's 0, it will return the latest price. */
    timestamp?: string;
}
export interface QueryGlobalSpStorePriceByTimeRequestAminoMsg {
    type: "/greenfield.sp.QueryGlobalSpStorePriceByTimeRequest";
    value: QueryGlobalSpStorePriceByTimeRequestAmino;
}
export interface QueryGlobalSpStorePriceByTimeRequestSDKType {
    timestamp: Long;
}
export interface QueryGlobalSpStorePriceByTimeResponse {
    globalSpStorePrice: GlobalSpStorePrice;
}
export interface QueryGlobalSpStorePriceByTimeResponseProtoMsg {
    typeUrl: "/greenfield.sp.QueryGlobalSpStorePriceByTimeResponse";
    value: Uint8Array;
}
export interface QueryGlobalSpStorePriceByTimeResponseAmino {
    global_sp_store_price?: GlobalSpStorePriceAmino;
}
export interface QueryGlobalSpStorePriceByTimeResponseAminoMsg {
    type: "/greenfield.sp.QueryGlobalSpStorePriceByTimeResponse";
    value: QueryGlobalSpStorePriceByTimeResponseAmino;
}
export interface QueryGlobalSpStorePriceByTimeResponseSDKType {
    global_sp_store_price: GlobalSpStorePriceSDKType;
}
export interface QueryStorageProviderRequest {
    id: number;
}
export interface QueryStorageProviderRequestProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProviderRequest";
    value: Uint8Array;
}
export interface QueryStorageProviderRequestAmino {
    id?: number;
}
export interface QueryStorageProviderRequestAminoMsg {
    type: "/greenfield.sp.QueryStorageProviderRequest";
    value: QueryStorageProviderRequestAmino;
}
export interface QueryStorageProviderRequestSDKType {
    id: number;
}
export interface QueryStorageProviderResponse {
    storageProvider?: StorageProvider;
}
export interface QueryStorageProviderResponseProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProviderResponse";
    value: Uint8Array;
}
export interface QueryStorageProviderResponseAmino {
    storageProvider?: StorageProviderAmino;
}
export interface QueryStorageProviderResponseAminoMsg {
    type: "/greenfield.sp.QueryStorageProviderResponse";
    value: QueryStorageProviderResponseAmino;
}
export interface QueryStorageProviderResponseSDKType {
    storageProvider?: StorageProviderSDKType;
}
export interface QueryStorageProviderByOperatorAddressRequest {
    operatorAddress: string;
}
export interface QueryStorageProviderByOperatorAddressRequestProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProviderByOperatorAddressRequest";
    value: Uint8Array;
}
export interface QueryStorageProviderByOperatorAddressRequestAmino {
    operator_address?: string;
}
export interface QueryStorageProviderByOperatorAddressRequestAminoMsg {
    type: "/greenfield.sp.QueryStorageProviderByOperatorAddressRequest";
    value: QueryStorageProviderByOperatorAddressRequestAmino;
}
export interface QueryStorageProviderByOperatorAddressRequestSDKType {
    operator_address: string;
}
export interface QueryStorageProviderByOperatorAddressResponse {
    storageProvider?: StorageProvider;
}
export interface QueryStorageProviderByOperatorAddressResponseProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProviderByOperatorAddressResponse";
    value: Uint8Array;
}
export interface QueryStorageProviderByOperatorAddressResponseAmino {
    storageProvider?: StorageProviderAmino;
}
export interface QueryStorageProviderByOperatorAddressResponseAminoMsg {
    type: "/greenfield.sp.QueryStorageProviderByOperatorAddressResponse";
    value: QueryStorageProviderByOperatorAddressResponseAmino;
}
export interface QueryStorageProviderByOperatorAddressResponseSDKType {
    storageProvider?: StorageProviderSDKType;
}
export interface QueryStorageProviderMaintenanceRecordsRequest {
    operatorAddress: string;
}
export interface QueryStorageProviderMaintenanceRecordsRequestProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProviderMaintenanceRecordsRequest";
    value: Uint8Array;
}
export interface QueryStorageProviderMaintenanceRecordsRequestAmino {
    operator_address?: string;
}
export interface QueryStorageProviderMaintenanceRecordsRequestAminoMsg {
    type: "/greenfield.sp.QueryStorageProviderMaintenanceRecordsRequest";
    value: QueryStorageProviderMaintenanceRecordsRequestAmino;
}
export interface QueryStorageProviderMaintenanceRecordsRequestSDKType {
    operator_address: string;
}
export interface QueryStorageProviderMaintenanceRecordsResponse {
    records: MaintenanceRecord[];
}
export interface QueryStorageProviderMaintenanceRecordsResponseProtoMsg {
    typeUrl: "/greenfield.sp.QueryStorageProviderMaintenanceRecordsResponse";
    value: Uint8Array;
}
export interface QueryStorageProviderMaintenanceRecordsResponseAmino {
    records?: MaintenanceRecordAmino[];
}
export interface QueryStorageProviderMaintenanceRecordsResponseAminoMsg {
    type: "/greenfield.sp.QueryStorageProviderMaintenanceRecordsResponse";
    value: QueryStorageProviderMaintenanceRecordsResponseAmino;
}
export interface QueryStorageProviderMaintenanceRecordsResponseSDKType {
    records: MaintenanceRecordSDKType[];
}
export declare const QueryParamsRequest: {
    typeUrl: string;
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
    fromSDK(_: QueryParamsRequestSDKType): QueryParamsRequest;
    toSDK(_: QueryParamsRequest): QueryParamsRequestSDKType;
    fromAmino(_: QueryParamsRequestAmino): QueryParamsRequest;
    toAmino(_: QueryParamsRequest): QueryParamsRequestAmino;
    fromAminoMsg(object: QueryParamsRequestAminoMsg): QueryParamsRequest;
    fromProtoMsg(message: QueryParamsRequestProtoMsg): QueryParamsRequest;
    toProto(message: QueryParamsRequest): Uint8Array;
    toProtoMsg(message: QueryParamsRequest): QueryParamsRequestProtoMsg;
};
export declare const QueryParamsResponse: {
    typeUrl: string;
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            depositDenom?: string;
            minDeposit?: string;
            secondarySpStorePriceRatio?: string;
            numOfHistoricalBlocksForMaintenanceRecords?: string | number | Long.Long;
            maintenanceDurationQuota?: string | number | Long.Long;
            numOfLockupBlocksForMaintenance?: string | number | Long.Long;
            updateGlobalPriceInterval?: string | number | Long.Long;
            updatePriceDisallowedDays?: number;
        };
    } & {
        params?: {
            depositDenom?: string;
            minDeposit?: string;
            secondarySpStorePriceRatio?: string;
            numOfHistoricalBlocksForMaintenanceRecords?: string | number | Long.Long;
            maintenanceDurationQuota?: string | number | Long.Long;
            numOfLockupBlocksForMaintenance?: string | number | Long.Long;
            updateGlobalPriceInterval?: string | number | Long.Long;
            updatePriceDisallowedDays?: number;
        } & {
            depositDenom?: string;
            minDeposit?: string;
            secondarySpStorePriceRatio?: string;
            numOfHistoricalBlocksForMaintenanceRecords?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["numOfHistoricalBlocksForMaintenanceRecords"], keyof Long.Long>, never>);
            maintenanceDurationQuota?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maintenanceDurationQuota"], keyof Long.Long>, never>);
            numOfLockupBlocksForMaintenance?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["numOfLockupBlocksForMaintenance"], keyof Long.Long>, never>);
            updateGlobalPriceInterval?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["updateGlobalPriceInterval"], keyof Long.Long>, never>);
            updatePriceDisallowedDays?: number;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
    fromSDK(object: QueryParamsResponseSDKType): QueryParamsResponse;
    toSDK(message: QueryParamsResponse): QueryParamsResponseSDKType;
    fromAmino(object: QueryParamsResponseAmino): QueryParamsResponse;
    toAmino(message: QueryParamsResponse): QueryParamsResponseAmino;
    fromAminoMsg(object: QueryParamsResponseAminoMsg): QueryParamsResponse;
    fromProtoMsg(message: QueryParamsResponseProtoMsg): QueryParamsResponse;
    toProto(message: QueryParamsResponse): Uint8Array;
    toProtoMsg(message: QueryParamsResponse): QueryParamsResponseProtoMsg;
};
export declare const QueryStorageProvidersRequest: {
    typeUrl: string;
    encode(message: QueryStorageProvidersRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProvidersRequest;
    fromJSON(object: any): QueryStorageProvidersRequest;
    toJSON(message: QueryStorageProvidersRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryStorageProvidersRequest;
    fromSDK(object: QueryStorageProvidersRequestSDKType): QueryStorageProvidersRequest;
    toSDK(message: QueryStorageProvidersRequest): QueryStorageProvidersRequestSDKType;
    fromAmino(object: QueryStorageProvidersRequestAmino): QueryStorageProvidersRequest;
    toAmino(message: QueryStorageProvidersRequest): QueryStorageProvidersRequestAmino;
    fromAminoMsg(object: QueryStorageProvidersRequestAminoMsg): QueryStorageProvidersRequest;
    fromProtoMsg(message: QueryStorageProvidersRequestProtoMsg): QueryStorageProvidersRequest;
    toProto(message: QueryStorageProvidersRequest): Uint8Array;
    toProtoMsg(message: QueryStorageProvidersRequest): QueryStorageProvidersRequestProtoMsg;
};
export declare const QueryStorageProvidersResponse: {
    typeUrl: string;
    encode(message: QueryStorageProvidersResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProvidersResponse;
    fromJSON(object: any): QueryStorageProvidersResponse;
    toJSON(message: QueryStorageProvidersResponse): unknown;
    fromPartial<I extends {
        sps?: {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        sps?: {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        }[] & ({
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        } & {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            } & {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            } & Record<Exclude<keyof I["sps"][number]["description"], keyof import("./types").Description>, never>;
            blsKey?: Uint8Array;
        } & Record<Exclude<keyof I["sps"][number], keyof StorageProvider>, never>)[] & Record<Exclude<keyof I["sps"], keyof {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryStorageProvidersResponse>, never>>(object: I): QueryStorageProvidersResponse;
    fromSDK(object: QueryStorageProvidersResponseSDKType): QueryStorageProvidersResponse;
    toSDK(message: QueryStorageProvidersResponse): QueryStorageProvidersResponseSDKType;
    fromAmino(object: QueryStorageProvidersResponseAmino): QueryStorageProvidersResponse;
    toAmino(message: QueryStorageProvidersResponse): QueryStorageProvidersResponseAmino;
    fromAminoMsg(object: QueryStorageProvidersResponseAminoMsg): QueryStorageProvidersResponse;
    fromProtoMsg(message: QueryStorageProvidersResponseProtoMsg): QueryStorageProvidersResponse;
    toProto(message: QueryStorageProvidersResponse): Uint8Array;
    toProtoMsg(message: QueryStorageProvidersResponse): QueryStorageProvidersResponseProtoMsg;
};
export declare const QuerySpStoragePriceRequest: {
    typeUrl: string;
    encode(message: QuerySpStoragePriceRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpStoragePriceRequest;
    fromJSON(object: any): QuerySpStoragePriceRequest;
    toJSON(message: QuerySpStoragePriceRequest): unknown;
    fromPartial<I extends {
        spAddr?: string;
    } & {
        spAddr?: string;
    } & Record<Exclude<keyof I, "spAddr">, never>>(object: I): QuerySpStoragePriceRequest;
    fromSDK(object: QuerySpStoragePriceRequestSDKType): QuerySpStoragePriceRequest;
    toSDK(message: QuerySpStoragePriceRequest): QuerySpStoragePriceRequestSDKType;
    fromAmino(object: QuerySpStoragePriceRequestAmino): QuerySpStoragePriceRequest;
    toAmino(message: QuerySpStoragePriceRequest): QuerySpStoragePriceRequestAmino;
    fromAminoMsg(object: QuerySpStoragePriceRequestAminoMsg): QuerySpStoragePriceRequest;
    fromProtoMsg(message: QuerySpStoragePriceRequestProtoMsg): QuerySpStoragePriceRequest;
    toProto(message: QuerySpStoragePriceRequest): Uint8Array;
    toProtoMsg(message: QuerySpStoragePriceRequest): QuerySpStoragePriceRequestProtoMsg;
};
export declare const QuerySpStoragePriceResponse: {
    typeUrl: string;
    encode(message: QuerySpStoragePriceResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QuerySpStoragePriceResponse;
    fromJSON(object: any): QuerySpStoragePriceResponse;
    toJSON(message: QuerySpStoragePriceResponse): unknown;
    fromPartial<I extends {
        spStoragePrice?: {
            spId?: number;
            updateTimeSec?: string | number | Long.Long;
            readPrice?: string;
            freeReadQuota?: string | number | Long.Long;
            storePrice?: string;
        };
    } & {
        spStoragePrice?: {
            spId?: number;
            updateTimeSec?: string | number | Long.Long;
            readPrice?: string;
            freeReadQuota?: string | number | Long.Long;
            storePrice?: string;
        } & {
            spId?: number;
            updateTimeSec?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["spStoragePrice"]["updateTimeSec"], keyof Long.Long>, never>);
            readPrice?: string;
            freeReadQuota?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["spStoragePrice"]["freeReadQuota"], keyof Long.Long>, never>);
            storePrice?: string;
        } & Record<Exclude<keyof I["spStoragePrice"], keyof SpStoragePrice>, never>;
    } & Record<Exclude<keyof I, "spStoragePrice">, never>>(object: I): QuerySpStoragePriceResponse;
    fromSDK(object: QuerySpStoragePriceResponseSDKType): QuerySpStoragePriceResponse;
    toSDK(message: QuerySpStoragePriceResponse): QuerySpStoragePriceResponseSDKType;
    fromAmino(object: QuerySpStoragePriceResponseAmino): QuerySpStoragePriceResponse;
    toAmino(message: QuerySpStoragePriceResponse): QuerySpStoragePriceResponseAmino;
    fromAminoMsg(object: QuerySpStoragePriceResponseAminoMsg): QuerySpStoragePriceResponse;
    fromProtoMsg(message: QuerySpStoragePriceResponseProtoMsg): QuerySpStoragePriceResponse;
    toProto(message: QuerySpStoragePriceResponse): Uint8Array;
    toProtoMsg(message: QuerySpStoragePriceResponse): QuerySpStoragePriceResponseProtoMsg;
};
export declare const QueryGlobalSpStorePriceByTimeRequest: {
    typeUrl: string;
    encode(message: QueryGlobalSpStorePriceByTimeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalSpStorePriceByTimeRequest;
    fromJSON(object: any): QueryGlobalSpStorePriceByTimeRequest;
    toJSON(message: QueryGlobalSpStorePriceByTimeRequest): unknown;
    fromPartial<I extends {
        timestamp?: string | number | Long.Long;
    } & {
        timestamp?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["timestamp"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, "timestamp">, never>>(object: I): QueryGlobalSpStorePriceByTimeRequest;
    fromSDK(object: QueryGlobalSpStorePriceByTimeRequestSDKType): QueryGlobalSpStorePriceByTimeRequest;
    toSDK(message: QueryGlobalSpStorePriceByTimeRequest): QueryGlobalSpStorePriceByTimeRequestSDKType;
    fromAmino(object: QueryGlobalSpStorePriceByTimeRequestAmino): QueryGlobalSpStorePriceByTimeRequest;
    toAmino(message: QueryGlobalSpStorePriceByTimeRequest): QueryGlobalSpStorePriceByTimeRequestAmino;
    fromAminoMsg(object: QueryGlobalSpStorePriceByTimeRequestAminoMsg): QueryGlobalSpStorePriceByTimeRequest;
    fromProtoMsg(message: QueryGlobalSpStorePriceByTimeRequestProtoMsg): QueryGlobalSpStorePriceByTimeRequest;
    toProto(message: QueryGlobalSpStorePriceByTimeRequest): Uint8Array;
    toProtoMsg(message: QueryGlobalSpStorePriceByTimeRequest): QueryGlobalSpStorePriceByTimeRequestProtoMsg;
};
export declare const QueryGlobalSpStorePriceByTimeResponse: {
    typeUrl: string;
    encode(message: QueryGlobalSpStorePriceByTimeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGlobalSpStorePriceByTimeResponse;
    fromJSON(object: any): QueryGlobalSpStorePriceByTimeResponse;
    toJSON(message: QueryGlobalSpStorePriceByTimeResponse): unknown;
    fromPartial<I extends {
        globalSpStorePrice?: {
            updateTimeSec?: string | number | Long.Long;
            readPrice?: string;
            primaryStorePrice?: string;
            secondaryStorePrice?: string;
        };
    } & {
        globalSpStorePrice?: {
            updateTimeSec?: string | number | Long.Long;
            readPrice?: string;
            primaryStorePrice?: string;
            secondaryStorePrice?: string;
        } & {
            updateTimeSec?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["globalSpStorePrice"]["updateTimeSec"], keyof Long.Long>, never>);
            readPrice?: string;
            primaryStorePrice?: string;
            secondaryStorePrice?: string;
        } & Record<Exclude<keyof I["globalSpStorePrice"], keyof GlobalSpStorePrice>, never>;
    } & Record<Exclude<keyof I, "globalSpStorePrice">, never>>(object: I): QueryGlobalSpStorePriceByTimeResponse;
    fromSDK(object: QueryGlobalSpStorePriceByTimeResponseSDKType): QueryGlobalSpStorePriceByTimeResponse;
    toSDK(message: QueryGlobalSpStorePriceByTimeResponse): QueryGlobalSpStorePriceByTimeResponseSDKType;
    fromAmino(object: QueryGlobalSpStorePriceByTimeResponseAmino): QueryGlobalSpStorePriceByTimeResponse;
    toAmino(message: QueryGlobalSpStorePriceByTimeResponse): QueryGlobalSpStorePriceByTimeResponseAmino;
    fromAminoMsg(object: QueryGlobalSpStorePriceByTimeResponseAminoMsg): QueryGlobalSpStorePriceByTimeResponse;
    fromProtoMsg(message: QueryGlobalSpStorePriceByTimeResponseProtoMsg): QueryGlobalSpStorePriceByTimeResponse;
    toProto(message: QueryGlobalSpStorePriceByTimeResponse): Uint8Array;
    toProtoMsg(message: QueryGlobalSpStorePriceByTimeResponse): QueryGlobalSpStorePriceByTimeResponseProtoMsg;
};
export declare const QueryStorageProviderRequest: {
    typeUrl: string;
    encode(message: QueryStorageProviderRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProviderRequest;
    fromJSON(object: any): QueryStorageProviderRequest;
    toJSON(message: QueryStorageProviderRequest): unknown;
    fromPartial<I extends {
        id?: number;
    } & {
        id?: number;
    } & Record<Exclude<keyof I, "id">, never>>(object: I): QueryStorageProviderRequest;
    fromSDK(object: QueryStorageProviderRequestSDKType): QueryStorageProviderRequest;
    toSDK(message: QueryStorageProviderRequest): QueryStorageProviderRequestSDKType;
    fromAmino(object: QueryStorageProviderRequestAmino): QueryStorageProviderRequest;
    toAmino(message: QueryStorageProviderRequest): QueryStorageProviderRequestAmino;
    fromAminoMsg(object: QueryStorageProviderRequestAminoMsg): QueryStorageProviderRequest;
    fromProtoMsg(message: QueryStorageProviderRequestProtoMsg): QueryStorageProviderRequest;
    toProto(message: QueryStorageProviderRequest): Uint8Array;
    toProtoMsg(message: QueryStorageProviderRequest): QueryStorageProviderRequestProtoMsg;
};
export declare const QueryStorageProviderResponse: {
    typeUrl: string;
    encode(message: QueryStorageProviderResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProviderResponse;
    fromJSON(object: any): QueryStorageProviderResponse;
    toJSON(message: QueryStorageProviderResponse): unknown;
    fromPartial<I extends {
        storageProvider?: {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        };
    } & {
        storageProvider?: {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        } & {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            } & {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            } & Record<Exclude<keyof I["storageProvider"]["description"], keyof import("./types").Description>, never>;
            blsKey?: Uint8Array;
        } & Record<Exclude<keyof I["storageProvider"], keyof StorageProvider>, never>;
    } & Record<Exclude<keyof I, "storageProvider">, never>>(object: I): QueryStorageProviderResponse;
    fromSDK(object: QueryStorageProviderResponseSDKType): QueryStorageProviderResponse;
    toSDK(message: QueryStorageProviderResponse): QueryStorageProviderResponseSDKType;
    fromAmino(object: QueryStorageProviderResponseAmino): QueryStorageProviderResponse;
    toAmino(message: QueryStorageProviderResponse): QueryStorageProviderResponseAmino;
    fromAminoMsg(object: QueryStorageProviderResponseAminoMsg): QueryStorageProviderResponse;
    fromProtoMsg(message: QueryStorageProviderResponseProtoMsg): QueryStorageProviderResponse;
    toProto(message: QueryStorageProviderResponse): Uint8Array;
    toProtoMsg(message: QueryStorageProviderResponse): QueryStorageProviderResponseProtoMsg;
};
export declare const QueryStorageProviderByOperatorAddressRequest: {
    typeUrl: string;
    encode(message: QueryStorageProviderByOperatorAddressRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProviderByOperatorAddressRequest;
    fromJSON(object: any): QueryStorageProviderByOperatorAddressRequest;
    toJSON(message: QueryStorageProviderByOperatorAddressRequest): unknown;
    fromPartial<I extends {
        operatorAddress?: string;
    } & {
        operatorAddress?: string;
    } & Record<Exclude<keyof I, "operatorAddress">, never>>(object: I): QueryStorageProviderByOperatorAddressRequest;
    fromSDK(object: QueryStorageProviderByOperatorAddressRequestSDKType): QueryStorageProviderByOperatorAddressRequest;
    toSDK(message: QueryStorageProviderByOperatorAddressRequest): QueryStorageProviderByOperatorAddressRequestSDKType;
    fromAmino(object: QueryStorageProviderByOperatorAddressRequestAmino): QueryStorageProviderByOperatorAddressRequest;
    toAmino(message: QueryStorageProviderByOperatorAddressRequest): QueryStorageProviderByOperatorAddressRequestAmino;
    fromAminoMsg(object: QueryStorageProviderByOperatorAddressRequestAminoMsg): QueryStorageProviderByOperatorAddressRequest;
    fromProtoMsg(message: QueryStorageProviderByOperatorAddressRequestProtoMsg): QueryStorageProviderByOperatorAddressRequest;
    toProto(message: QueryStorageProviderByOperatorAddressRequest): Uint8Array;
    toProtoMsg(message: QueryStorageProviderByOperatorAddressRequest): QueryStorageProviderByOperatorAddressRequestProtoMsg;
};
export declare const QueryStorageProviderByOperatorAddressResponse: {
    typeUrl: string;
    encode(message: QueryStorageProviderByOperatorAddressResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProviderByOperatorAddressResponse;
    fromJSON(object: any): QueryStorageProviderByOperatorAddressResponse;
    toJSON(message: QueryStorageProviderByOperatorAddressResponse): unknown;
    fromPartial<I extends {
        storageProvider?: {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        };
    } & {
        storageProvider?: {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            };
            blsKey?: Uint8Array;
        } & {
            id?: number;
            operatorAddress?: string;
            fundingAddress?: string;
            sealAddress?: string;
            approvalAddress?: string;
            gcAddress?: string;
            maintenanceAddress?: string;
            totalDeposit?: string;
            status?: import("./types").Status;
            endpoint?: string;
            description?: {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            } & {
                moniker?: string;
                identity?: string;
                website?: string;
                securityContact?: string;
                details?: string;
            } & Record<Exclude<keyof I["storageProvider"]["description"], keyof import("./types").Description>, never>;
            blsKey?: Uint8Array;
        } & Record<Exclude<keyof I["storageProvider"], keyof StorageProvider>, never>;
    } & Record<Exclude<keyof I, "storageProvider">, never>>(object: I): QueryStorageProviderByOperatorAddressResponse;
    fromSDK(object: QueryStorageProviderByOperatorAddressResponseSDKType): QueryStorageProviderByOperatorAddressResponse;
    toSDK(message: QueryStorageProviderByOperatorAddressResponse): QueryStorageProviderByOperatorAddressResponseSDKType;
    fromAmino(object: QueryStorageProviderByOperatorAddressResponseAmino): QueryStorageProviderByOperatorAddressResponse;
    toAmino(message: QueryStorageProviderByOperatorAddressResponse): QueryStorageProviderByOperatorAddressResponseAmino;
    fromAminoMsg(object: QueryStorageProviderByOperatorAddressResponseAminoMsg): QueryStorageProviderByOperatorAddressResponse;
    fromProtoMsg(message: QueryStorageProviderByOperatorAddressResponseProtoMsg): QueryStorageProviderByOperatorAddressResponse;
    toProto(message: QueryStorageProviderByOperatorAddressResponse): Uint8Array;
    toProtoMsg(message: QueryStorageProviderByOperatorAddressResponse): QueryStorageProviderByOperatorAddressResponseProtoMsg;
};
export declare const QueryStorageProviderMaintenanceRecordsRequest: {
    typeUrl: string;
    encode(message: QueryStorageProviderMaintenanceRecordsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProviderMaintenanceRecordsRequest;
    fromJSON(object: any): QueryStorageProviderMaintenanceRecordsRequest;
    toJSON(message: QueryStorageProviderMaintenanceRecordsRequest): unknown;
    fromPartial<I extends {
        operatorAddress?: string;
    } & {
        operatorAddress?: string;
    } & Record<Exclude<keyof I, "operatorAddress">, never>>(object: I): QueryStorageProviderMaintenanceRecordsRequest;
    fromSDK(object: QueryStorageProviderMaintenanceRecordsRequestSDKType): QueryStorageProviderMaintenanceRecordsRequest;
    toSDK(message: QueryStorageProviderMaintenanceRecordsRequest): QueryStorageProviderMaintenanceRecordsRequestSDKType;
    fromAmino(object: QueryStorageProviderMaintenanceRecordsRequestAmino): QueryStorageProviderMaintenanceRecordsRequest;
    toAmino(message: QueryStorageProviderMaintenanceRecordsRequest): QueryStorageProviderMaintenanceRecordsRequestAmino;
    fromAminoMsg(object: QueryStorageProviderMaintenanceRecordsRequestAminoMsg): QueryStorageProviderMaintenanceRecordsRequest;
    fromProtoMsg(message: QueryStorageProviderMaintenanceRecordsRequestProtoMsg): QueryStorageProviderMaintenanceRecordsRequest;
    toProto(message: QueryStorageProviderMaintenanceRecordsRequest): Uint8Array;
    toProtoMsg(message: QueryStorageProviderMaintenanceRecordsRequest): QueryStorageProviderMaintenanceRecordsRequestProtoMsg;
};
export declare const QueryStorageProviderMaintenanceRecordsResponse: {
    typeUrl: string;
    encode(message: QueryStorageProviderMaintenanceRecordsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStorageProviderMaintenanceRecordsResponse;
    fromJSON(object: any): QueryStorageProviderMaintenanceRecordsResponse;
    toJSON(message: QueryStorageProviderMaintenanceRecordsResponse): unknown;
    fromPartial<I extends {
        records?: {
            height?: string | number | Long.Long;
            requestDuration?: string | number | Long.Long;
            actualDuration?: string | number | Long.Long;
            requestAt?: string | number | Long.Long;
        }[];
    } & {
        records?: {
            height?: string | number | Long.Long;
            requestDuration?: string | number | Long.Long;
            actualDuration?: string | number | Long.Long;
            requestAt?: string | number | Long.Long;
        }[] & ({
            height?: string | number | Long.Long;
            requestDuration?: string | number | Long.Long;
            actualDuration?: string | number | Long.Long;
            requestAt?: string | number | Long.Long;
        } & {
            height?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["records"][number]["height"], keyof Long.Long>, never>);
            requestDuration?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["records"][number]["requestDuration"], keyof Long.Long>, never>);
            actualDuration?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["records"][number]["actualDuration"], keyof Long.Long>, never>);
            requestAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["records"][number]["requestAt"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["records"][number], keyof MaintenanceRecord>, never>)[] & Record<Exclude<keyof I["records"], keyof {
            height?: string | number | Long.Long;
            requestDuration?: string | number | Long.Long;
            actualDuration?: string | number | Long.Long;
            requestAt?: string | number | Long.Long;
        }[]>, never>;
    } & Record<Exclude<keyof I, "records">, never>>(object: I): QueryStorageProviderMaintenanceRecordsResponse;
    fromSDK(object: QueryStorageProviderMaintenanceRecordsResponseSDKType): QueryStorageProviderMaintenanceRecordsResponse;
    toSDK(message: QueryStorageProviderMaintenanceRecordsResponse): QueryStorageProviderMaintenanceRecordsResponseSDKType;
    fromAmino(object: QueryStorageProviderMaintenanceRecordsResponseAmino): QueryStorageProviderMaintenanceRecordsResponse;
    toAmino(message: QueryStorageProviderMaintenanceRecordsResponse): QueryStorageProviderMaintenanceRecordsResponseAmino;
    fromAminoMsg(object: QueryStorageProviderMaintenanceRecordsResponseAminoMsg): QueryStorageProviderMaintenanceRecordsResponse;
    fromProtoMsg(message: QueryStorageProviderMaintenanceRecordsResponseProtoMsg): QueryStorageProviderMaintenanceRecordsResponse;
    toProto(message: QueryStorageProviderMaintenanceRecordsResponse): Uint8Array;
    toProtoMsg(message: QueryStorageProviderMaintenanceRecordsResponse): QueryStorageProviderMaintenanceRecordsResponseProtoMsg;
};
/** Query defines the gRPC querier service. */
export interface Query {
    /** Parameters queries the parameters of the module. */
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** Queries a list of GetStorageProviders items. */
    StorageProviders(request?: QueryStorageProvidersRequest): Promise<QueryStorageProvidersResponse>;
    /** get the latest storage price of specific sp */
    QuerySpStoragePrice(request: QuerySpStoragePriceRequest): Promise<QuerySpStoragePriceResponse>;
    /** get global store price by time */
    QueryGlobalSpStorePriceByTime(request: QueryGlobalSpStorePriceByTimeRequest): Promise<QueryGlobalSpStorePriceByTimeResponse>;
    /** Queries a storage provider with specify id */
    StorageProvider(request: QueryStorageProviderRequest): Promise<QueryStorageProviderResponse>;
    /** Queries a StorageProvider by specify operator address. */
    StorageProviderByOperatorAddress(request: QueryStorageProviderByOperatorAddressRequest): Promise<QueryStorageProviderByOperatorAddressResponse>;
    /** Queries a StorageProvider by specify operator address. */
    StorageProviderMaintenanceRecordsByOperatorAddress(request: QueryStorageProviderMaintenanceRecordsRequest): Promise<QueryStorageProviderMaintenanceRecordsResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    StorageProviders(request?: QueryStorageProvidersRequest): Promise<QueryStorageProvidersResponse>;
    QuerySpStoragePrice(request: QuerySpStoragePriceRequest): Promise<QuerySpStoragePriceResponse>;
    QueryGlobalSpStorePriceByTime(request: QueryGlobalSpStorePriceByTimeRequest): Promise<QueryGlobalSpStorePriceByTimeResponse>;
    StorageProvider(request: QueryStorageProviderRequest): Promise<QueryStorageProviderResponse>;
    StorageProviderByOperatorAddress(request: QueryStorageProviderByOperatorAddressRequest): Promise<QueryStorageProviderByOperatorAddressResponse>;
    StorageProviderMaintenanceRecordsByOperatorAddress(request: QueryStorageProviderMaintenanceRecordsRequest): Promise<QueryStorageProviderMaintenanceRecordsResponse>;
}
