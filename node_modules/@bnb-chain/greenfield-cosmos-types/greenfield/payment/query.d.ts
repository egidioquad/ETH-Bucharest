/// <reference types="long" />
import { PageRequest, PageRequestAmino, PageRequestSDKType, PageResponse, PageResponseAmino, PageResponseSDKType } from "../../cosmos/base/query/v1beta1/pagination";
import { Params, ParamsAmino, ParamsSDKType } from "./params";
import { OutFlow, OutFlowAmino, OutFlowSDKType } from "./out_flow";
import { StreamRecord, StreamRecordAmino, StreamRecordSDKType } from "./stream_record";
import { PaymentAccountCount, PaymentAccountCountAmino, PaymentAccountCountSDKType } from "./payment_account_count";
import { PaymentAccount, PaymentAccountAmino, PaymentAccountSDKType } from "./payment_account";
import { AutoSettleRecord, AutoSettleRecordAmino, AutoSettleRecordSDKType } from "./auto_settle_record";
import { DelayedWithdrawalRecord, DelayedWithdrawalRecordAmino, DelayedWithdrawalRecordSDKType } from "./delayed_withdrawal_record";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.payment";
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
export interface QueryParamsRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryParamsRequest";
    value: Uint8Array;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestAmino {
}
export interface QueryParamsRequestAminoMsg {
    type: "/greenfield.payment.QueryParamsRequest";
    value: QueryParamsRequestAmino;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestSDKType {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
export interface QueryParamsResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryParamsResponse";
    value: Uint8Array;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseAmino {
    /** params holds all the parameters of this module. */
    params?: ParamsAmino;
}
export interface QueryParamsResponseAminoMsg {
    type: "/greenfield.payment.QueryParamsResponse";
    value: QueryParamsResponseAmino;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseSDKType {
    params: ParamsSDKType;
}
/** QueryParamsByTimestampRequest is request type for the Query/ParamsByTimestamp RPC method with timestamp. */
export interface QueryParamsByTimestampRequest {
    /** the timestamp of the block time you want to query */
    timestamp: Long;
}
export interface QueryParamsByTimestampRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryParamsByTimestampRequest";
    value: Uint8Array;
}
/** QueryParamsByTimestampRequest is request type for the Query/ParamsByTimestamp RPC method with timestamp. */
export interface QueryParamsByTimestampRequestAmino {
    /** the timestamp of the block time you want to query */
    timestamp?: string;
}
export interface QueryParamsByTimestampRequestAminoMsg {
    type: "/greenfield.payment.QueryParamsByTimestampRequest";
    value: QueryParamsByTimestampRequestAmino;
}
/** QueryParamsByTimestampRequest is request type for the Query/ParamsByTimestamp RPC method with timestamp. */
export interface QueryParamsByTimestampRequestSDKType {
    timestamp: Long;
}
/** QueryParamsByTimestampResponse is response type for the Query/ParamsByTimestamp RPC method with timestamp. */
export interface QueryParamsByTimestampResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
export interface QueryParamsByTimestampResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryParamsByTimestampResponse";
    value: Uint8Array;
}
/** QueryParamsByTimestampResponse is response type for the Query/ParamsByTimestamp RPC method with timestamp. */
export interface QueryParamsByTimestampResponseAmino {
    /** params holds all the parameters of this module. */
    params?: ParamsAmino;
}
export interface QueryParamsByTimestampResponseAminoMsg {
    type: "/greenfield.payment.QueryParamsByTimestampResponse";
    value: QueryParamsByTimestampResponseAmino;
}
/** QueryParamsByTimestampResponse is response type for the Query/ParamsByTimestamp RPC method with timestamp. */
export interface QueryParamsByTimestampResponseSDKType {
    params: ParamsSDKType;
}
export interface QueryOutFlowsRequest {
    account: string;
}
export interface QueryOutFlowsRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryOutFlowsRequest";
    value: Uint8Array;
}
export interface QueryOutFlowsRequestAmino {
    account?: string;
}
export interface QueryOutFlowsRequestAminoMsg {
    type: "/greenfield.payment.QueryOutFlowsRequest";
    value: QueryOutFlowsRequestAmino;
}
export interface QueryOutFlowsRequestSDKType {
    account: string;
}
export interface QueryOutFlowsResponse {
    outFlows: OutFlow[];
}
export interface QueryOutFlowsResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryOutFlowsResponse";
    value: Uint8Array;
}
export interface QueryOutFlowsResponseAmino {
    out_flows?: OutFlowAmino[];
}
export interface QueryOutFlowsResponseAminoMsg {
    type: "/greenfield.payment.QueryOutFlowsResponse";
    value: QueryOutFlowsResponseAmino;
}
export interface QueryOutFlowsResponseSDKType {
    out_flows: OutFlowSDKType[];
}
export interface QueryGetStreamRecordRequest {
    account: string;
}
export interface QueryGetStreamRecordRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryGetStreamRecordRequest";
    value: Uint8Array;
}
export interface QueryGetStreamRecordRequestAmino {
    account?: string;
}
export interface QueryGetStreamRecordRequestAminoMsg {
    type: "/greenfield.payment.QueryGetStreamRecordRequest";
    value: QueryGetStreamRecordRequestAmino;
}
export interface QueryGetStreamRecordRequestSDKType {
    account: string;
}
export interface QueryGetStreamRecordResponse {
    streamRecord: StreamRecord;
}
export interface QueryGetStreamRecordResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryGetStreamRecordResponse";
    value: Uint8Array;
}
export interface QueryGetStreamRecordResponseAmino {
    stream_record?: StreamRecordAmino;
}
export interface QueryGetStreamRecordResponseAminoMsg {
    type: "/greenfield.payment.QueryGetStreamRecordResponse";
    value: QueryGetStreamRecordResponseAmino;
}
export interface QueryGetStreamRecordResponseSDKType {
    stream_record: StreamRecordSDKType;
}
export interface QueryStreamRecordsRequest {
    pagination?: PageRequest;
}
export interface QueryStreamRecordsRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryStreamRecordsRequest";
    value: Uint8Array;
}
export interface QueryStreamRecordsRequestAmino {
    pagination?: PageRequestAmino;
}
export interface QueryStreamRecordsRequestAminoMsg {
    type: "/greenfield.payment.QueryStreamRecordsRequest";
    value: QueryStreamRecordsRequestAmino;
}
export interface QueryStreamRecordsRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryStreamRecordsResponse {
    streamRecords: StreamRecord[];
    pagination?: PageResponse;
}
export interface QueryStreamRecordsResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryStreamRecordsResponse";
    value: Uint8Array;
}
export interface QueryStreamRecordsResponseAmino {
    stream_records?: StreamRecordAmino[];
    pagination?: PageResponseAmino;
}
export interface QueryStreamRecordsResponseAminoMsg {
    type: "/greenfield.payment.QueryStreamRecordsResponse";
    value: QueryStreamRecordsResponseAmino;
}
export interface QueryStreamRecordsResponseSDKType {
    stream_records: StreamRecordSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryPaymentAccountCountRequest {
    owner: string;
}
export interface QueryPaymentAccountCountRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountCountRequest";
    value: Uint8Array;
}
export interface QueryPaymentAccountCountRequestAmino {
    owner?: string;
}
export interface QueryPaymentAccountCountRequestAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountCountRequest";
    value: QueryPaymentAccountCountRequestAmino;
}
export interface QueryPaymentAccountCountRequestSDKType {
    owner: string;
}
export interface QueryPaymentAccountCountResponse {
    paymentAccountCount: PaymentAccountCount;
}
export interface QueryPaymentAccountCountResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountCountResponse";
    value: Uint8Array;
}
export interface QueryPaymentAccountCountResponseAmino {
    payment_account_count?: PaymentAccountCountAmino;
}
export interface QueryPaymentAccountCountResponseAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountCountResponse";
    value: QueryPaymentAccountCountResponseAmino;
}
export interface QueryPaymentAccountCountResponseSDKType {
    payment_account_count: PaymentAccountCountSDKType;
}
export interface QueryPaymentAccountCountsRequest {
    pagination?: PageRequest;
}
export interface QueryPaymentAccountCountsRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountCountsRequest";
    value: Uint8Array;
}
export interface QueryPaymentAccountCountsRequestAmino {
    pagination?: PageRequestAmino;
}
export interface QueryPaymentAccountCountsRequestAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountCountsRequest";
    value: QueryPaymentAccountCountsRequestAmino;
}
export interface QueryPaymentAccountCountsRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryPaymentAccountCountsResponse {
    paymentAccountCounts: PaymentAccountCount[];
    pagination?: PageResponse;
}
export interface QueryPaymentAccountCountsResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountCountsResponse";
    value: Uint8Array;
}
export interface QueryPaymentAccountCountsResponseAmino {
    payment_account_counts?: PaymentAccountCountAmino[];
    pagination?: PageResponseAmino;
}
export interface QueryPaymentAccountCountsResponseAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountCountsResponse";
    value: QueryPaymentAccountCountsResponseAmino;
}
export interface QueryPaymentAccountCountsResponseSDKType {
    payment_account_counts: PaymentAccountCountSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryPaymentAccountRequest {
    addr: string;
}
export interface QueryPaymentAccountRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountRequest";
    value: Uint8Array;
}
export interface QueryPaymentAccountRequestAmino {
    addr?: string;
}
export interface QueryPaymentAccountRequestAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountRequest";
    value: QueryPaymentAccountRequestAmino;
}
export interface QueryPaymentAccountRequestSDKType {
    addr: string;
}
export interface QueryPaymentAccountResponse {
    paymentAccount: PaymentAccount;
}
export interface QueryPaymentAccountResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountResponse";
    value: Uint8Array;
}
export interface QueryPaymentAccountResponseAmino {
    payment_account?: PaymentAccountAmino;
}
export interface QueryPaymentAccountResponseAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountResponse";
    value: QueryPaymentAccountResponseAmino;
}
export interface QueryPaymentAccountResponseSDKType {
    payment_account: PaymentAccountSDKType;
}
export interface QueryPaymentAccountsRequest {
    pagination?: PageRequest;
}
export interface QueryPaymentAccountsRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountsRequest";
    value: Uint8Array;
}
export interface QueryPaymentAccountsRequestAmino {
    pagination?: PageRequestAmino;
}
export interface QueryPaymentAccountsRequestAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountsRequest";
    value: QueryPaymentAccountsRequestAmino;
}
export interface QueryPaymentAccountsRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryPaymentAccountsResponse {
    paymentAccounts: PaymentAccount[];
    pagination?: PageResponse;
}
export interface QueryPaymentAccountsResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountsResponse";
    value: Uint8Array;
}
export interface QueryPaymentAccountsResponseAmino {
    payment_accounts?: PaymentAccountAmino[];
    pagination?: PageResponseAmino;
}
export interface QueryPaymentAccountsResponseAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountsResponse";
    value: QueryPaymentAccountsResponseAmino;
}
export interface QueryPaymentAccountsResponseSDKType {
    payment_accounts: PaymentAccountSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryDynamicBalanceRequest {
    account: string;
}
export interface QueryDynamicBalanceRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryDynamicBalanceRequest";
    value: Uint8Array;
}
export interface QueryDynamicBalanceRequestAmino {
    account?: string;
}
export interface QueryDynamicBalanceRequestAminoMsg {
    type: "/greenfield.payment.QueryDynamicBalanceRequest";
    value: QueryDynamicBalanceRequestAmino;
}
export interface QueryDynamicBalanceRequestSDKType {
    account: string;
}
export interface QueryDynamicBalanceResponse {
    /** dynamic balance is static balance + flowDelta */
    dynamicBalance: string;
    /** the stream record of the given account, if it does not exist, it will be default values */
    streamRecord: StreamRecord;
    /** the timestamp of the current block */
    currentTimestamp: Long;
    /** bank_balance is the BNB balance of the bank module */
    bankBalance: string;
    /** available_balance is bank balance + static balance */
    availableBalance: string;
    /** locked_fee is buffer balance + locked balance */
    lockedFee: string;
    /** change_rate is the netflow rate of the given account */
    changeRate: string;
}
export interface QueryDynamicBalanceResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryDynamicBalanceResponse";
    value: Uint8Array;
}
export interface QueryDynamicBalanceResponseAmino {
    /** dynamic balance is static balance + flowDelta */
    dynamic_balance?: string;
    /** the stream record of the given account, if it does not exist, it will be default values */
    stream_record?: StreamRecordAmino;
    /** the timestamp of the current block */
    current_timestamp?: string;
    /** bank_balance is the BNB balance of the bank module */
    bank_balance?: string;
    /** available_balance is bank balance + static balance */
    available_balance?: string;
    /** locked_fee is buffer balance + locked balance */
    locked_fee?: string;
    /** change_rate is the netflow rate of the given account */
    change_rate?: string;
}
export interface QueryDynamicBalanceResponseAminoMsg {
    type: "/greenfield.payment.QueryDynamicBalanceResponse";
    value: QueryDynamicBalanceResponseAmino;
}
export interface QueryDynamicBalanceResponseSDKType {
    dynamic_balance: string;
    stream_record: StreamRecordSDKType;
    current_timestamp: Long;
    bank_balance: string;
    available_balance: string;
    locked_fee: string;
    change_rate: string;
}
export interface QueryPaymentAccountsByOwnerRequest {
    owner: string;
}
export interface QueryPaymentAccountsByOwnerRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountsByOwnerRequest";
    value: Uint8Array;
}
export interface QueryPaymentAccountsByOwnerRequestAmino {
    owner?: string;
}
export interface QueryPaymentAccountsByOwnerRequestAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountsByOwnerRequest";
    value: QueryPaymentAccountsByOwnerRequestAmino;
}
export interface QueryPaymentAccountsByOwnerRequestSDKType {
    owner: string;
}
export interface QueryPaymentAccountsByOwnerResponse {
    paymentAccounts: string[];
}
export interface QueryPaymentAccountsByOwnerResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryPaymentAccountsByOwnerResponse";
    value: Uint8Array;
}
export interface QueryPaymentAccountsByOwnerResponseAmino {
    paymentAccounts?: string[];
}
export interface QueryPaymentAccountsByOwnerResponseAminoMsg {
    type: "/greenfield.payment.QueryPaymentAccountsByOwnerResponse";
    value: QueryPaymentAccountsByOwnerResponseAmino;
}
export interface QueryPaymentAccountsByOwnerResponseSDKType {
    paymentAccounts: string[];
}
export interface QueryAutoSettleRecordsRequest {
    pagination?: PageRequest;
}
export interface QueryAutoSettleRecordsRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryAutoSettleRecordsRequest";
    value: Uint8Array;
}
export interface QueryAutoSettleRecordsRequestAmino {
    pagination?: PageRequestAmino;
}
export interface QueryAutoSettleRecordsRequestAminoMsg {
    type: "/greenfield.payment.QueryAutoSettleRecordsRequest";
    value: QueryAutoSettleRecordsRequestAmino;
}
export interface QueryAutoSettleRecordsRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryAutoSettleRecordsResponse {
    autoSettleRecords: AutoSettleRecord[];
    pagination?: PageResponse;
}
export interface QueryAutoSettleRecordsResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryAutoSettleRecordsResponse";
    value: Uint8Array;
}
export interface QueryAutoSettleRecordsResponseAmino {
    auto_settle_records?: AutoSettleRecordAmino[];
    pagination?: PageResponseAmino;
}
export interface QueryAutoSettleRecordsResponseAminoMsg {
    type: "/greenfield.payment.QueryAutoSettleRecordsResponse";
    value: QueryAutoSettleRecordsResponseAmino;
}
export interface QueryAutoSettleRecordsResponseSDKType {
    auto_settle_records: AutoSettleRecordSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryDelayedWithdrawalRequest {
    account: string;
}
export interface QueryDelayedWithdrawalRequestProtoMsg {
    typeUrl: "/greenfield.payment.QueryDelayedWithdrawalRequest";
    value: Uint8Array;
}
export interface QueryDelayedWithdrawalRequestAmino {
    account?: string;
}
export interface QueryDelayedWithdrawalRequestAminoMsg {
    type: "/greenfield.payment.QueryDelayedWithdrawalRequest";
    value: QueryDelayedWithdrawalRequestAmino;
}
export interface QueryDelayedWithdrawalRequestSDKType {
    account: string;
}
export interface QueryDelayedWithdrawalResponse {
    delayedWithdrawal: DelayedWithdrawalRecord;
}
export interface QueryDelayedWithdrawalResponseProtoMsg {
    typeUrl: "/greenfield.payment.QueryDelayedWithdrawalResponse";
    value: Uint8Array;
}
export interface QueryDelayedWithdrawalResponseAmino {
    delayed_withdrawal?: DelayedWithdrawalRecordAmino;
}
export interface QueryDelayedWithdrawalResponseAminoMsg {
    type: "/greenfield.payment.QueryDelayedWithdrawalResponse";
    value: QueryDelayedWithdrawalResponseAmino;
}
export interface QueryDelayedWithdrawalResponseSDKType {
    delayed_withdrawal: DelayedWithdrawalRecordSDKType;
}
export declare const QueryParamsRequest: {
    typeUrl: string;
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
    fromSDK(_: QueryParamsRequestSDKType): QueryParamsRequest;
    toSDK(_: QueryParamsRequest): QueryParamsRequestSDKType;
    fromAmino(_: QueryParamsRequestAmino): QueryParamsRequest;
    toAmino(_: QueryParamsRequest): QueryParamsRequestAmino;
    fromAminoMsg(object: QueryParamsRequestAminoMsg): QueryParamsRequest;
    fromProtoMsg(message: QueryParamsRequestProtoMsg): QueryParamsRequest;
    toProto(message: QueryParamsRequest): Uint8Array;
    toProtoMsg(message: QueryParamsRequest): QueryParamsRequestProtoMsg;
};
export declare const QueryParamsResponse: {
    typeUrl: string;
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            versionedParams?: {
                reserveTime?: string | number | Long.Long;
                validatorTaxRate?: string;
            };
            paymentAccountCountLimit?: string | number | Long.Long;
            forcedSettleTime?: string | number | Long.Long;
            maxAutoSettleFlowCount?: string | number | Long.Long;
            maxAutoResumeFlowCount?: string | number | Long.Long;
            feeDenom?: string;
            withdrawTimeLockThreshold?: string;
            withdrawTimeLockDuration?: string | number | Long.Long;
        };
    } & {
        params?: {
            versionedParams?: {
                reserveTime?: string | number | Long.Long;
                validatorTaxRate?: string;
            };
            paymentAccountCountLimit?: string | number | Long.Long;
            forcedSettleTime?: string | number | Long.Long;
            maxAutoSettleFlowCount?: string | number | Long.Long;
            maxAutoResumeFlowCount?: string | number | Long.Long;
            feeDenom?: string;
            withdrawTimeLockThreshold?: string;
            withdrawTimeLockDuration?: string | number | Long.Long;
        } & {
            versionedParams?: {
                reserveTime?: string | number | Long.Long;
                validatorTaxRate?: string;
            } & {
                reserveTime?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["reserveTime"], keyof Long.Long>, never>);
                validatorTaxRate?: string;
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>;
            paymentAccountCountLimit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["paymentAccountCountLimit"], keyof Long.Long>, never>);
            forcedSettleTime?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["forcedSettleTime"], keyof Long.Long>, never>);
            maxAutoSettleFlowCount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxAutoSettleFlowCount"], keyof Long.Long>, never>);
            maxAutoResumeFlowCount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxAutoResumeFlowCount"], keyof Long.Long>, never>);
            feeDenom?: string;
            withdrawTimeLockThreshold?: string;
            withdrawTimeLockDuration?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["withdrawTimeLockDuration"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
    fromSDK(object: QueryParamsResponseSDKType): QueryParamsResponse;
    toSDK(message: QueryParamsResponse): QueryParamsResponseSDKType;
    fromAmino(object: QueryParamsResponseAmino): QueryParamsResponse;
    toAmino(message: QueryParamsResponse): QueryParamsResponseAmino;
    fromAminoMsg(object: QueryParamsResponseAminoMsg): QueryParamsResponse;
    fromProtoMsg(message: QueryParamsResponseProtoMsg): QueryParamsResponse;
    toProto(message: QueryParamsResponse): Uint8Array;
    toProtoMsg(message: QueryParamsResponse): QueryParamsResponseProtoMsg;
};
export declare const QueryParamsByTimestampRequest: {
    typeUrl: string;
    encode(message: QueryParamsByTimestampRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsByTimestampRequest;
    fromJSON(object: any): QueryParamsByTimestampRequest;
    toJSON(message: QueryParamsByTimestampRequest): unknown;
    fromPartial<I extends {
        timestamp?: string | number | Long.Long;
    } & {
        timestamp?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["timestamp"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, "timestamp">, never>>(object: I): QueryParamsByTimestampRequest;
    fromSDK(object: QueryParamsByTimestampRequestSDKType): QueryParamsByTimestampRequest;
    toSDK(message: QueryParamsByTimestampRequest): QueryParamsByTimestampRequestSDKType;
    fromAmino(object: QueryParamsByTimestampRequestAmino): QueryParamsByTimestampRequest;
    toAmino(message: QueryParamsByTimestampRequest): QueryParamsByTimestampRequestAmino;
    fromAminoMsg(object: QueryParamsByTimestampRequestAminoMsg): QueryParamsByTimestampRequest;
    fromProtoMsg(message: QueryParamsByTimestampRequestProtoMsg): QueryParamsByTimestampRequest;
    toProto(message: QueryParamsByTimestampRequest): Uint8Array;
    toProtoMsg(message: QueryParamsByTimestampRequest): QueryParamsByTimestampRequestProtoMsg;
};
export declare const QueryParamsByTimestampResponse: {
    typeUrl: string;
    encode(message: QueryParamsByTimestampResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsByTimestampResponse;
    fromJSON(object: any): QueryParamsByTimestampResponse;
    toJSON(message: QueryParamsByTimestampResponse): unknown;
    fromPartial<I extends {
        params?: {
            versionedParams?: {
                reserveTime?: string | number | Long.Long;
                validatorTaxRate?: string;
            };
            paymentAccountCountLimit?: string | number | Long.Long;
            forcedSettleTime?: string | number | Long.Long;
            maxAutoSettleFlowCount?: string | number | Long.Long;
            maxAutoResumeFlowCount?: string | number | Long.Long;
            feeDenom?: string;
            withdrawTimeLockThreshold?: string;
            withdrawTimeLockDuration?: string | number | Long.Long;
        };
    } & {
        params?: {
            versionedParams?: {
                reserveTime?: string | number | Long.Long;
                validatorTaxRate?: string;
            };
            paymentAccountCountLimit?: string | number | Long.Long;
            forcedSettleTime?: string | number | Long.Long;
            maxAutoSettleFlowCount?: string | number | Long.Long;
            maxAutoResumeFlowCount?: string | number | Long.Long;
            feeDenom?: string;
            withdrawTimeLockThreshold?: string;
            withdrawTimeLockDuration?: string | number | Long.Long;
        } & {
            versionedParams?: {
                reserveTime?: string | number | Long.Long;
                validatorTaxRate?: string;
            } & {
                reserveTime?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["reserveTime"], keyof Long.Long>, never>);
                validatorTaxRate?: string;
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>;
            paymentAccountCountLimit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["paymentAccountCountLimit"], keyof Long.Long>, never>);
            forcedSettleTime?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["forcedSettleTime"], keyof Long.Long>, never>);
            maxAutoSettleFlowCount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxAutoSettleFlowCount"], keyof Long.Long>, never>);
            maxAutoResumeFlowCount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxAutoResumeFlowCount"], keyof Long.Long>, never>);
            feeDenom?: string;
            withdrawTimeLockThreshold?: string;
            withdrawTimeLockDuration?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["withdrawTimeLockDuration"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsByTimestampResponse;
    fromSDK(object: QueryParamsByTimestampResponseSDKType): QueryParamsByTimestampResponse;
    toSDK(message: QueryParamsByTimestampResponse): QueryParamsByTimestampResponseSDKType;
    fromAmino(object: QueryParamsByTimestampResponseAmino): QueryParamsByTimestampResponse;
    toAmino(message: QueryParamsByTimestampResponse): QueryParamsByTimestampResponseAmino;
    fromAminoMsg(object: QueryParamsByTimestampResponseAminoMsg): QueryParamsByTimestampResponse;
    fromProtoMsg(message: QueryParamsByTimestampResponseProtoMsg): QueryParamsByTimestampResponse;
    toProto(message: QueryParamsByTimestampResponse): Uint8Array;
    toProtoMsg(message: QueryParamsByTimestampResponse): QueryParamsByTimestampResponseProtoMsg;
};
export declare const QueryOutFlowsRequest: {
    typeUrl: string;
    encode(message: QueryOutFlowsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryOutFlowsRequest;
    fromJSON(object: any): QueryOutFlowsRequest;
    toJSON(message: QueryOutFlowsRequest): unknown;
    fromPartial<I extends {
        account?: string;
    } & {
        account?: string;
    } & Record<Exclude<keyof I, "account">, never>>(object: I): QueryOutFlowsRequest;
    fromSDK(object: QueryOutFlowsRequestSDKType): QueryOutFlowsRequest;
    toSDK(message: QueryOutFlowsRequest): QueryOutFlowsRequestSDKType;
    fromAmino(object: QueryOutFlowsRequestAmino): QueryOutFlowsRequest;
    toAmino(message: QueryOutFlowsRequest): QueryOutFlowsRequestAmino;
    fromAminoMsg(object: QueryOutFlowsRequestAminoMsg): QueryOutFlowsRequest;
    fromProtoMsg(message: QueryOutFlowsRequestProtoMsg): QueryOutFlowsRequest;
    toProto(message: QueryOutFlowsRequest): Uint8Array;
    toProtoMsg(message: QueryOutFlowsRequest): QueryOutFlowsRequestProtoMsg;
};
export declare const QueryOutFlowsResponse: {
    typeUrl: string;
    encode(message: QueryOutFlowsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryOutFlowsResponse;
    fromJSON(object: any): QueryOutFlowsResponse;
    toJSON(message: QueryOutFlowsResponse): unknown;
    fromPartial<I extends {
        outFlows?: {
            toAddress?: string;
            rate?: string;
            status?: import("./out_flow").OutFlowStatus;
        }[];
    } & {
        outFlows?: {
            toAddress?: string;
            rate?: string;
            status?: import("./out_flow").OutFlowStatus;
        }[] & ({
            toAddress?: string;
            rate?: string;
            status?: import("./out_flow").OutFlowStatus;
        } & {
            toAddress?: string;
            rate?: string;
            status?: import("./out_flow").OutFlowStatus;
        } & Record<Exclude<keyof I["outFlows"][number], keyof OutFlow>, never>)[] & Record<Exclude<keyof I["outFlows"], keyof {
            toAddress?: string;
            rate?: string;
            status?: import("./out_flow").OutFlowStatus;
        }[]>, never>;
    } & Record<Exclude<keyof I, "outFlows">, never>>(object: I): QueryOutFlowsResponse;
    fromSDK(object: QueryOutFlowsResponseSDKType): QueryOutFlowsResponse;
    toSDK(message: QueryOutFlowsResponse): QueryOutFlowsResponseSDKType;
    fromAmino(object: QueryOutFlowsResponseAmino): QueryOutFlowsResponse;
    toAmino(message: QueryOutFlowsResponse): QueryOutFlowsResponseAmino;
    fromAminoMsg(object: QueryOutFlowsResponseAminoMsg): QueryOutFlowsResponse;
    fromProtoMsg(message: QueryOutFlowsResponseProtoMsg): QueryOutFlowsResponse;
    toProto(message: QueryOutFlowsResponse): Uint8Array;
    toProtoMsg(message: QueryOutFlowsResponse): QueryOutFlowsResponseProtoMsg;
};
export declare const QueryGetStreamRecordRequest: {
    typeUrl: string;
    encode(message: QueryGetStreamRecordRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetStreamRecordRequest;
    fromJSON(object: any): QueryGetStreamRecordRequest;
    toJSON(message: QueryGetStreamRecordRequest): unknown;
    fromPartial<I extends {
        account?: string;
    } & {
        account?: string;
    } & Record<Exclude<keyof I, "account">, never>>(object: I): QueryGetStreamRecordRequest;
    fromSDK(object: QueryGetStreamRecordRequestSDKType): QueryGetStreamRecordRequest;
    toSDK(message: QueryGetStreamRecordRequest): QueryGetStreamRecordRequestSDKType;
    fromAmino(object: QueryGetStreamRecordRequestAmino): QueryGetStreamRecordRequest;
    toAmino(message: QueryGetStreamRecordRequest): QueryGetStreamRecordRequestAmino;
    fromAminoMsg(object: QueryGetStreamRecordRequestAminoMsg): QueryGetStreamRecordRequest;
    fromProtoMsg(message: QueryGetStreamRecordRequestProtoMsg): QueryGetStreamRecordRequest;
    toProto(message: QueryGetStreamRecordRequest): Uint8Array;
    toProtoMsg(message: QueryGetStreamRecordRequest): QueryGetStreamRecordRequestProtoMsg;
};
export declare const QueryGetStreamRecordResponse: {
    typeUrl: string;
    encode(message: QueryGetStreamRecordResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGetStreamRecordResponse;
    fromJSON(object: any): QueryGetStreamRecordResponse;
    toJSON(message: QueryGetStreamRecordResponse): unknown;
    fromPartial<I extends {
        streamRecord?: {
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        };
    } & {
        streamRecord?: {
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        } & {
            account?: string;
            crudTimestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecord"]["crudTimestamp"], keyof Long.Long>, never>);
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecord"]["settleTimestamp"], keyof Long.Long>, never>);
            outFlowCount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecord"]["outFlowCount"], keyof Long.Long>, never>);
            frozenNetflowRate?: string;
        } & Record<Exclude<keyof I["streamRecord"], keyof StreamRecord>, never>;
    } & Record<Exclude<keyof I, "streamRecord">, never>>(object: I): QueryGetStreamRecordResponse;
    fromSDK(object: QueryGetStreamRecordResponseSDKType): QueryGetStreamRecordResponse;
    toSDK(message: QueryGetStreamRecordResponse): QueryGetStreamRecordResponseSDKType;
    fromAmino(object: QueryGetStreamRecordResponseAmino): QueryGetStreamRecordResponse;
    toAmino(message: QueryGetStreamRecordResponse): QueryGetStreamRecordResponseAmino;
    fromAminoMsg(object: QueryGetStreamRecordResponseAminoMsg): QueryGetStreamRecordResponse;
    fromProtoMsg(message: QueryGetStreamRecordResponseProtoMsg): QueryGetStreamRecordResponse;
    toProto(message: QueryGetStreamRecordResponse): Uint8Array;
    toProtoMsg(message: QueryGetStreamRecordResponse): QueryGetStreamRecordResponseProtoMsg;
};
export declare const QueryStreamRecordsRequest: {
    typeUrl: string;
    encode(message: QueryStreamRecordsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStreamRecordsRequest;
    fromJSON(object: any): QueryStreamRecordsRequest;
    toJSON(message: QueryStreamRecordsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryStreamRecordsRequest;
    fromSDK(object: QueryStreamRecordsRequestSDKType): QueryStreamRecordsRequest;
    toSDK(message: QueryStreamRecordsRequest): QueryStreamRecordsRequestSDKType;
    fromAmino(object: QueryStreamRecordsRequestAmino): QueryStreamRecordsRequest;
    toAmino(message: QueryStreamRecordsRequest): QueryStreamRecordsRequestAmino;
    fromAminoMsg(object: QueryStreamRecordsRequestAminoMsg): QueryStreamRecordsRequest;
    fromProtoMsg(message: QueryStreamRecordsRequestProtoMsg): QueryStreamRecordsRequest;
    toProto(message: QueryStreamRecordsRequest): Uint8Array;
    toProtoMsg(message: QueryStreamRecordsRequest): QueryStreamRecordsRequestProtoMsg;
};
export declare const QueryStreamRecordsResponse: {
    typeUrl: string;
    encode(message: QueryStreamRecordsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryStreamRecordsResponse;
    fromJSON(object: any): QueryStreamRecordsResponse;
    toJSON(message: QueryStreamRecordsResponse): unknown;
    fromPartial<I extends {
        streamRecords?: {
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        streamRecords?: {
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        }[] & ({
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        } & {
            account?: string;
            crudTimestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecords"][number]["crudTimestamp"], keyof Long.Long>, never>);
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecords"][number]["settleTimestamp"], keyof Long.Long>, never>);
            outFlowCount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecords"][number]["outFlowCount"], keyof Long.Long>, never>);
            frozenNetflowRate?: string;
        } & Record<Exclude<keyof I["streamRecords"][number], keyof StreamRecord>, never>)[] & Record<Exclude<keyof I["streamRecords"], keyof {
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryStreamRecordsResponse>, never>>(object: I): QueryStreamRecordsResponse;
    fromSDK(object: QueryStreamRecordsResponseSDKType): QueryStreamRecordsResponse;
    toSDK(message: QueryStreamRecordsResponse): QueryStreamRecordsResponseSDKType;
    fromAmino(object: QueryStreamRecordsResponseAmino): QueryStreamRecordsResponse;
    toAmino(message: QueryStreamRecordsResponse): QueryStreamRecordsResponseAmino;
    fromAminoMsg(object: QueryStreamRecordsResponseAminoMsg): QueryStreamRecordsResponse;
    fromProtoMsg(message: QueryStreamRecordsResponseProtoMsg): QueryStreamRecordsResponse;
    toProto(message: QueryStreamRecordsResponse): Uint8Array;
    toProtoMsg(message: QueryStreamRecordsResponse): QueryStreamRecordsResponseProtoMsg;
};
export declare const QueryPaymentAccountCountRequest: {
    typeUrl: string;
    encode(message: QueryPaymentAccountCountRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountCountRequest;
    fromJSON(object: any): QueryPaymentAccountCountRequest;
    toJSON(message: QueryPaymentAccountCountRequest): unknown;
    fromPartial<I extends {
        owner?: string;
    } & {
        owner?: string;
    } & Record<Exclude<keyof I, "owner">, never>>(object: I): QueryPaymentAccountCountRequest;
    fromSDK(object: QueryPaymentAccountCountRequestSDKType): QueryPaymentAccountCountRequest;
    toSDK(message: QueryPaymentAccountCountRequest): QueryPaymentAccountCountRequestSDKType;
    fromAmino(object: QueryPaymentAccountCountRequestAmino): QueryPaymentAccountCountRequest;
    toAmino(message: QueryPaymentAccountCountRequest): QueryPaymentAccountCountRequestAmino;
    fromAminoMsg(object: QueryPaymentAccountCountRequestAminoMsg): QueryPaymentAccountCountRequest;
    fromProtoMsg(message: QueryPaymentAccountCountRequestProtoMsg): QueryPaymentAccountCountRequest;
    toProto(message: QueryPaymentAccountCountRequest): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountCountRequest): QueryPaymentAccountCountRequestProtoMsg;
};
export declare const QueryPaymentAccountCountResponse: {
    typeUrl: string;
    encode(message: QueryPaymentAccountCountResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountCountResponse;
    fromJSON(object: any): QueryPaymentAccountCountResponse;
    toJSON(message: QueryPaymentAccountCountResponse): unknown;
    fromPartial<I extends {
        paymentAccountCount?: {
            owner?: string;
            count?: string | number | Long.Long;
        };
    } & {
        paymentAccountCount?: {
            owner?: string;
            count?: string | number | Long.Long;
        } & {
            owner?: string;
            count?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["paymentAccountCount"]["count"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["paymentAccountCount"], keyof PaymentAccountCount>, never>;
    } & Record<Exclude<keyof I, "paymentAccountCount">, never>>(object: I): QueryPaymentAccountCountResponse;
    fromSDK(object: QueryPaymentAccountCountResponseSDKType): QueryPaymentAccountCountResponse;
    toSDK(message: QueryPaymentAccountCountResponse): QueryPaymentAccountCountResponseSDKType;
    fromAmino(object: QueryPaymentAccountCountResponseAmino): QueryPaymentAccountCountResponse;
    toAmino(message: QueryPaymentAccountCountResponse): QueryPaymentAccountCountResponseAmino;
    fromAminoMsg(object: QueryPaymentAccountCountResponseAminoMsg): QueryPaymentAccountCountResponse;
    fromProtoMsg(message: QueryPaymentAccountCountResponseProtoMsg): QueryPaymentAccountCountResponse;
    toProto(message: QueryPaymentAccountCountResponse): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountCountResponse): QueryPaymentAccountCountResponseProtoMsg;
};
export declare const QueryPaymentAccountCountsRequest: {
    typeUrl: string;
    encode(message: QueryPaymentAccountCountsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountCountsRequest;
    fromJSON(object: any): QueryPaymentAccountCountsRequest;
    toJSON(message: QueryPaymentAccountCountsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryPaymentAccountCountsRequest;
    fromSDK(object: QueryPaymentAccountCountsRequestSDKType): QueryPaymentAccountCountsRequest;
    toSDK(message: QueryPaymentAccountCountsRequest): QueryPaymentAccountCountsRequestSDKType;
    fromAmino(object: QueryPaymentAccountCountsRequestAmino): QueryPaymentAccountCountsRequest;
    toAmino(message: QueryPaymentAccountCountsRequest): QueryPaymentAccountCountsRequestAmino;
    fromAminoMsg(object: QueryPaymentAccountCountsRequestAminoMsg): QueryPaymentAccountCountsRequest;
    fromProtoMsg(message: QueryPaymentAccountCountsRequestProtoMsg): QueryPaymentAccountCountsRequest;
    toProto(message: QueryPaymentAccountCountsRequest): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountCountsRequest): QueryPaymentAccountCountsRequestProtoMsg;
};
export declare const QueryPaymentAccountCountsResponse: {
    typeUrl: string;
    encode(message: QueryPaymentAccountCountsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountCountsResponse;
    fromJSON(object: any): QueryPaymentAccountCountsResponse;
    toJSON(message: QueryPaymentAccountCountsResponse): unknown;
    fromPartial<I extends {
        paymentAccountCounts?: {
            owner?: string;
            count?: string | number | Long.Long;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        paymentAccountCounts?: {
            owner?: string;
            count?: string | number | Long.Long;
        }[] & ({
            owner?: string;
            count?: string | number | Long.Long;
        } & {
            owner?: string;
            count?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["paymentAccountCounts"][number]["count"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["paymentAccountCounts"][number], keyof PaymentAccountCount>, never>)[] & Record<Exclude<keyof I["paymentAccountCounts"], keyof {
            owner?: string;
            count?: string | number | Long.Long;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryPaymentAccountCountsResponse>, never>>(object: I): QueryPaymentAccountCountsResponse;
    fromSDK(object: QueryPaymentAccountCountsResponseSDKType): QueryPaymentAccountCountsResponse;
    toSDK(message: QueryPaymentAccountCountsResponse): QueryPaymentAccountCountsResponseSDKType;
    fromAmino(object: QueryPaymentAccountCountsResponseAmino): QueryPaymentAccountCountsResponse;
    toAmino(message: QueryPaymentAccountCountsResponse): QueryPaymentAccountCountsResponseAmino;
    fromAminoMsg(object: QueryPaymentAccountCountsResponseAminoMsg): QueryPaymentAccountCountsResponse;
    fromProtoMsg(message: QueryPaymentAccountCountsResponseProtoMsg): QueryPaymentAccountCountsResponse;
    toProto(message: QueryPaymentAccountCountsResponse): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountCountsResponse): QueryPaymentAccountCountsResponseProtoMsg;
};
export declare const QueryPaymentAccountRequest: {
    typeUrl: string;
    encode(message: QueryPaymentAccountRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountRequest;
    fromJSON(object: any): QueryPaymentAccountRequest;
    toJSON(message: QueryPaymentAccountRequest): unknown;
    fromPartial<I extends {
        addr?: string;
    } & {
        addr?: string;
    } & Record<Exclude<keyof I, "addr">, never>>(object: I): QueryPaymentAccountRequest;
    fromSDK(object: QueryPaymentAccountRequestSDKType): QueryPaymentAccountRequest;
    toSDK(message: QueryPaymentAccountRequest): QueryPaymentAccountRequestSDKType;
    fromAmino(object: QueryPaymentAccountRequestAmino): QueryPaymentAccountRequest;
    toAmino(message: QueryPaymentAccountRequest): QueryPaymentAccountRequestAmino;
    fromAminoMsg(object: QueryPaymentAccountRequestAminoMsg): QueryPaymentAccountRequest;
    fromProtoMsg(message: QueryPaymentAccountRequestProtoMsg): QueryPaymentAccountRequest;
    toProto(message: QueryPaymentAccountRequest): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountRequest): QueryPaymentAccountRequestProtoMsg;
};
export declare const QueryPaymentAccountResponse: {
    typeUrl: string;
    encode(message: QueryPaymentAccountResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountResponse;
    fromJSON(object: any): QueryPaymentAccountResponse;
    toJSON(message: QueryPaymentAccountResponse): unknown;
    fromPartial<I extends {
        paymentAccount?: {
            addr?: string;
            owner?: string;
            refundable?: boolean;
        };
    } & {
        paymentAccount?: {
            addr?: string;
            owner?: string;
            refundable?: boolean;
        } & {
            addr?: string;
            owner?: string;
            refundable?: boolean;
        } & Record<Exclude<keyof I["paymentAccount"], keyof PaymentAccount>, never>;
    } & Record<Exclude<keyof I, "paymentAccount">, never>>(object: I): QueryPaymentAccountResponse;
    fromSDK(object: QueryPaymentAccountResponseSDKType): QueryPaymentAccountResponse;
    toSDK(message: QueryPaymentAccountResponse): QueryPaymentAccountResponseSDKType;
    fromAmino(object: QueryPaymentAccountResponseAmino): QueryPaymentAccountResponse;
    toAmino(message: QueryPaymentAccountResponse): QueryPaymentAccountResponseAmino;
    fromAminoMsg(object: QueryPaymentAccountResponseAminoMsg): QueryPaymentAccountResponse;
    fromProtoMsg(message: QueryPaymentAccountResponseProtoMsg): QueryPaymentAccountResponse;
    toProto(message: QueryPaymentAccountResponse): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountResponse): QueryPaymentAccountResponseProtoMsg;
};
export declare const QueryPaymentAccountsRequest: {
    typeUrl: string;
    encode(message: QueryPaymentAccountsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountsRequest;
    fromJSON(object: any): QueryPaymentAccountsRequest;
    toJSON(message: QueryPaymentAccountsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryPaymentAccountsRequest;
    fromSDK(object: QueryPaymentAccountsRequestSDKType): QueryPaymentAccountsRequest;
    toSDK(message: QueryPaymentAccountsRequest): QueryPaymentAccountsRequestSDKType;
    fromAmino(object: QueryPaymentAccountsRequestAmino): QueryPaymentAccountsRequest;
    toAmino(message: QueryPaymentAccountsRequest): QueryPaymentAccountsRequestAmino;
    fromAminoMsg(object: QueryPaymentAccountsRequestAminoMsg): QueryPaymentAccountsRequest;
    fromProtoMsg(message: QueryPaymentAccountsRequestProtoMsg): QueryPaymentAccountsRequest;
    toProto(message: QueryPaymentAccountsRequest): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountsRequest): QueryPaymentAccountsRequestProtoMsg;
};
export declare const QueryPaymentAccountsResponse: {
    typeUrl: string;
    encode(message: QueryPaymentAccountsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountsResponse;
    fromJSON(object: any): QueryPaymentAccountsResponse;
    toJSON(message: QueryPaymentAccountsResponse): unknown;
    fromPartial<I extends {
        paymentAccounts?: {
            addr?: string;
            owner?: string;
            refundable?: boolean;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        paymentAccounts?: {
            addr?: string;
            owner?: string;
            refundable?: boolean;
        }[] & ({
            addr?: string;
            owner?: string;
            refundable?: boolean;
        } & {
            addr?: string;
            owner?: string;
            refundable?: boolean;
        } & Record<Exclude<keyof I["paymentAccounts"][number], keyof PaymentAccount>, never>)[] & Record<Exclude<keyof I["paymentAccounts"], keyof {
            addr?: string;
            owner?: string;
            refundable?: boolean;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryPaymentAccountsResponse>, never>>(object: I): QueryPaymentAccountsResponse;
    fromSDK(object: QueryPaymentAccountsResponseSDKType): QueryPaymentAccountsResponse;
    toSDK(message: QueryPaymentAccountsResponse): QueryPaymentAccountsResponseSDKType;
    fromAmino(object: QueryPaymentAccountsResponseAmino): QueryPaymentAccountsResponse;
    toAmino(message: QueryPaymentAccountsResponse): QueryPaymentAccountsResponseAmino;
    fromAminoMsg(object: QueryPaymentAccountsResponseAminoMsg): QueryPaymentAccountsResponse;
    fromProtoMsg(message: QueryPaymentAccountsResponseProtoMsg): QueryPaymentAccountsResponse;
    toProto(message: QueryPaymentAccountsResponse): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountsResponse): QueryPaymentAccountsResponseProtoMsg;
};
export declare const QueryDynamicBalanceRequest: {
    typeUrl: string;
    encode(message: QueryDynamicBalanceRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryDynamicBalanceRequest;
    fromJSON(object: any): QueryDynamicBalanceRequest;
    toJSON(message: QueryDynamicBalanceRequest): unknown;
    fromPartial<I extends {
        account?: string;
    } & {
        account?: string;
    } & Record<Exclude<keyof I, "account">, never>>(object: I): QueryDynamicBalanceRequest;
    fromSDK(object: QueryDynamicBalanceRequestSDKType): QueryDynamicBalanceRequest;
    toSDK(message: QueryDynamicBalanceRequest): QueryDynamicBalanceRequestSDKType;
    fromAmino(object: QueryDynamicBalanceRequestAmino): QueryDynamicBalanceRequest;
    toAmino(message: QueryDynamicBalanceRequest): QueryDynamicBalanceRequestAmino;
    fromAminoMsg(object: QueryDynamicBalanceRequestAminoMsg): QueryDynamicBalanceRequest;
    fromProtoMsg(message: QueryDynamicBalanceRequestProtoMsg): QueryDynamicBalanceRequest;
    toProto(message: QueryDynamicBalanceRequest): Uint8Array;
    toProtoMsg(message: QueryDynamicBalanceRequest): QueryDynamicBalanceRequestProtoMsg;
};
export declare const QueryDynamicBalanceResponse: {
    typeUrl: string;
    encode(message: QueryDynamicBalanceResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryDynamicBalanceResponse;
    fromJSON(object: any): QueryDynamicBalanceResponse;
    toJSON(message: QueryDynamicBalanceResponse): unknown;
    fromPartial<I extends {
        dynamicBalance?: string;
        streamRecord?: {
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        };
        currentTimestamp?: string | number | Long.Long;
        bankBalance?: string;
        availableBalance?: string;
        lockedFee?: string;
        changeRate?: string;
    } & {
        dynamicBalance?: string;
        streamRecord?: {
            account?: string;
            crudTimestamp?: string | number | Long.Long;
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | Long.Long;
            outFlowCount?: string | number | Long.Long;
            frozenNetflowRate?: string;
        } & {
            account?: string;
            crudTimestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecord"]["crudTimestamp"], keyof Long.Long>, never>);
            netflowRate?: string;
            staticBalance?: string;
            bufferBalance?: string;
            lockBalance?: string;
            status?: import("./stream_record").StreamAccountStatus;
            settleTimestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecord"]["settleTimestamp"], keyof Long.Long>, never>);
            outFlowCount?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["streamRecord"]["outFlowCount"], keyof Long.Long>, never>);
            frozenNetflowRate?: string;
        } & Record<Exclude<keyof I["streamRecord"], keyof StreamRecord>, never>;
        currentTimestamp?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["currentTimestamp"], keyof Long.Long>, never>);
        bankBalance?: string;
        availableBalance?: string;
        lockedFee?: string;
        changeRate?: string;
    } & Record<Exclude<keyof I, keyof QueryDynamicBalanceResponse>, never>>(object: I): QueryDynamicBalanceResponse;
    fromSDK(object: QueryDynamicBalanceResponseSDKType): QueryDynamicBalanceResponse;
    toSDK(message: QueryDynamicBalanceResponse): QueryDynamicBalanceResponseSDKType;
    fromAmino(object: QueryDynamicBalanceResponseAmino): QueryDynamicBalanceResponse;
    toAmino(message: QueryDynamicBalanceResponse): QueryDynamicBalanceResponseAmino;
    fromAminoMsg(object: QueryDynamicBalanceResponseAminoMsg): QueryDynamicBalanceResponse;
    fromProtoMsg(message: QueryDynamicBalanceResponseProtoMsg): QueryDynamicBalanceResponse;
    toProto(message: QueryDynamicBalanceResponse): Uint8Array;
    toProtoMsg(message: QueryDynamicBalanceResponse): QueryDynamicBalanceResponseProtoMsg;
};
export declare const QueryPaymentAccountsByOwnerRequest: {
    typeUrl: string;
    encode(message: QueryPaymentAccountsByOwnerRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountsByOwnerRequest;
    fromJSON(object: any): QueryPaymentAccountsByOwnerRequest;
    toJSON(message: QueryPaymentAccountsByOwnerRequest): unknown;
    fromPartial<I extends {
        owner?: string;
    } & {
        owner?: string;
    } & Record<Exclude<keyof I, "owner">, never>>(object: I): QueryPaymentAccountsByOwnerRequest;
    fromSDK(object: QueryPaymentAccountsByOwnerRequestSDKType): QueryPaymentAccountsByOwnerRequest;
    toSDK(message: QueryPaymentAccountsByOwnerRequest): QueryPaymentAccountsByOwnerRequestSDKType;
    fromAmino(object: QueryPaymentAccountsByOwnerRequestAmino): QueryPaymentAccountsByOwnerRequest;
    toAmino(message: QueryPaymentAccountsByOwnerRequest): QueryPaymentAccountsByOwnerRequestAmino;
    fromAminoMsg(object: QueryPaymentAccountsByOwnerRequestAminoMsg): QueryPaymentAccountsByOwnerRequest;
    fromProtoMsg(message: QueryPaymentAccountsByOwnerRequestProtoMsg): QueryPaymentAccountsByOwnerRequest;
    toProto(message: QueryPaymentAccountsByOwnerRequest): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountsByOwnerRequest): QueryPaymentAccountsByOwnerRequestProtoMsg;
};
export declare const QueryPaymentAccountsByOwnerResponse: {
    typeUrl: string;
    encode(message: QueryPaymentAccountsByOwnerResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPaymentAccountsByOwnerResponse;
    fromJSON(object: any): QueryPaymentAccountsByOwnerResponse;
    toJSON(message: QueryPaymentAccountsByOwnerResponse): unknown;
    fromPartial<I extends {
        paymentAccounts?: string[];
    } & {
        paymentAccounts?: string[] & string[] & Record<Exclude<keyof I["paymentAccounts"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, "paymentAccounts">, never>>(object: I): QueryPaymentAccountsByOwnerResponse;
    fromSDK(object: QueryPaymentAccountsByOwnerResponseSDKType): QueryPaymentAccountsByOwnerResponse;
    toSDK(message: QueryPaymentAccountsByOwnerResponse): QueryPaymentAccountsByOwnerResponseSDKType;
    fromAmino(object: QueryPaymentAccountsByOwnerResponseAmino): QueryPaymentAccountsByOwnerResponse;
    toAmino(message: QueryPaymentAccountsByOwnerResponse): QueryPaymentAccountsByOwnerResponseAmino;
    fromAminoMsg(object: QueryPaymentAccountsByOwnerResponseAminoMsg): QueryPaymentAccountsByOwnerResponse;
    fromProtoMsg(message: QueryPaymentAccountsByOwnerResponseProtoMsg): QueryPaymentAccountsByOwnerResponse;
    toProto(message: QueryPaymentAccountsByOwnerResponse): Uint8Array;
    toProtoMsg(message: QueryPaymentAccountsByOwnerResponse): QueryPaymentAccountsByOwnerResponseProtoMsg;
};
export declare const QueryAutoSettleRecordsRequest: {
    typeUrl: string;
    encode(message: QueryAutoSettleRecordsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryAutoSettleRecordsRequest;
    fromJSON(object: any): QueryAutoSettleRecordsRequest;
    toJSON(message: QueryAutoSettleRecordsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryAutoSettleRecordsRequest;
    fromSDK(object: QueryAutoSettleRecordsRequestSDKType): QueryAutoSettleRecordsRequest;
    toSDK(message: QueryAutoSettleRecordsRequest): QueryAutoSettleRecordsRequestSDKType;
    fromAmino(object: QueryAutoSettleRecordsRequestAmino): QueryAutoSettleRecordsRequest;
    toAmino(message: QueryAutoSettleRecordsRequest): QueryAutoSettleRecordsRequestAmino;
    fromAminoMsg(object: QueryAutoSettleRecordsRequestAminoMsg): QueryAutoSettleRecordsRequest;
    fromProtoMsg(message: QueryAutoSettleRecordsRequestProtoMsg): QueryAutoSettleRecordsRequest;
    toProto(message: QueryAutoSettleRecordsRequest): Uint8Array;
    toProtoMsg(message: QueryAutoSettleRecordsRequest): QueryAutoSettleRecordsRequestProtoMsg;
};
export declare const QueryAutoSettleRecordsResponse: {
    typeUrl: string;
    encode(message: QueryAutoSettleRecordsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryAutoSettleRecordsResponse;
    fromJSON(object: any): QueryAutoSettleRecordsResponse;
    toJSON(message: QueryAutoSettleRecordsResponse): unknown;
    fromPartial<I extends {
        autoSettleRecords?: {
            timestamp?: string | number | Long.Long;
            addr?: string;
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        autoSettleRecords?: {
            timestamp?: string | number | Long.Long;
            addr?: string;
        }[] & ({
            timestamp?: string | number | Long.Long;
            addr?: string;
        } & {
            timestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["autoSettleRecords"][number]["timestamp"], keyof Long.Long>, never>);
            addr?: string;
        } & Record<Exclude<keyof I["autoSettleRecords"][number], keyof AutoSettleRecord>, never>)[] & Record<Exclude<keyof I["autoSettleRecords"], keyof {
            timestamp?: string | number | Long.Long;
            addr?: string;
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryAutoSettleRecordsResponse>, never>>(object: I): QueryAutoSettleRecordsResponse;
    fromSDK(object: QueryAutoSettleRecordsResponseSDKType): QueryAutoSettleRecordsResponse;
    toSDK(message: QueryAutoSettleRecordsResponse): QueryAutoSettleRecordsResponseSDKType;
    fromAmino(object: QueryAutoSettleRecordsResponseAmino): QueryAutoSettleRecordsResponse;
    toAmino(message: QueryAutoSettleRecordsResponse): QueryAutoSettleRecordsResponseAmino;
    fromAminoMsg(object: QueryAutoSettleRecordsResponseAminoMsg): QueryAutoSettleRecordsResponse;
    fromProtoMsg(message: QueryAutoSettleRecordsResponseProtoMsg): QueryAutoSettleRecordsResponse;
    toProto(message: QueryAutoSettleRecordsResponse): Uint8Array;
    toProtoMsg(message: QueryAutoSettleRecordsResponse): QueryAutoSettleRecordsResponseProtoMsg;
};
export declare const QueryDelayedWithdrawalRequest: {
    typeUrl: string;
    encode(message: QueryDelayedWithdrawalRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelayedWithdrawalRequest;
    fromJSON(object: any): QueryDelayedWithdrawalRequest;
    toJSON(message: QueryDelayedWithdrawalRequest): unknown;
    fromPartial<I extends {
        account?: string;
    } & {
        account?: string;
    } & Record<Exclude<keyof I, "account">, never>>(object: I): QueryDelayedWithdrawalRequest;
    fromSDK(object: QueryDelayedWithdrawalRequestSDKType): QueryDelayedWithdrawalRequest;
    toSDK(message: QueryDelayedWithdrawalRequest): QueryDelayedWithdrawalRequestSDKType;
    fromAmino(object: QueryDelayedWithdrawalRequestAmino): QueryDelayedWithdrawalRequest;
    toAmino(message: QueryDelayedWithdrawalRequest): QueryDelayedWithdrawalRequestAmino;
    fromAminoMsg(object: QueryDelayedWithdrawalRequestAminoMsg): QueryDelayedWithdrawalRequest;
    fromProtoMsg(message: QueryDelayedWithdrawalRequestProtoMsg): QueryDelayedWithdrawalRequest;
    toProto(message: QueryDelayedWithdrawalRequest): Uint8Array;
    toProtoMsg(message: QueryDelayedWithdrawalRequest): QueryDelayedWithdrawalRequestProtoMsg;
};
export declare const QueryDelayedWithdrawalResponse: {
    typeUrl: string;
    encode(message: QueryDelayedWithdrawalResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryDelayedWithdrawalResponse;
    fromJSON(object: any): QueryDelayedWithdrawalResponse;
    toJSON(message: QueryDelayedWithdrawalResponse): unknown;
    fromPartial<I extends {
        delayedWithdrawal?: {
            addr?: string;
            amount?: string;
            from?: string;
            unlockTimestamp?: string | number | Long.Long;
        };
    } & {
        delayedWithdrawal?: {
            addr?: string;
            amount?: string;
            from?: string;
            unlockTimestamp?: string | number | Long.Long;
        } & {
            addr?: string;
            amount?: string;
            from?: string;
            unlockTimestamp?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["delayedWithdrawal"]["unlockTimestamp"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["delayedWithdrawal"], keyof DelayedWithdrawalRecord>, never>;
    } & Record<Exclude<keyof I, "delayedWithdrawal">, never>>(object: I): QueryDelayedWithdrawalResponse;
    fromSDK(object: QueryDelayedWithdrawalResponseSDKType): QueryDelayedWithdrawalResponse;
    toSDK(message: QueryDelayedWithdrawalResponse): QueryDelayedWithdrawalResponseSDKType;
    fromAmino(object: QueryDelayedWithdrawalResponseAmino): QueryDelayedWithdrawalResponse;
    toAmino(message: QueryDelayedWithdrawalResponse): QueryDelayedWithdrawalResponseAmino;
    fromAminoMsg(object: QueryDelayedWithdrawalResponseAminoMsg): QueryDelayedWithdrawalResponse;
    fromProtoMsg(message: QueryDelayedWithdrawalResponseProtoMsg): QueryDelayedWithdrawalResponse;
    toProto(message: QueryDelayedWithdrawalResponse): Uint8Array;
    toProtoMsg(message: QueryDelayedWithdrawalResponse): QueryDelayedWithdrawalResponseProtoMsg;
};
/** Query defines the gRPC querier service. */
export interface Query {
    /** Parameters queries the parameters of the module. */
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** ParamsByTimestamp queries the parameter of the module by timestamp. */
    ParamsByTimestamp(request: QueryParamsByTimestampRequest): Promise<QueryParamsByTimestampResponse>;
    /** Queries our flows by account. */
    OutFlows(request: QueryOutFlowsRequest): Promise<QueryOutFlowsResponse>;
    /** Queries a stream record by account. */
    StreamRecord(request: QueryGetStreamRecordRequest): Promise<QueryGetStreamRecordResponse>;
    /** Queries all stream records. */
    StreamRecords(request?: QueryStreamRecordsRequest): Promise<QueryStreamRecordsResponse>;
    /** Queries the count of payment account by owner. */
    PaymentAccountCount(request: QueryPaymentAccountCountRequest): Promise<QueryPaymentAccountCountResponse>;
    /** Queries all counts of payment account for all owners. */
    PaymentAccountCounts(request?: QueryPaymentAccountCountsRequest): Promise<QueryPaymentAccountCountsResponse>;
    /** Queries a payment account by payment account address. */
    PaymentAccount(request: QueryPaymentAccountRequest): Promise<QueryPaymentAccountResponse>;
    /** Queries all payment accounts. */
    PaymentAccounts(request?: QueryPaymentAccountsRequest): Promise<QueryPaymentAccountsResponse>;
    /** Queries dynamic balance of a payment account. */
    DynamicBalance(request: QueryDynamicBalanceRequest): Promise<QueryDynamicBalanceResponse>;
    /** Queries all payment accounts by a owner. */
    PaymentAccountsByOwner(request: QueryPaymentAccountsByOwnerRequest): Promise<QueryPaymentAccountsByOwnerResponse>;
    /** Queries all auto settle records. */
    AutoSettleRecords(request?: QueryAutoSettleRecordsRequest): Promise<QueryAutoSettleRecordsResponse>;
    /** Queries delayed withdrawal of a account. */
    DelayedWithdrawal(request: QueryDelayedWithdrawalRequest): Promise<QueryDelayedWithdrawalResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    ParamsByTimestamp(request: QueryParamsByTimestampRequest): Promise<QueryParamsByTimestampResponse>;
    OutFlows(request: QueryOutFlowsRequest): Promise<QueryOutFlowsResponse>;
    StreamRecord(request: QueryGetStreamRecordRequest): Promise<QueryGetStreamRecordResponse>;
    StreamRecords(request?: QueryStreamRecordsRequest): Promise<QueryStreamRecordsResponse>;
    PaymentAccountCount(request: QueryPaymentAccountCountRequest): Promise<QueryPaymentAccountCountResponse>;
    PaymentAccountCounts(request?: QueryPaymentAccountCountsRequest): Promise<QueryPaymentAccountCountsResponse>;
    PaymentAccount(request: QueryPaymentAccountRequest): Promise<QueryPaymentAccountResponse>;
    PaymentAccounts(request?: QueryPaymentAccountsRequest): Promise<QueryPaymentAccountsResponse>;
    DynamicBalance(request: QueryDynamicBalanceRequest): Promise<QueryDynamicBalanceResponse>;
    PaymentAccountsByOwner(request: QueryPaymentAccountsByOwnerRequest): Promise<QueryPaymentAccountsByOwnerResponse>;
    AutoSettleRecords(request?: QueryAutoSettleRecordsRequest): Promise<QueryAutoSettleRecordsResponse>;
    DelayedWithdrawal(request: QueryDelayedWithdrawalRequest): Promise<QueryDelayedWithdrawalResponse>;
}
