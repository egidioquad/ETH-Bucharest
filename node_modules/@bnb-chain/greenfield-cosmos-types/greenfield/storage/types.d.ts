/// <reference types="long" />
import { VisibilityType, SourceType, BucketStatus, LocalVirtualGroup, LocalVirtualGroupAmino, LocalVirtualGroupSDKType, ObjectStatus, RedundancyType } from "./common";
import { Long } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
export interface BucketInfo {
    /** owner is the account address of bucket creator, it is also the bucket owner. */
    owner: string;
    /** bucket_name is a globally unique name of bucket */
    bucketName: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get storage objects in it. */
    visibility: VisibilityType;
    /** id is the unique identification for bucket. */
    id: string;
    /** source_type defines which chain the user should send the bucket management transactions to */
    sourceType: SourceType;
    /** create_at define the block timestamp when the bucket created. */
    createAt: Long;
    /** payment_address is the address of the payment account */
    paymentAddress: string;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    globalVirtualGroupFamilyId: number;
    /**
     * charged_read_quota defines the traffic quota for read in bytes per month.
     * The available read data for each user is the sum of the free read data provided by SP and
     * the ChargeReadQuota specified here.
     */
    chargedReadQuota: Long;
    /** bucket_status define the status of the bucket. */
    bucketStatus: BucketStatus;
    /** tags defines a list of tags the bucket has */
    tags?: ResourceTags;
}
export interface BucketInfoProtoMsg {
    typeUrl: "/greenfield.storage.BucketInfo";
    value: Uint8Array;
}
export interface BucketInfoAmino {
    /** owner is the account address of bucket creator, it is also the bucket owner. */
    owner?: string;
    /** bucket_name is a globally unique name of bucket */
    bucket_name?: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get storage objects in it. */
    visibility?: VisibilityType;
    /** id is the unique identification for bucket. */
    id?: string;
    /** source_type defines which chain the user should send the bucket management transactions to */
    source_type?: SourceType;
    /** create_at define the block timestamp when the bucket created. */
    create_at?: string;
    /** payment_address is the address of the payment account */
    payment_address?: string;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    global_virtual_group_family_id?: number;
    /**
     * charged_read_quota defines the traffic quota for read in bytes per month.
     * The available read data for each user is the sum of the free read data provided by SP and
     * the ChargeReadQuota specified here.
     */
    charged_read_quota?: string;
    /** bucket_status define the status of the bucket. */
    bucket_status?: BucketStatus;
    /** tags defines a list of tags the bucket has */
    tags?: ResourceTagsAmino;
}
export interface BucketInfoAminoMsg {
    type: "/greenfield.storage.BucketInfo";
    value: BucketInfoAmino;
}
export interface BucketInfoSDKType {
    owner: string;
    bucket_name: string;
    visibility: VisibilityType;
    id: string;
    source_type: SourceType;
    create_at: Long;
    payment_address: string;
    global_virtual_group_family_id: number;
    charged_read_quota: Long;
    bucket_status: BucketStatus;
    tags?: ResourceTagsSDKType;
}
export interface InternalBucketInfo {
    /** the time of the payment price, used to calculate the charge rate of the bucket */
    priceTime: Long;
    /** the total size of the objects in the bucket, used to calculate the charge rate of the bucket */
    totalChargeSize: Long;
    /** local_virtual_groups contains all the lvg of this bucket. */
    localVirtualGroups: LocalVirtualGroup[];
    /** next_local_virtual_group_id store the next id used by local virtual group */
    nextLocalVirtualGroupId: number;
}
export interface InternalBucketInfoProtoMsg {
    typeUrl: "/greenfield.storage.InternalBucketInfo";
    value: Uint8Array;
}
export interface InternalBucketInfoAmino {
    /** the time of the payment price, used to calculate the charge rate of the bucket */
    price_time?: string;
    /** the total size of the objects in the bucket, used to calculate the charge rate of the bucket */
    total_charge_size?: string;
    /** local_virtual_groups contains all the lvg of this bucket. */
    local_virtual_groups?: LocalVirtualGroupAmino[];
    /** next_local_virtual_group_id store the next id used by local virtual group */
    next_local_virtual_group_id?: number;
}
export interface InternalBucketInfoAminoMsg {
    type: "/greenfield.storage.InternalBucketInfo";
    value: InternalBucketInfoAmino;
}
export interface InternalBucketInfoSDKType {
    price_time: Long;
    total_charge_size: Long;
    local_virtual_groups: LocalVirtualGroupSDKType[];
    next_local_virtual_group_id: number;
}
export interface ObjectInfo {
    /** owner is the object owner */
    owner: string;
    /** creator is the address of the uploader, it always be same as owner address */
    creator: string;
    /** bucket_name is the name of the bucket */
    bucketName: string;
    /** object_name is the name of object */
    objectName: string;
    /** id is the unique identifier of object */
    id: string;
    localVirtualGroupId: number;
    /** payloadSize is the total size of the object payload */
    payloadSize: Long;
    /** visibility defines the highest permissions for object. When an object is public, everyone can access it. */
    visibility: VisibilityType;
    /** content_type define the format of the object which should be a standard MIME type. */
    contentType: string;
    /** create_at define the block timestamp when the object is created */
    createAt: Long;
    /** object_status define the upload status of the object. */
    objectStatus: ObjectStatus;
    /** redundancy_type define the type of the redundancy which can be multi-replication or EC. */
    redundancyType: RedundancyType;
    /** source_type define the source of the object. */
    sourceType: SourceType;
    /**
     * checksums define the root hash of the pieces which stored in a SP.
     * add omit tag to omit the field when converting to NFT metadata
     */
    checksums: Uint8Array[];
    /** tags defines a list of tags the object has */
    tags?: ResourceTags;
}
export interface ObjectInfoProtoMsg {
    typeUrl: "/greenfield.storage.ObjectInfo";
    value: Uint8Array;
}
export interface ObjectInfoAmino {
    /** owner is the object owner */
    owner?: string;
    /** creator is the address of the uploader, it always be same as owner address */
    creator?: string;
    /** bucket_name is the name of the bucket */
    bucket_name?: string;
    /** object_name is the name of object */
    object_name?: string;
    /** id is the unique identifier of object */
    id?: string;
    local_virtual_group_id?: number;
    /** payloadSize is the total size of the object payload */
    payload_size?: string;
    /** visibility defines the highest permissions for object. When an object is public, everyone can access it. */
    visibility?: VisibilityType;
    /** content_type define the format of the object which should be a standard MIME type. */
    content_type?: string;
    /** create_at define the block timestamp when the object is created */
    create_at?: string;
    /** object_status define the upload status of the object. */
    object_status?: ObjectStatus;
    /** redundancy_type define the type of the redundancy which can be multi-replication or EC. */
    redundancy_type?: RedundancyType;
    /** source_type define the source of the object. */
    source_type?: SourceType;
    /**
     * checksums define the root hash of the pieces which stored in a SP.
     * add omit tag to omit the field when converting to NFT metadata
     */
    checksums?: string[];
    /** tags defines a list of tags the object has */
    tags?: ResourceTagsAmino;
}
export interface ObjectInfoAminoMsg {
    type: "/greenfield.storage.ObjectInfo";
    value: ObjectInfoAmino;
}
export interface ObjectInfoSDKType {
    owner: string;
    creator: string;
    bucket_name: string;
    object_name: string;
    id: string;
    local_virtual_group_id: number;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    create_at: Long;
    object_status: ObjectStatus;
    redundancy_type: RedundancyType;
    source_type: SourceType;
    checksums: Uint8Array[];
    tags?: ResourceTagsSDKType;
}
export interface GroupInfo {
    /** owner is the owner of the group. It can not changed once it created. */
    owner: string;
    /** group_name is the name of group which is unique under an account. */
    groupName: string;
    /** source_type */
    sourceType: SourceType;
    /** id is the unique identifier of group */
    id: string;
    /** extra is used to store extra info for the group */
    extra: string;
    /** tags defines a list of tags the group has */
    tags?: ResourceTags;
}
export interface GroupInfoProtoMsg {
    typeUrl: "/greenfield.storage.GroupInfo";
    value: Uint8Array;
}
export interface GroupInfoAmino {
    /** owner is the owner of the group. It can not changed once it created. */
    owner?: string;
    /** group_name is the name of group which is unique under an account. */
    group_name?: string;
    /** source_type */
    source_type?: SourceType;
    /** id is the unique identifier of group */
    id?: string;
    /** extra is used to store extra info for the group */
    extra?: string;
    /** tags defines a list of tags the group has */
    tags?: ResourceTagsAmino;
}
export interface GroupInfoAminoMsg {
    type: "/greenfield.storage.GroupInfo";
    value: GroupInfoAmino;
}
export interface GroupInfoSDKType {
    owner: string;
    group_name: string;
    source_type: SourceType;
    id: string;
    extra: string;
    tags?: ResourceTagsSDKType;
}
export interface Trait {
    traitType: string;
    value: string;
}
export interface TraitProtoMsg {
    typeUrl: "/greenfield.storage.Trait";
    value: Uint8Array;
}
export interface TraitAmino {
    trait_type?: string;
    value?: string;
}
export interface TraitAminoMsg {
    type: "/greenfield.storage.Trait";
    value: TraitAmino;
}
export interface TraitSDKType {
    trait_type: string;
    value: string;
}
export interface BucketMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of bucket NFT */
    bucketName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface BucketMetaDataProtoMsg {
    typeUrl: "/greenfield.storage.BucketMetaData";
    value: Uint8Array;
}
export interface BucketMetaDataAmino {
    /** description */
    description?: string;
    /** externalUrl a link to external site to view NFT */
    external_url?: string;
    /** name of bucket NFT */
    bucket_name?: string;
    /** image is the link to image */
    image?: string;
    /** attributes */
    attributes?: TraitAmino[];
}
export interface BucketMetaDataAminoMsg {
    type: "/greenfield.storage.BucketMetaData";
    value: BucketMetaDataAmino;
}
export interface BucketMetaDataSDKType {
    description: string;
    external_url: string;
    bucket_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface ObjectMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of object NFT */
    objectName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface ObjectMetaDataProtoMsg {
    typeUrl: "/greenfield.storage.ObjectMetaData";
    value: Uint8Array;
}
export interface ObjectMetaDataAmino {
    /** description */
    description?: string;
    /** externalUrl a link to external site to view NFT */
    external_url?: string;
    /** name of object NFT */
    object_name?: string;
    /** image is the link to image */
    image?: string;
    /** attributes */
    attributes?: TraitAmino[];
}
export interface ObjectMetaDataAminoMsg {
    type: "/greenfield.storage.ObjectMetaData";
    value: ObjectMetaDataAmino;
}
export interface ObjectMetaDataSDKType {
    description: string;
    external_url: string;
    object_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface GroupMetaData {
    /** description */
    description: string;
    /** externalUrl a link to external site to view NFT */
    externalUrl: string;
    /** name of group NFT */
    groupName: string;
    /** image is the link to image */
    image: string;
    /** attributes */
    attributes: Trait[];
}
export interface GroupMetaDataProtoMsg {
    typeUrl: "/greenfield.storage.GroupMetaData";
    value: Uint8Array;
}
export interface GroupMetaDataAmino {
    /** description */
    description?: string;
    /** externalUrl a link to external site to view NFT */
    external_url?: string;
    /** name of group NFT */
    group_name?: string;
    /** image is the link to image */
    image?: string;
    /** attributes */
    attributes?: TraitAmino[];
}
export interface GroupMetaDataAminoMsg {
    type: "/greenfield.storage.GroupMetaData";
    value: GroupMetaDataAmino;
}
export interface GroupMetaDataSDKType {
    description: string;
    external_url: string;
    group_name: string;
    image: string;
    attributes: TraitSDKType[];
}
export interface Ids {
    /** ids of the objects or buckets */
    id: string[];
}
export interface IdsProtoMsg {
    typeUrl: "/greenfield.storage.Ids";
    value: Uint8Array;
}
export interface IdsAmino {
    /** ids of the objects or buckets */
    id?: string[];
}
export interface IdsAminoMsg {
    type: "/greenfield.storage.Ids";
    value: IdsAmino;
}
export interface IdsSDKType {
    id: string[];
}
export interface DeleteInfo {
    bucketIds?: Ids;
    objectIds?: Ids;
    groupIds?: Ids;
}
export interface DeleteInfoProtoMsg {
    typeUrl: "/greenfield.storage.DeleteInfo";
    value: Uint8Array;
}
export interface DeleteInfoAmino {
    bucket_ids?: IdsAmino;
    object_ids?: IdsAmino;
    group_ids?: IdsAmino;
}
export interface DeleteInfoAminoMsg {
    type: "/greenfield.storage.DeleteInfo";
    value: DeleteInfoAmino;
}
export interface DeleteInfoSDKType {
    bucket_ids?: IdsSDKType;
    object_ids?: IdsSDKType;
    group_ids?: IdsSDKType;
}
export interface MigrationBucketInfo {
    srcSpId: number;
    srcGlobalVirtualGroupFamilyId: number;
    dstSpId: number;
    /** id is the unique identifier of bucket */
    bucketId: string;
}
export interface MigrationBucketInfoProtoMsg {
    typeUrl: "/greenfield.storage.MigrationBucketInfo";
    value: Uint8Array;
}
export interface MigrationBucketInfoAmino {
    src_sp_id?: number;
    src_global_virtual_group_family_id?: number;
    dst_sp_id?: number;
    /** id is the unique identifier of bucket */
    bucket_id?: string;
}
export interface MigrationBucketInfoAminoMsg {
    type: "/greenfield.storage.MigrationBucketInfo";
    value: MigrationBucketInfoAmino;
}
export interface MigrationBucketInfoSDKType {
    src_sp_id: number;
    src_global_virtual_group_family_id: number;
    dst_sp_id: number;
    bucket_id: string;
}
export interface ResourceTags {
    /** tags defines a list of tags the resource has */
    tags: ResourceTags_Tag[];
}
export interface ResourceTagsProtoMsg {
    typeUrl: "/greenfield.storage.ResourceTags";
    value: Uint8Array;
}
export interface ResourceTagsAmino {
    /** tags defines a list of tags the resource has */
    tags?: ResourceTags_TagAmino[];
}
export interface ResourceTagsAminoMsg {
    type: "/greenfield.storage.ResourceTags";
    value: ResourceTagsAmino;
}
export interface ResourceTagsSDKType {
    tags: ResourceTags_TagSDKType[];
}
export interface ResourceTags_Tag {
    key: string;
    value: string;
}
export interface ResourceTags_TagProtoMsg {
    typeUrl: "/greenfield.storage.Tag";
    value: Uint8Array;
}
export interface ResourceTags_TagAmino {
    key?: string;
    value?: string;
}
export interface ResourceTags_TagAminoMsg {
    type: "/greenfield.storage.Tag";
    value: ResourceTags_TagAmino;
}
export interface ResourceTags_TagSDKType {
    key: string;
    value: string;
}
export declare const BucketInfo: {
    typeUrl: string;
    encode(message: BucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BucketInfo;
    fromJSON(object: any): BucketInfo;
    toJSON(message: BucketInfo): unknown;
    fromPartial<I extends {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        id?: string;
        sourceType?: SourceType;
        createAt?: string | number | Long.Long;
        paymentAddress?: string;
        globalVirtualGroupFamilyId?: number;
        chargedReadQuota?: string | number | Long.Long;
        bucketStatus?: BucketStatus;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        };
    } & {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        id?: string;
        sourceType?: SourceType;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        paymentAddress?: string;
        globalVirtualGroupFamilyId?: number;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>);
        bucketStatus?: BucketStatus;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        } & {
            tags?: {
                key?: string;
                value?: string;
            }[] & ({
                key?: string;
                value?: string;
            } & {
                key?: string;
                value?: string;
            } & Record<Exclude<keyof I["tags"]["tags"][number], keyof ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["tags"]["tags"], keyof {
                key?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["tags"], "tags">, never>;
    } & Record<Exclude<keyof I, keyof BucketInfo>, never>>(object: I): BucketInfo;
    fromSDK(object: BucketInfoSDKType): BucketInfo;
    toSDK(message: BucketInfo): BucketInfoSDKType;
    fromAmino(object: BucketInfoAmino): BucketInfo;
    toAmino(message: BucketInfo): BucketInfoAmino;
    fromAminoMsg(object: BucketInfoAminoMsg): BucketInfo;
    fromProtoMsg(message: BucketInfoProtoMsg): BucketInfo;
    toProto(message: BucketInfo): Uint8Array;
    toProtoMsg(message: BucketInfo): BucketInfoProtoMsg;
};
export declare const InternalBucketInfo: {
    typeUrl: string;
    encode(message: InternalBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): InternalBucketInfo;
    fromJSON(object: any): InternalBucketInfo;
    toJSON(message: InternalBucketInfo): unknown;
    fromPartial<I extends {
        priceTime?: string | number | Long.Long;
        totalChargeSize?: string | number | Long.Long;
        localVirtualGroups?: {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        }[];
        nextLocalVirtualGroupId?: number;
    } & {
        priceTime?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["priceTime"], keyof Long.Long>, never>);
        totalChargeSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["totalChargeSize"], keyof Long.Long>, never>);
        localVirtualGroups?: {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        }[] & ({
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        } & {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["localVirtualGroups"][number]["storedSize"], keyof Long.Long>, never>);
            totalChargeSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["localVirtualGroups"][number]["totalChargeSize"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["localVirtualGroups"][number], keyof LocalVirtualGroup>, never>)[] & Record<Exclude<keyof I["localVirtualGroups"], keyof {
            id?: number;
            globalVirtualGroupId?: number;
            storedSize?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
        }[]>, never>;
        nextLocalVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof InternalBucketInfo>, never>>(object: I): InternalBucketInfo;
    fromSDK(object: InternalBucketInfoSDKType): InternalBucketInfo;
    toSDK(message: InternalBucketInfo): InternalBucketInfoSDKType;
    fromAmino(object: InternalBucketInfoAmino): InternalBucketInfo;
    toAmino(message: InternalBucketInfo): InternalBucketInfoAmino;
    fromAminoMsg(object: InternalBucketInfoAminoMsg): InternalBucketInfo;
    fromProtoMsg(message: InternalBucketInfoProtoMsg): InternalBucketInfo;
    toProto(message: InternalBucketInfo): Uint8Array;
    toProtoMsg(message: InternalBucketInfo): InternalBucketInfoProtoMsg;
};
export declare const ObjectInfo: {
    typeUrl: string;
    encode(message: ObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ObjectInfo;
    fromJSON(object: any): ObjectInfo;
    toJSON(message: ObjectInfo): unknown;
    fromPartial<I extends {
        owner?: string;
        creator?: string;
        bucketName?: string;
        objectName?: string;
        id?: string;
        localVirtualGroupId?: number;
        payloadSize?: string | number | Long.Long;
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | Long.Long;
        objectStatus?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[];
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        };
    } & {
        owner?: string;
        creator?: string;
        bucketName?: string;
        objectName?: string;
        id?: string;
        localVirtualGroupId?: number;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>);
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        objectStatus?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["checksums"], keyof Uint8Array[]>, never>;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        } & {
            tags?: {
                key?: string;
                value?: string;
            }[] & ({
                key?: string;
                value?: string;
            } & {
                key?: string;
                value?: string;
            } & Record<Exclude<keyof I["tags"]["tags"][number], keyof ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["tags"]["tags"], keyof {
                key?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["tags"], "tags">, never>;
    } & Record<Exclude<keyof I, keyof ObjectInfo>, never>>(object: I): ObjectInfo;
    fromSDK(object: ObjectInfoSDKType): ObjectInfo;
    toSDK(message: ObjectInfo): ObjectInfoSDKType;
    fromAmino(object: ObjectInfoAmino): ObjectInfo;
    toAmino(message: ObjectInfo): ObjectInfoAmino;
    fromAminoMsg(object: ObjectInfoAminoMsg): ObjectInfo;
    fromProtoMsg(message: ObjectInfoProtoMsg): ObjectInfo;
    toProto(message: ObjectInfo): Uint8Array;
    toProtoMsg(message: ObjectInfo): ObjectInfoProtoMsg;
};
export declare const GroupInfo: {
    typeUrl: string;
    encode(message: GroupInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GroupInfo;
    fromJSON(object: any): GroupInfo;
    toJSON(message: GroupInfo): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        sourceType?: SourceType;
        id?: string;
        extra?: string;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        };
    } & {
        owner?: string;
        groupName?: string;
        sourceType?: SourceType;
        id?: string;
        extra?: string;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        } & {
            tags?: {
                key?: string;
                value?: string;
            }[] & ({
                key?: string;
                value?: string;
            } & {
                key?: string;
                value?: string;
            } & Record<Exclude<keyof I["tags"]["tags"][number], keyof ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["tags"]["tags"], keyof {
                key?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["tags"], "tags">, never>;
    } & Record<Exclude<keyof I, keyof GroupInfo>, never>>(object: I): GroupInfo;
    fromSDK(object: GroupInfoSDKType): GroupInfo;
    toSDK(message: GroupInfo): GroupInfoSDKType;
    fromAmino(object: GroupInfoAmino): GroupInfo;
    toAmino(message: GroupInfo): GroupInfoAmino;
    fromAminoMsg(object: GroupInfoAminoMsg): GroupInfo;
    fromProtoMsg(message: GroupInfoProtoMsg): GroupInfo;
    toProto(message: GroupInfo): Uint8Array;
    toProtoMsg(message: GroupInfo): GroupInfoProtoMsg;
};
export declare const Trait: {
    typeUrl: string;
    encode(message: Trait, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Trait;
    fromJSON(object: any): Trait;
    toJSON(message: Trait): unknown;
    fromPartial<I extends {
        traitType?: string;
        value?: string;
    } & {
        traitType?: string;
        value?: string;
    } & Record<Exclude<keyof I, keyof Trait>, never>>(object: I): Trait;
    fromSDK(object: TraitSDKType): Trait;
    toSDK(message: Trait): TraitSDKType;
    fromAmino(object: TraitAmino): Trait;
    toAmino(message: Trait): TraitAmino;
    fromAminoMsg(object: TraitAminoMsg): Trait;
    fromProtoMsg(message: TraitProtoMsg): Trait;
    toProto(message: Trait): Uint8Array;
    toProtoMsg(message: Trait): TraitProtoMsg;
};
export declare const BucketMetaData: {
    typeUrl: string;
    encode(message: BucketMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BucketMetaData;
    fromJSON(object: any): BucketMetaData;
    toJSON(message: BucketMetaData): unknown;
    fromPartial<I extends {
        description?: string;
        externalUrl?: string;
        bucketName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[];
    } & {
        description?: string;
        externalUrl?: string;
        bucketName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[] & ({
            traitType?: string;
            value?: string;
        } & {
            traitType?: string;
            value?: string;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string;
            value?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof BucketMetaData>, never>>(object: I): BucketMetaData;
    fromSDK(object: BucketMetaDataSDKType): BucketMetaData;
    toSDK(message: BucketMetaData): BucketMetaDataSDKType;
    fromAmino(object: BucketMetaDataAmino): BucketMetaData;
    toAmino(message: BucketMetaData): BucketMetaDataAmino;
    fromAminoMsg(object: BucketMetaDataAminoMsg): BucketMetaData;
    fromProtoMsg(message: BucketMetaDataProtoMsg): BucketMetaData;
    toProto(message: BucketMetaData): Uint8Array;
    toProtoMsg(message: BucketMetaData): BucketMetaDataProtoMsg;
};
export declare const ObjectMetaData: {
    typeUrl: string;
    encode(message: ObjectMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ObjectMetaData;
    fromJSON(object: any): ObjectMetaData;
    toJSON(message: ObjectMetaData): unknown;
    fromPartial<I extends {
        description?: string;
        externalUrl?: string;
        objectName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[];
    } & {
        description?: string;
        externalUrl?: string;
        objectName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[] & ({
            traitType?: string;
            value?: string;
        } & {
            traitType?: string;
            value?: string;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string;
            value?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof ObjectMetaData>, never>>(object: I): ObjectMetaData;
    fromSDK(object: ObjectMetaDataSDKType): ObjectMetaData;
    toSDK(message: ObjectMetaData): ObjectMetaDataSDKType;
    fromAmino(object: ObjectMetaDataAmino): ObjectMetaData;
    toAmino(message: ObjectMetaData): ObjectMetaDataAmino;
    fromAminoMsg(object: ObjectMetaDataAminoMsg): ObjectMetaData;
    fromProtoMsg(message: ObjectMetaDataProtoMsg): ObjectMetaData;
    toProto(message: ObjectMetaData): Uint8Array;
    toProtoMsg(message: ObjectMetaData): ObjectMetaDataProtoMsg;
};
export declare const GroupMetaData: {
    typeUrl: string;
    encode(message: GroupMetaData, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): GroupMetaData;
    fromJSON(object: any): GroupMetaData;
    toJSON(message: GroupMetaData): unknown;
    fromPartial<I extends {
        description?: string;
        externalUrl?: string;
        groupName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[];
    } & {
        description?: string;
        externalUrl?: string;
        groupName?: string;
        image?: string;
        attributes?: {
            traitType?: string;
            value?: string;
        }[] & ({
            traitType?: string;
            value?: string;
        } & {
            traitType?: string;
            value?: string;
        } & Record<Exclude<keyof I["attributes"][number], keyof Trait>, never>)[] & Record<Exclude<keyof I["attributes"], keyof {
            traitType?: string;
            value?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof GroupMetaData>, never>>(object: I): GroupMetaData;
    fromSDK(object: GroupMetaDataSDKType): GroupMetaData;
    toSDK(message: GroupMetaData): GroupMetaDataSDKType;
    fromAmino(object: GroupMetaDataAmino): GroupMetaData;
    toAmino(message: GroupMetaData): GroupMetaDataAmino;
    fromAminoMsg(object: GroupMetaDataAminoMsg): GroupMetaData;
    fromProtoMsg(message: GroupMetaDataProtoMsg): GroupMetaData;
    toProto(message: GroupMetaData): Uint8Array;
    toProtoMsg(message: GroupMetaData): GroupMetaDataProtoMsg;
};
export declare const Ids: {
    typeUrl: string;
    encode(message: Ids, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Ids;
    fromJSON(object: any): Ids;
    toJSON(message: Ids): unknown;
    fromPartial<I extends {
        id?: string[];
    } & {
        id?: string[] & string[] & Record<Exclude<keyof I["id"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, "id">, never>>(object: I): Ids;
    fromSDK(object: IdsSDKType): Ids;
    toSDK(message: Ids): IdsSDKType;
    fromAmino(object: IdsAmino): Ids;
    toAmino(message: Ids): IdsAmino;
    fromAminoMsg(object: IdsAminoMsg): Ids;
    fromProtoMsg(message: IdsProtoMsg): Ids;
    toProto(message: Ids): Uint8Array;
    toProtoMsg(message: Ids): IdsProtoMsg;
};
export declare const DeleteInfo: {
    typeUrl: string;
    encode(message: DeleteInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DeleteInfo;
    fromJSON(object: any): DeleteInfo;
    toJSON(message: DeleteInfo): unknown;
    fromPartial<I extends {
        bucketIds?: {
            id?: string[];
        };
        objectIds?: {
            id?: string[];
        };
        groupIds?: {
            id?: string[];
        };
    } & {
        bucketIds?: {
            id?: string[];
        } & {
            id?: string[] & string[] & Record<Exclude<keyof I["bucketIds"]["id"], keyof string[]>, never>;
        } & Record<Exclude<keyof I["bucketIds"], "id">, never>;
        objectIds?: {
            id?: string[];
        } & {
            id?: string[] & string[] & Record<Exclude<keyof I["objectIds"]["id"], keyof string[]>, never>;
        } & Record<Exclude<keyof I["objectIds"], "id">, never>;
        groupIds?: {
            id?: string[];
        } & {
            id?: string[] & string[] & Record<Exclude<keyof I["groupIds"]["id"], keyof string[]>, never>;
        } & Record<Exclude<keyof I["groupIds"], "id">, never>;
    } & Record<Exclude<keyof I, keyof DeleteInfo>, never>>(object: I): DeleteInfo;
    fromSDK(object: DeleteInfoSDKType): DeleteInfo;
    toSDK(message: DeleteInfo): DeleteInfoSDKType;
    fromAmino(object: DeleteInfoAmino): DeleteInfo;
    toAmino(message: DeleteInfo): DeleteInfoAmino;
    fromAminoMsg(object: DeleteInfoAminoMsg): DeleteInfo;
    fromProtoMsg(message: DeleteInfoProtoMsg): DeleteInfo;
    toProto(message: DeleteInfo): Uint8Array;
    toProtoMsg(message: DeleteInfo): DeleteInfoProtoMsg;
};
export declare const MigrationBucketInfo: {
    typeUrl: string;
    encode(message: MigrationBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MigrationBucketInfo;
    fromJSON(object: any): MigrationBucketInfo;
    toJSON(message: MigrationBucketInfo): unknown;
    fromPartial<I extends {
        srcSpId?: number;
        srcGlobalVirtualGroupFamilyId?: number;
        dstSpId?: number;
        bucketId?: string;
    } & {
        srcSpId?: number;
        srcGlobalVirtualGroupFamilyId?: number;
        dstSpId?: number;
        bucketId?: string;
    } & Record<Exclude<keyof I, keyof MigrationBucketInfo>, never>>(object: I): MigrationBucketInfo;
    fromSDK(object: MigrationBucketInfoSDKType): MigrationBucketInfo;
    toSDK(message: MigrationBucketInfo): MigrationBucketInfoSDKType;
    fromAmino(object: MigrationBucketInfoAmino): MigrationBucketInfo;
    toAmino(message: MigrationBucketInfo): MigrationBucketInfoAmino;
    fromAminoMsg(object: MigrationBucketInfoAminoMsg): MigrationBucketInfo;
    fromProtoMsg(message: MigrationBucketInfoProtoMsg): MigrationBucketInfo;
    toProto(message: MigrationBucketInfo): Uint8Array;
    toProtoMsg(message: MigrationBucketInfo): MigrationBucketInfoProtoMsg;
};
export declare const ResourceTags: {
    typeUrl: string;
    encode(message: ResourceTags, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResourceTags;
    fromJSON(object: any): ResourceTags;
    toJSON(message: ResourceTags): unknown;
    fromPartial<I extends {
        tags?: {
            key?: string;
            value?: string;
        }[];
    } & {
        tags?: {
            key?: string;
            value?: string;
        }[] & ({
            key?: string;
            value?: string;
        } & {
            key?: string;
            value?: string;
        } & Record<Exclude<keyof I["tags"][number], keyof ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["tags"], keyof {
            key?: string;
            value?: string;
        }[]>, never>;
    } & Record<Exclude<keyof I, "tags">, never>>(object: I): ResourceTags;
    fromSDK(object: ResourceTagsSDKType): ResourceTags;
    toSDK(message: ResourceTags): ResourceTagsSDKType;
    fromAmino(object: ResourceTagsAmino): ResourceTags;
    toAmino(message: ResourceTags): ResourceTagsAmino;
    fromAminoMsg(object: ResourceTagsAminoMsg): ResourceTags;
    fromProtoMsg(message: ResourceTagsProtoMsg): ResourceTags;
    toProto(message: ResourceTags): Uint8Array;
    toProtoMsg(message: ResourceTags): ResourceTagsProtoMsg;
};
export declare const ResourceTags_Tag: {
    typeUrl: string;
    encode(message: ResourceTags_Tag, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResourceTags_Tag;
    fromJSON(object: any): ResourceTags_Tag;
    toJSON(message: ResourceTags_Tag): unknown;
    fromPartial<I extends {
        key?: string;
        value?: string;
    } & {
        key?: string;
        value?: string;
    } & Record<Exclude<keyof I, keyof ResourceTags_Tag>, never>>(object: I): ResourceTags_Tag;
    fromSDK(object: ResourceTags_TagSDKType): ResourceTags_Tag;
    toSDK(message: ResourceTags_Tag): ResourceTags_TagSDKType;
    fromAmino(object: ResourceTags_TagAmino): ResourceTags_Tag;
    toAmino(message: ResourceTags_Tag): ResourceTags_TagAmino;
    fromAminoMsg(object: ResourceTags_TagAminoMsg): ResourceTags_Tag;
    fromProtoMsg(message: ResourceTags_TagProtoMsg): ResourceTags_Tag;
    toProto(message: ResourceTags_Tag): Uint8Array;
    toProtoMsg(message: ResourceTags_Tag): ResourceTags_TagProtoMsg;
};
