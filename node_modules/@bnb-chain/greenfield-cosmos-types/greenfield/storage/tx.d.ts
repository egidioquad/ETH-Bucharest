/// <reference types="long" />
import { VisibilityType, RedundancyType, GVGMapping, GVGMappingAmino, GVGMappingSDKType } from "./common";
import { Approval, ApprovalAmino, ApprovalSDKType } from "../common/approval";
import { UInt64Value, UInt64ValueAmino, UInt64ValueSDKType } from "../common/wrapper";
import { Principal, PrincipalAmino, PrincipalSDKType, Statement, StatementAmino, StatementSDKType } from "../permission/common";
import { Timestamp, TimestampSDKType } from "../../google/protobuf/timestamp";
import { Params, ParamsAmino, ParamsSDKType } from "./params";
import { ResourceTags, ResourceTagsAmino, ResourceTagsSDKType } from "./types";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
export interface MsgCreateBucket {
    /** creator defines the account address of bucket creator, it is also the bucket owner. */
    creator: string;
    /** bucket_name defines a globally unique name of bucket */
    bucketName: string;
    /**
     * visibility means the bucket is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility: VisibilityType;
    /** payment_address defines an account address specified by bucket owner to pay the read fee. Default: creator */
    paymentAddress: string;
    /** primary_sp_address defines the address of primary sp. */
    primarySpAddress: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    primarySpApproval?: Approval;
    /**
     * charged_read_quota defines the read data that users are charged for, measured in bytes.
     * The available read data for each user is the sum of the free read data provided by SP and
     * the ChargeReadQuota specified here.
     */
    chargedReadQuota: Long;
}
export interface MsgCreateBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgCreateBucket";
    value: Uint8Array;
}
export interface MsgCreateBucketAmino {
    /** creator defines the account address of bucket creator, it is also the bucket owner. */
    creator?: string;
    /** bucket_name defines a globally unique name of bucket */
    bucket_name?: string;
    /**
     * visibility means the bucket is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility?: VisibilityType;
    /** payment_address defines an account address specified by bucket owner to pay the read fee. Default: creator */
    payment_address?: string;
    /** primary_sp_address defines the address of primary sp. */
    primary_sp_address?: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    primary_sp_approval?: ApprovalAmino;
    /**
     * charged_read_quota defines the read data that users are charged for, measured in bytes.
     * The available read data for each user is the sum of the free read data provided by SP and
     * the ChargeReadQuota specified here.
     */
    charged_read_quota?: string;
}
export interface MsgCreateBucketAminoMsg {
    type: "/greenfield.storage.MsgCreateBucket";
    value: MsgCreateBucketAmino;
}
export interface MsgCreateBucketSDKType {
    creator: string;
    bucket_name: string;
    visibility: VisibilityType;
    payment_address: string;
    primary_sp_address: string;
    primary_sp_approval?: ApprovalSDKType;
    charged_read_quota: Long;
}
export interface MsgCreateBucketResponse {
    bucketId: string;
}
export interface MsgCreateBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgCreateBucketResponse";
    value: Uint8Array;
}
export interface MsgCreateBucketResponseAmino {
    bucket_id?: string;
}
export interface MsgCreateBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgCreateBucketResponse";
    value: MsgCreateBucketResponseAmino;
}
export interface MsgCreateBucketResponseSDKType {
    bucket_id: string;
}
export interface MsgDeleteBucket {
    /** creator defines the account address of the grantee who has the DeleteBucket permission of the bucket to be deleted. */
    operator: string;
    /** bucket_name defines the name of the bucket to be deleted. */
    bucketName: string;
}
export interface MsgDeleteBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeleteBucket";
    value: Uint8Array;
}
export interface MsgDeleteBucketAmino {
    /** creator defines the account address of the grantee who has the DeleteBucket permission of the bucket to be deleted. */
    operator?: string;
    /** bucket_name defines the name of the bucket to be deleted. */
    bucket_name?: string;
}
export interface MsgDeleteBucketAminoMsg {
    type: "/greenfield.storage.MsgDeleteBucket";
    value: MsgDeleteBucketAmino;
}
export interface MsgDeleteBucketSDKType {
    operator: string;
    bucket_name: string;
}
export interface MsgDeleteBucketResponse {
}
export interface MsgDeleteBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeleteBucketResponse";
    value: Uint8Array;
}
export interface MsgDeleteBucketResponseAmino {
}
export interface MsgDeleteBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgDeleteBucketResponse";
    value: MsgDeleteBucketResponseAmino;
}
export interface MsgDeleteBucketResponseSDKType {
}
export interface MsgDiscontinueBucket {
    /** operator is the sp who wants to stop serving the bucket. */
    operator: string;
    /** bucket_name defines the name of the bucket where the object which to be discontinued is stored. */
    bucketName: string;
    /** the reason for the request. */
    reason: string;
}
export interface MsgDiscontinueBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgDiscontinueBucket";
    value: Uint8Array;
}
export interface MsgDiscontinueBucketAmino {
    /** operator is the sp who wants to stop serving the bucket. */
    operator?: string;
    /** bucket_name defines the name of the bucket where the object which to be discontinued is stored. */
    bucket_name?: string;
    /** the reason for the request. */
    reason?: string;
}
export interface MsgDiscontinueBucketAminoMsg {
    type: "/greenfield.storage.MsgDiscontinueBucket";
    value: MsgDiscontinueBucketAmino;
}
export interface MsgDiscontinueBucketSDKType {
    operator: string;
    bucket_name: string;
    reason: string;
}
export interface MsgDiscontinueBucketResponse {
}
export interface MsgDiscontinueBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgDiscontinueBucketResponse";
    value: Uint8Array;
}
export interface MsgDiscontinueBucketResponseAmino {
}
export interface MsgDiscontinueBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgDiscontinueBucketResponse";
    value: MsgDiscontinueBucketResponseAmino;
}
export interface MsgDiscontinueBucketResponseSDKType {
}
export interface MsgCreateObject {
    /** creator defines the account address of object uploader */
    creator: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucketName: string;
    /** object_name defines the name of object */
    objectName: string;
    /** payload_size defines size of the object's payload */
    payloadSize: Long;
    /**
     * visibility means the object is private or public. if private, only object owner or grantee can access it,
     * otherwise every greenfield user can access it.
     */
    visibility: VisibilityType;
    /** content_type defines a standard MIME type describing the format of the object. */
    contentType: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    primarySpApproval?: Approval;
    /** expect_checksums defines a list of hashes which was generate by redundancy algorithm. */
    expectChecksums: Uint8Array[];
    /** redundancy_type can be ec or replica */
    redundancyType: RedundancyType;
}
export interface MsgCreateObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgCreateObject";
    value: Uint8Array;
}
export interface MsgCreateObjectAmino {
    /** creator defines the account address of object uploader */
    creator?: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucket_name?: string;
    /** object_name defines the name of object */
    object_name?: string;
    /** payload_size defines size of the object's payload */
    payload_size?: string;
    /**
     * visibility means the object is private or public. if private, only object owner or grantee can access it,
     * otherwise every greenfield user can access it.
     */
    visibility?: VisibilityType;
    /** content_type defines a standard MIME type describing the format of the object. */
    content_type?: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    primary_sp_approval?: ApprovalAmino;
    /** expect_checksums defines a list of hashes which was generate by redundancy algorithm. */
    expect_checksums?: string[];
    /** redundancy_type can be ec or replica */
    redundancy_type?: RedundancyType;
}
export interface MsgCreateObjectAminoMsg {
    type: "/greenfield.storage.MsgCreateObject";
    value: MsgCreateObjectAmino;
}
export interface MsgCreateObjectSDKType {
    creator: string;
    bucket_name: string;
    object_name: string;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    primary_sp_approval?: ApprovalSDKType;
    expect_checksums: Uint8Array[];
    redundancy_type: RedundancyType;
}
export interface MsgCreateObjectResponse {
    objectId: string;
}
export interface MsgCreateObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgCreateObjectResponse";
    value: Uint8Array;
}
export interface MsgCreateObjectResponseAmino {
    object_id?: string;
}
export interface MsgCreateObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgCreateObjectResponse";
    value: MsgCreateObjectResponseAmino;
}
export interface MsgCreateObjectResponseSDKType {
    object_id: string;
}
export interface MsgSealObject {
    /** operator defines the account address of primary SP */
    operator: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucketName: string;
    /** object_name defines the name of object to be sealed. */
    objectName: string;
    /** global_virtual_group_id defines the id of global virtual group */
    globalVirtualGroupId: number;
    /**
     * secondary_sp_bls_agg_signatures defines the aggregate bls signature of the secondary sp that can
     * acknowledge that the payload data has received and stored.
     */
    secondarySpBlsAggSignatures: Uint8Array;
}
export interface MsgSealObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgSealObject";
    value: Uint8Array;
}
export interface MsgSealObjectAmino {
    /** operator defines the account address of primary SP */
    operator?: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucket_name?: string;
    /** object_name defines the name of object to be sealed. */
    object_name?: string;
    /** global_virtual_group_id defines the id of global virtual group */
    global_virtual_group_id?: number;
    /**
     * secondary_sp_bls_agg_signatures defines the aggregate bls signature of the secondary sp that can
     * acknowledge that the payload data has received and stored.
     */
    secondary_sp_bls_agg_signatures?: string;
}
export interface MsgSealObjectAminoMsg {
    type: "/greenfield.storage.MsgSealObject";
    value: MsgSealObjectAmino;
}
export interface MsgSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    global_virtual_group_id: number;
    secondary_sp_bls_agg_signatures: Uint8Array;
}
export interface MsgSealObjectResponse {
}
export interface MsgSealObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgSealObjectResponse";
    value: Uint8Array;
}
export interface MsgSealObjectResponseAmino {
}
export interface MsgSealObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgSealObjectResponse";
    value: MsgSealObjectResponseAmino;
}
export interface MsgSealObjectResponseSDKType {
}
export interface MsgRejectSealObject {
    /** operator defines the account address of the object owner */
    operator: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucketName: string;
    /** object_name defines the name of unsealed object to be reject. */
    objectName: string;
}
export interface MsgRejectSealObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgRejectSealObject";
    value: Uint8Array;
}
export interface MsgRejectSealObjectAmino {
    /** operator defines the account address of the object owner */
    operator?: string;
    /** bucket_name defines the name of the bucket where the object is stored. */
    bucket_name?: string;
    /** object_name defines the name of unsealed object to be reject. */
    object_name?: string;
}
export interface MsgRejectSealObjectAminoMsg {
    type: "/greenfield.storage.MsgRejectSealObject";
    value: MsgRejectSealObjectAmino;
}
export interface MsgRejectSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
}
export interface MsgRejectSealObjectResponse {
}
export interface MsgRejectSealObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgRejectSealObjectResponse";
    value: Uint8Array;
}
export interface MsgRejectSealObjectResponseAmino {
}
export interface MsgRejectSealObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgRejectSealObjectResponse";
    value: MsgRejectSealObjectResponseAmino;
}
export interface MsgRejectSealObjectResponseSDKType {
}
export interface MsgCopyObject {
    /** operator defines the account address of the operator who has the CopyObject permission. */
    operator: string;
    /** src_bucket_name defines the name of the bucket where the object to be copied is located */
    srcBucketName: string;
    /** dst_bucket_name defines the name of the bucket where the object is copied to. */
    dstBucketName: string;
    /** src_object_name defines the name of the object which to be copied */
    srcObjectName: string;
    /** dst_object_name defines the name of the object which is copied to */
    dstObjectName: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    dstPrimarySpApproval?: Approval;
}
export interface MsgCopyObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgCopyObject";
    value: Uint8Array;
}
export interface MsgCopyObjectAmino {
    /** operator defines the account address of the operator who has the CopyObject permission. */
    operator?: string;
    /** src_bucket_name defines the name of the bucket where the object to be copied is located */
    src_bucket_name?: string;
    /** dst_bucket_name defines the name of the bucket where the object is copied to. */
    dst_bucket_name?: string;
    /** src_object_name defines the name of the object which to be copied */
    src_object_name?: string;
    /** dst_object_name defines the name of the object which is copied to */
    dst_object_name?: string;
    /** primary_sp_approval defines the approval info of the primary SP which indicates that primary sp confirm the user's request. */
    dst_primary_sp_approval?: ApprovalAmino;
}
export interface MsgCopyObjectAminoMsg {
    type: "/greenfield.storage.MsgCopyObject";
    value: MsgCopyObjectAmino;
}
export interface MsgCopyObjectSDKType {
    operator: string;
    src_bucket_name: string;
    dst_bucket_name: string;
    src_object_name: string;
    dst_object_name: string;
    dst_primary_sp_approval?: ApprovalSDKType;
}
export interface MsgCopyObjectResponse {
    objectId: string;
}
export interface MsgCopyObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgCopyObjectResponse";
    value: Uint8Array;
}
export interface MsgCopyObjectResponseAmino {
    object_id?: string;
}
export interface MsgCopyObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgCopyObjectResponse";
    value: MsgCopyObjectResponseAmino;
}
export interface MsgCopyObjectResponseSDKType {
    object_id: string;
}
export interface MsgDeleteObject {
    /** operator defines the account address of the operator who has the DeleteObject permission of the object to be deleted. */
    operator: string;
    /** bucket_name defines the name of the bucket where the object which to be deleted is stored. */
    bucketName: string;
    /** object_name defines the name of the object which to be deleted. */
    objectName: string;
}
export interface MsgDeleteObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeleteObject";
    value: Uint8Array;
}
export interface MsgDeleteObjectAmino {
    /** operator defines the account address of the operator who has the DeleteObject permission of the object to be deleted. */
    operator?: string;
    /** bucket_name defines the name of the bucket where the object which to be deleted is stored. */
    bucket_name?: string;
    /** object_name defines the name of the object which to be deleted. */
    object_name?: string;
}
export interface MsgDeleteObjectAminoMsg {
    type: "/greenfield.storage.MsgDeleteObject";
    value: MsgDeleteObjectAmino;
}
export interface MsgDeleteObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
}
export interface MsgDeleteObjectResponse {
}
export interface MsgDeleteObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeleteObjectResponse";
    value: Uint8Array;
}
export interface MsgDeleteObjectResponseAmino {
}
export interface MsgDeleteObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgDeleteObjectResponse";
    value: MsgDeleteObjectResponseAmino;
}
export interface MsgDeleteObjectResponseSDKType {
}
export interface MsgDiscontinueObject {
    /** operator is the sp who wants to stop serving the objects. */
    operator: string;
    /** bucket_name defines the name of the bucket where the object which to be discontinued is stored. */
    bucketName: string;
    /** object_ids are the ids of object info. */
    objectIds: string[];
    /** the reason for the request. */
    reason: string;
}
export interface MsgDiscontinueObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgDiscontinueObject";
    value: Uint8Array;
}
export interface MsgDiscontinueObjectAmino {
    /** operator is the sp who wants to stop serving the objects. */
    operator?: string;
    /** bucket_name defines the name of the bucket where the object which to be discontinued is stored. */
    bucket_name?: string;
    /** object_ids are the ids of object info. */
    object_ids?: string[];
    /** the reason for the request. */
    reason?: string;
}
export interface MsgDiscontinueObjectAminoMsg {
    type: "/greenfield.storage.MsgDiscontinueObject";
    value: MsgDiscontinueObjectAmino;
}
export interface MsgDiscontinueObjectSDKType {
    operator: string;
    bucket_name: string;
    object_ids: string[];
    reason: string;
}
export interface MsgDiscontinueObjectResponse {
}
export interface MsgDiscontinueObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgDiscontinueObjectResponse";
    value: Uint8Array;
}
export interface MsgDiscontinueObjectResponseAmino {
}
export interface MsgDiscontinueObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgDiscontinueObjectResponse";
    value: MsgDiscontinueObjectResponseAmino;
}
export interface MsgDiscontinueObjectResponseSDKType {
}
export interface MsgCreateGroup {
    /** owner defines the account address of group owner who create the group */
    creator: string;
    /** group_name defines the name of the group. it's not globally unique. */
    groupName: string;
    /** extra defines extra info for the group */
    extra: string;
}
export interface MsgCreateGroupProtoMsg {
    typeUrl: "/greenfield.storage.MsgCreateGroup";
    value: Uint8Array;
}
export interface MsgCreateGroupAmino {
    /** owner defines the account address of group owner who create the group */
    creator?: string;
    /** group_name defines the name of the group. it's not globally unique. */
    group_name?: string;
    /** extra defines extra info for the group */
    extra?: string;
}
export interface MsgCreateGroupAminoMsg {
    type: "/greenfield.storage.MsgCreateGroup";
    value: MsgCreateGroupAmino;
}
export interface MsgCreateGroupSDKType {
    creator: string;
    group_name: string;
    extra: string;
}
export interface MsgCreateGroupResponse {
    groupId: string;
}
export interface MsgCreateGroupResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgCreateGroupResponse";
    value: Uint8Array;
}
export interface MsgCreateGroupResponseAmino {
    group_id?: string;
}
export interface MsgCreateGroupResponseAminoMsg {
    type: "/greenfield.storage.MsgCreateGroupResponse";
    value: MsgCreateGroupResponseAmino;
}
export interface MsgCreateGroupResponseSDKType {
    group_id: string;
}
export interface MsgDeleteGroup {
    /** operator defines the account address of the operator who has the DeleteGroup permission of the group to be deleted. */
    operator: string;
    /** group_name defines the name of the group which to be deleted */
    groupName: string;
}
export interface MsgDeleteGroupProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeleteGroup";
    value: Uint8Array;
}
export interface MsgDeleteGroupAmino {
    /** operator defines the account address of the operator who has the DeleteGroup permission of the group to be deleted. */
    operator?: string;
    /** group_name defines the name of the group which to be deleted */
    group_name?: string;
}
export interface MsgDeleteGroupAminoMsg {
    type: "/greenfield.storage.MsgDeleteGroup";
    value: MsgDeleteGroupAmino;
}
export interface MsgDeleteGroupSDKType {
    operator: string;
    group_name: string;
}
export interface MsgDeleteGroupResponse {
}
export interface MsgDeleteGroupResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeleteGroupResponse";
    value: Uint8Array;
}
export interface MsgDeleteGroupResponseAmino {
}
export interface MsgDeleteGroupResponseAminoMsg {
    type: "/greenfield.storage.MsgDeleteGroupResponse";
    value: MsgDeleteGroupResponseAmino;
}
export interface MsgDeleteGroupResponseSDKType {
}
export interface MsgUpdateGroupMember {
    /** operator defines the account address of the operator who has the UpdateGroupMember permission of the group. */
    operator: string;
    /** group_owner defines the account address of the group owner */
    groupOwner: string;
    /** group_name defines the name of the group which to be updated */
    groupName: string;
    /** members_to_add defines a list of members account address which will be add to the group */
    membersToAdd: MsgGroupMember[];
    /** members_to_delete defines a list of members account address which will be remove from the group */
    membersToDelete: string[];
}
export interface MsgUpdateGroupMemberProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateGroupMember";
    value: Uint8Array;
}
export interface MsgUpdateGroupMemberAmino {
    /** operator defines the account address of the operator who has the UpdateGroupMember permission of the group. */
    operator?: string;
    /** group_owner defines the account address of the group owner */
    group_owner?: string;
    /** group_name defines the name of the group which to be updated */
    group_name?: string;
    /** members_to_add defines a list of members account address which will be add to the group */
    members_to_add?: MsgGroupMemberAmino[];
    /** members_to_delete defines a list of members account address which will be remove from the group */
    members_to_delete?: string[];
}
export interface MsgUpdateGroupMemberAminoMsg {
    type: "/greenfield.storage.MsgUpdateGroupMember";
    value: MsgUpdateGroupMemberAmino;
}
export interface MsgUpdateGroupMemberSDKType {
    operator: string;
    group_owner: string;
    group_name: string;
    members_to_add: MsgGroupMemberSDKType[];
    members_to_delete: string[];
}
export interface MsgUpdateGroupMemberResponse {
}
export interface MsgUpdateGroupMemberResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateGroupMemberResponse";
    value: Uint8Array;
}
export interface MsgUpdateGroupMemberResponseAmino {
}
export interface MsgUpdateGroupMemberResponseAminoMsg {
    type: "/greenfield.storage.MsgUpdateGroupMemberResponse";
    value: MsgUpdateGroupMemberResponseAmino;
}
export interface MsgUpdateGroupMemberResponseSDKType {
}
export interface MsgRenewGroupMember {
    /** operator defines the account address of the operator who has the UpdateGroupMember permission of the group. */
    operator: string;
    /** group_owner defines the account address of the group owner */
    groupOwner: string;
    /** group_name defines the name of the group which to be updated */
    groupName: string;
    /** members defines a list of members which will be renew to the group */
    members: MsgGroupMember[];
}
export interface MsgRenewGroupMemberProtoMsg {
    typeUrl: "/greenfield.storage.MsgRenewGroupMember";
    value: Uint8Array;
}
export interface MsgRenewGroupMemberAmino {
    /** operator defines the account address of the operator who has the UpdateGroupMember permission of the group. */
    operator?: string;
    /** group_owner defines the account address of the group owner */
    group_owner?: string;
    /** group_name defines the name of the group which to be updated */
    group_name?: string;
    /** members defines a list of members which will be renew to the group */
    members?: MsgGroupMemberAmino[];
}
export interface MsgRenewGroupMemberAminoMsg {
    type: "/greenfield.storage.MsgRenewGroupMember";
    value: MsgRenewGroupMemberAmino;
}
export interface MsgRenewGroupMemberSDKType {
    operator: string;
    group_owner: string;
    group_name: string;
    members: MsgGroupMemberSDKType[];
}
export interface MsgRenewGroupMemberResponse {
}
export interface MsgRenewGroupMemberResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgRenewGroupMemberResponse";
    value: Uint8Array;
}
export interface MsgRenewGroupMemberResponseAmino {
}
export interface MsgRenewGroupMemberResponseAminoMsg {
    type: "/greenfield.storage.MsgRenewGroupMemberResponse";
    value: MsgRenewGroupMemberResponseAmino;
}
export interface MsgRenewGroupMemberResponseSDKType {
}
export interface MsgGroupMember {
    /** member defines the account address of the group member */
    member: string;
    /** expiration_time defines the expiration time of the group member */
    expirationTime?: Timestamp;
}
export interface MsgGroupMemberProtoMsg {
    typeUrl: "/greenfield.storage.MsgGroupMember";
    value: Uint8Array;
}
export interface MsgGroupMemberAmino {
    /** member defines the account address of the group member */
    member?: string;
    /** expiration_time defines the expiration time of the group member */
    expiration_time?: string;
}
export interface MsgGroupMemberAminoMsg {
    type: "/greenfield.storage.MsgGroupMember";
    value: MsgGroupMemberAmino;
}
export interface MsgGroupMemberSDKType {
    member: string;
    expiration_time?: TimestampSDKType;
}
export interface MsgUpdateGroupExtra {
    /** operator defines the account address of the operator who has the UpdateGroupMember permission of the group. */
    operator: string;
    /** group_owner defines the account address of the group owner */
    groupOwner: string;
    /** group_name defines the name of the group which to be updated */
    groupName: string;
    /** extra defines extra info for the group to update */
    extra: string;
}
export interface MsgUpdateGroupExtraProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateGroupExtra";
    value: Uint8Array;
}
export interface MsgUpdateGroupExtraAmino {
    /** operator defines the account address of the operator who has the UpdateGroupMember permission of the group. */
    operator?: string;
    /** group_owner defines the account address of the group owner */
    group_owner?: string;
    /** group_name defines the name of the group which to be updated */
    group_name?: string;
    /** extra defines extra info for the group to update */
    extra?: string;
}
export interface MsgUpdateGroupExtraAminoMsg {
    type: "/greenfield.storage.MsgUpdateGroupExtra";
    value: MsgUpdateGroupExtraAmino;
}
export interface MsgUpdateGroupExtraSDKType {
    operator: string;
    group_owner: string;
    group_name: string;
    extra: string;
}
export interface MsgUpdateGroupExtraResponse {
}
export interface MsgUpdateGroupExtraResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateGroupExtraResponse";
    value: Uint8Array;
}
export interface MsgUpdateGroupExtraResponseAmino {
}
export interface MsgUpdateGroupExtraResponseAminoMsg {
    type: "/greenfield.storage.MsgUpdateGroupExtraResponse";
    value: MsgUpdateGroupExtraResponseAmino;
}
export interface MsgUpdateGroupExtraResponseSDKType {
}
export interface MsgLeaveGroup {
    /** member defines the account address of the member who want to leave the group */
    member: string;
    /** group_owner defines the owner of the group you want to leave */
    groupOwner: string;
    /** group_name defines the name of the group you want to leave */
    groupName: string;
}
export interface MsgLeaveGroupProtoMsg {
    typeUrl: "/greenfield.storage.MsgLeaveGroup";
    value: Uint8Array;
}
export interface MsgLeaveGroupAmino {
    /** member defines the account address of the member who want to leave the group */
    member?: string;
    /** group_owner defines the owner of the group you want to leave */
    group_owner?: string;
    /** group_name defines the name of the group you want to leave */
    group_name?: string;
}
export interface MsgLeaveGroupAminoMsg {
    type: "/greenfield.storage.MsgLeaveGroup";
    value: MsgLeaveGroupAmino;
}
export interface MsgLeaveGroupSDKType {
    member: string;
    group_owner: string;
    group_name: string;
}
export interface MsgLeaveGroupResponse {
}
export interface MsgLeaveGroupResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgLeaveGroupResponse";
    value: Uint8Array;
}
export interface MsgLeaveGroupResponseAmino {
}
export interface MsgLeaveGroupResponseAminoMsg {
    type: "/greenfield.storage.MsgLeaveGroupResponse";
    value: MsgLeaveGroupResponseAmino;
}
export interface MsgLeaveGroupResponseSDKType {
}
export interface MsgUpdateBucketInfo {
    /** operator defines the account address of the operator */
    operator: string;
    /** bucket_name defines the name of bucket which you'll update */
    bucketName: string;
    /**
     * charged_read_quota defines the traffic quota that you read from primary sp
     * if read_quota is nil, it means don't change the read_quota
     */
    chargedReadQuota?: UInt64Value;
    /**
     * payment_address defines the account address of the payment account
     * if payment_address is empty, it means don't change the payment_address
     */
    paymentAddress: string;
    /**
     * visibility means the bucket is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility: VisibilityType;
}
export interface MsgUpdateBucketInfoProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateBucketInfo";
    value: Uint8Array;
}
export interface MsgUpdateBucketInfoAmino {
    /** operator defines the account address of the operator */
    operator?: string;
    /** bucket_name defines the name of bucket which you'll update */
    bucket_name?: string;
    /**
     * charged_read_quota defines the traffic quota that you read from primary sp
     * if read_quota is nil, it means don't change the read_quota
     */
    charged_read_quota?: UInt64ValueAmino;
    /**
     * payment_address defines the account address of the payment account
     * if payment_address is empty, it means don't change the payment_address
     */
    payment_address?: string;
    /**
     * visibility means the bucket is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility?: VisibilityType;
}
export interface MsgUpdateBucketInfoAminoMsg {
    type: "/greenfield.storage.MsgUpdateBucketInfo";
    value: MsgUpdateBucketInfoAmino;
}
export interface MsgUpdateBucketInfoSDKType {
    operator: string;
    bucket_name: string;
    charged_read_quota?: UInt64ValueSDKType;
    payment_address: string;
    visibility: VisibilityType;
}
export interface MsgUpdateBucketInfoResponse {
}
export interface MsgUpdateBucketInfoResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateBucketInfoResponse";
    value: Uint8Array;
}
export interface MsgUpdateBucketInfoResponseAmino {
}
export interface MsgUpdateBucketInfoResponseAminoMsg {
    type: "/greenfield.storage.MsgUpdateBucketInfoResponse";
    value: MsgUpdateBucketInfoResponseAmino;
}
export interface MsgUpdateBucketInfoResponseSDKType {
}
export interface MsgCancelCreateObject {
    /** operator defines the account address of the operator */
    operator: string;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** object_name defines the name of the object */
    objectName: string;
}
export interface MsgCancelCreateObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgCancelCreateObject";
    value: Uint8Array;
}
export interface MsgCancelCreateObjectAmino {
    /** operator defines the account address of the operator */
    operator?: string;
    /** bucket_name defines the name of the bucket */
    bucket_name?: string;
    /** object_name defines the name of the object */
    object_name?: string;
}
export interface MsgCancelCreateObjectAminoMsg {
    type: "/greenfield.storage.MsgCancelCreateObject";
    value: MsgCancelCreateObjectAmino;
}
export interface MsgCancelCreateObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
}
export interface MsgCancelCreateObjectResponse {
}
export interface MsgCancelCreateObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgCancelCreateObjectResponse";
    value: Uint8Array;
}
export interface MsgCancelCreateObjectResponseAmino {
}
export interface MsgCancelCreateObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgCancelCreateObjectResponse";
    value: MsgCancelCreateObjectResponseAmino;
}
export interface MsgCancelCreateObjectResponseSDKType {
}
export interface MsgPutPolicy {
    /** operator defines the granter who grant the permission to another principal */
    operator: string;
    /** Principal defines the roles that can be grant permissions to. Currently, it can be account or group. */
    principal?: Principal;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource: string;
    /** statements defines a list of individual statement which describe the detail rules of policy */
    statements: Statement[];
    /**
     * expiration_time defines the whole expiration time of all the statements.
     * Notices: Its priority is higher than the expiration time inside the Statement
     */
    expirationTime?: Timestamp;
}
export interface MsgPutPolicyProtoMsg {
    typeUrl: "/greenfield.storage.MsgPutPolicy";
    value: Uint8Array;
}
export interface MsgPutPolicyAmino {
    /** operator defines the granter who grant the permission to another principal */
    operator?: string;
    /** Principal defines the roles that can be grant permissions to. Currently, it can be account or group. */
    principal?: PrincipalAmino;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource?: string;
    /** statements defines a list of individual statement which describe the detail rules of policy */
    statements?: StatementAmino[];
    /**
     * expiration_time defines the whole expiration time of all the statements.
     * Notices: Its priority is higher than the expiration time inside the Statement
     */
    expiration_time?: string;
}
export interface MsgPutPolicyAminoMsg {
    type: "/greenfield.storage.MsgPutPolicy";
    value: MsgPutPolicyAmino;
}
export interface MsgPutPolicySDKType {
    operator: string;
    principal?: PrincipalSDKType;
    resource: string;
    statements: StatementSDKType[];
    expiration_time?: TimestampSDKType;
}
export interface MsgPutPolicyResponse {
    policyId: string;
}
export interface MsgPutPolicyResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgPutPolicyResponse";
    value: Uint8Array;
}
export interface MsgPutPolicyResponseAmino {
    policy_id?: string;
}
export interface MsgPutPolicyResponseAminoMsg {
    type: "/greenfield.storage.MsgPutPolicyResponse";
    value: MsgPutPolicyResponseAmino;
}
export interface MsgPutPolicyResponseSDKType {
    policy_id: string;
}
export interface MsgDeletePolicy {
    /** operator defines the granter who grant the permission to another principal */
    operator: string;
    /** Principal defines the roles that can grant permissions. Currently, it can be account or group. */
    principal?: Principal;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource: string;
}
export interface MsgDeletePolicyProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeletePolicy";
    value: Uint8Array;
}
export interface MsgDeletePolicyAmino {
    /** operator defines the granter who grant the permission to another principal */
    operator?: string;
    /** Principal defines the roles that can grant permissions. Currently, it can be account or group. */
    principal?: PrincipalAmino;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource?: string;
}
export interface MsgDeletePolicyAminoMsg {
    type: "/greenfield.storage.MsgDeletePolicy";
    value: MsgDeletePolicyAmino;
}
export interface MsgDeletePolicySDKType {
    operator: string;
    principal?: PrincipalSDKType;
    resource: string;
}
export interface MsgDeletePolicyResponse {
    policyId: string;
}
export interface MsgDeletePolicyResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgDeletePolicyResponse";
    value: Uint8Array;
}
export interface MsgDeletePolicyResponseAmino {
    policy_id?: string;
}
export interface MsgDeletePolicyResponseAminoMsg {
    type: "/greenfield.storage.MsgDeletePolicyResponse";
    value: MsgDeletePolicyResponseAmino;
}
export interface MsgDeletePolicyResponseSDKType {
    policy_id: string;
}
export interface MsgMirrorObject {
    /** operator defines the account address of the object owner. */
    operator: string;
    /** id defines the unique u256 for object. */
    id: string;
    /** bucket_name defines the name of the bucket where the object is stored */
    bucketName: string;
    /** object_name defines the name of object */
    objectName: string;
    /** destination chain id */
    destChainId: number;
}
export interface MsgMirrorObjectProtoMsg {
    typeUrl: "/greenfield.storage.MsgMirrorObject";
    value: Uint8Array;
}
export interface MsgMirrorObjectAmino {
    /** operator defines the account address of the object owner. */
    operator?: string;
    /** id defines the unique u256 for object. */
    id?: string;
    /** bucket_name defines the name of the bucket where the object is stored */
    bucket_name?: string;
    /** object_name defines the name of object */
    object_name?: string;
    /** destination chain id */
    dest_chain_id?: number;
}
export interface MsgMirrorObjectAminoMsg {
    type: "/greenfield.storage.MsgMirrorObject";
    value: MsgMirrorObjectAmino;
}
export interface MsgMirrorObjectSDKType {
    operator: string;
    id: string;
    bucket_name: string;
    object_name: string;
    dest_chain_id: number;
}
export interface MsgMirrorObjectResponse {
}
export interface MsgMirrorObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgMirrorObjectResponse";
    value: Uint8Array;
}
export interface MsgMirrorObjectResponseAmino {
}
export interface MsgMirrorObjectResponseAminoMsg {
    type: "/greenfield.storage.MsgMirrorObjectResponse";
    value: MsgMirrorObjectResponseAmino;
}
export interface MsgMirrorObjectResponseSDKType {
}
export interface MsgMirrorBucket {
    /** operator defines the account address of the bucket owner. */
    operator: string;
    /** id defines the unique u256 for bucket. */
    id: string;
    /** bucket_name defines a globally unique name of bucket */
    bucketName: string;
    /** destination chain id */
    destChainId: number;
}
export interface MsgMirrorBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgMirrorBucket";
    value: Uint8Array;
}
export interface MsgMirrorBucketAmino {
    /** operator defines the account address of the bucket owner. */
    operator?: string;
    /** id defines the unique u256 for bucket. */
    id?: string;
    /** bucket_name defines a globally unique name of bucket */
    bucket_name?: string;
    /** destination chain id */
    dest_chain_id?: number;
}
export interface MsgMirrorBucketAminoMsg {
    type: "/greenfield.storage.MsgMirrorBucket";
    value: MsgMirrorBucketAmino;
}
export interface MsgMirrorBucketSDKType {
    operator: string;
    id: string;
    bucket_name: string;
    dest_chain_id: number;
}
export interface MsgUpdateObjectInfoResponse {
}
export interface MsgUpdateObjectInfoResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateObjectInfoResponse";
    value: Uint8Array;
}
export interface MsgUpdateObjectInfoResponseAmino {
}
export interface MsgUpdateObjectInfoResponseAminoMsg {
    type: "/greenfield.storage.MsgUpdateObjectInfoResponse";
    value: MsgUpdateObjectInfoResponseAmino;
}
export interface MsgUpdateObjectInfoResponseSDKType {
}
export interface MsgUpdateObjectInfo {
    /** operator defines the account address of the operator */
    operator: string;
    /** bucket_name is the name of the bucket */
    bucketName: string;
    /** object_name defines the name of bucket which you'll update */
    objectName: string;
    /**
     * visibility means the object is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility: VisibilityType;
}
export interface MsgUpdateObjectInfoProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateObjectInfo";
    value: Uint8Array;
}
export interface MsgUpdateObjectInfoAmino {
    /** operator defines the account address of the operator */
    operator?: string;
    /** bucket_name is the name of the bucket */
    bucket_name?: string;
    /** object_name defines the name of bucket which you'll update */
    object_name?: string;
    /**
     * visibility means the object is private or public. if private, only bucket owner or grantee can read it,
     * otherwise every greenfield user can read it.
     */
    visibility?: VisibilityType;
}
export interface MsgUpdateObjectInfoAminoMsg {
    type: "/greenfield.storage.MsgUpdateObjectInfo";
    value: MsgUpdateObjectInfoAmino;
}
export interface MsgUpdateObjectInfoSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    visibility: VisibilityType;
}
export interface MsgMirrorBucketResponse {
}
export interface MsgMirrorBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgMirrorBucketResponse";
    value: Uint8Array;
}
export interface MsgMirrorBucketResponseAmino {
}
export interface MsgMirrorBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgMirrorBucketResponse";
    value: MsgMirrorBucketResponseAmino;
}
export interface MsgMirrorBucketResponseSDKType {
}
export interface MsgMirrorGroup {
    /** operator defines the account address of the group owner. */
    operator: string;
    /** id defines the unique u256 for group. */
    id: string;
    /** group_name defines the name of the group */
    groupName: string;
    /** destination chain id */
    destChainId: number;
}
export interface MsgMirrorGroupProtoMsg {
    typeUrl: "/greenfield.storage.MsgMirrorGroup";
    value: Uint8Array;
}
export interface MsgMirrorGroupAmino {
    /** operator defines the account address of the group owner. */
    operator?: string;
    /** id defines the unique u256 for group. */
    id?: string;
    /** group_name defines the name of the group */
    group_name?: string;
    /** destination chain id */
    dest_chain_id?: number;
}
export interface MsgMirrorGroupAminoMsg {
    type: "/greenfield.storage.MsgMirrorGroup";
    value: MsgMirrorGroupAmino;
}
export interface MsgMirrorGroupSDKType {
    operator: string;
    id: string;
    group_name: string;
    dest_chain_id: number;
}
export interface MsgMirrorGroupResponse {
}
export interface MsgMirrorGroupResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgMirrorGroupResponse";
    value: Uint8Array;
}
export interface MsgMirrorGroupResponseAmino {
}
export interface MsgMirrorGroupResponseAminoMsg {
    type: "/greenfield.storage.MsgMirrorGroupResponse";
    value: MsgMirrorGroupResponseAmino;
}
export interface MsgMirrorGroupResponseSDKType {
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
    /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
    authority: string;
    /**
     * params defines the x/storage parameters to update.
     * NOTE: All parameters must be supplied.
     */
    params: Params;
}
export interface MsgUpdateParamsProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateParams";
    value: Uint8Array;
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParamsAmino {
    /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
    authority?: string;
    /**
     * params defines the x/storage parameters to update.
     * NOTE: All parameters must be supplied.
     */
    params?: ParamsAmino;
}
export interface MsgUpdateParamsAminoMsg {
    type: "/greenfield.storage.MsgUpdateParams";
    value: MsgUpdateParamsAmino;
}
/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParamsSDKType {
    authority: string;
    params: ParamsSDKType;
}
/** MsgUpdateParamsResponse defines the response structure for executing a */
export interface MsgUpdateParamsResponse {
}
export interface MsgUpdateParamsResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgUpdateParamsResponse";
    value: Uint8Array;
}
/** MsgUpdateParamsResponse defines the response structure for executing a */
export interface MsgUpdateParamsResponseAmino {
}
export interface MsgUpdateParamsResponseAminoMsg {
    type: "/greenfield.storage.MsgUpdateParamsResponse";
    value: MsgUpdateParamsResponseAmino;
}
/** MsgUpdateParamsResponse defines the response structure for executing a */
export interface MsgUpdateParamsResponseSDKType {
}
export interface MsgMigrateBucket {
    /** operator defines the account address of the operator who initial the migrate bucket */
    operator: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucketName: string;
    /** dst_primary_sp_id defines the destination SP for migration */
    dstPrimarySpId: number;
    /** dst_primary_sp_approval defines the approval of destination sp */
    dstPrimarySpApproval?: Approval;
}
export interface MsgMigrateBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgMigrateBucket";
    value: Uint8Array;
}
export interface MsgMigrateBucketAmino {
    /** operator defines the account address of the operator who initial the migrate bucket */
    operator?: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucket_name?: string;
    /** dst_primary_sp_id defines the destination SP for migration */
    dst_primary_sp_id?: number;
    /** dst_primary_sp_approval defines the approval of destination sp */
    dst_primary_sp_approval?: ApprovalAmino;
}
export interface MsgMigrateBucketAminoMsg {
    type: "/greenfield.storage.MsgMigrateBucket";
    value: MsgMigrateBucketAmino;
}
export interface MsgMigrateBucketSDKType {
    operator: string;
    bucket_name: string;
    dst_primary_sp_id: number;
    dst_primary_sp_approval?: ApprovalSDKType;
}
export interface MsgMigrateBucketResponse {
}
export interface MsgMigrateBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgMigrateBucketResponse";
    value: Uint8Array;
}
export interface MsgMigrateBucketResponseAmino {
}
export interface MsgMigrateBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgMigrateBucketResponse";
    value: MsgMigrateBucketResponseAmino;
}
export interface MsgMigrateBucketResponseSDKType {
}
export interface MsgCompleteMigrateBucket {
    /**
     * operator defines the account address of the msg operator.
     * The CompleteMigrateBucket transaction must be initiated by the destination SP of the migration
     */
    operator: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucketName: string;
    /** global_virtual_group_family_id defines the family id which the bucket migrate to */
    globalVirtualGroupFamilyId: number;
    /** gvg_mappings defines the src and dst gvg mapping relationships which the bucket migrate to */
    gvgMappings: GVGMapping[];
}
export interface MsgCompleteMigrateBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgCompleteMigrateBucket";
    value: Uint8Array;
}
export interface MsgCompleteMigrateBucketAmino {
    /**
     * operator defines the account address of the msg operator.
     * The CompleteMigrateBucket transaction must be initiated by the destination SP of the migration
     */
    operator?: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucket_name?: string;
    /** global_virtual_group_family_id defines the family id which the bucket migrate to */
    global_virtual_group_family_id?: number;
    /** gvg_mappings defines the src and dst gvg mapping relationships which the bucket migrate to */
    gvg_mappings?: GVGMappingAmino[];
}
export interface MsgCompleteMigrateBucketAminoMsg {
    type: "/greenfield.storage.MsgCompleteMigrateBucket";
    value: MsgCompleteMigrateBucketAmino;
}
export interface MsgCompleteMigrateBucketSDKType {
    operator: string;
    bucket_name: string;
    global_virtual_group_family_id: number;
    gvg_mappings: GVGMappingSDKType[];
}
export interface MsgCompleteMigrateBucketResponse {
}
export interface MsgCompleteMigrateBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgCompleteMigrateBucketResponse";
    value: Uint8Array;
}
export interface MsgCompleteMigrateBucketResponseAmino {
}
export interface MsgCompleteMigrateBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgCompleteMigrateBucketResponse";
    value: MsgCompleteMigrateBucketResponseAmino;
}
export interface MsgCompleteMigrateBucketResponseSDKType {
}
export interface MsgCancelMigrateBucket {
    /**
     * operator defines the account address of the msg operator.
     * Only the user can send this transaction to cancel the migrate bucket
     */
    operator: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucketName: string;
}
export interface MsgCancelMigrateBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgCancelMigrateBucket";
    value: Uint8Array;
}
export interface MsgCancelMigrateBucketAmino {
    /**
     * operator defines the account address of the msg operator.
     * Only the user can send this transaction to cancel the migrate bucket
     */
    operator?: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucket_name?: string;
}
export interface MsgCancelMigrateBucketAminoMsg {
    type: "/greenfield.storage.MsgCancelMigrateBucket";
    value: MsgCancelMigrateBucketAmino;
}
export interface MsgCancelMigrateBucketSDKType {
    operator: string;
    bucket_name: string;
}
export interface MsgCancelMigrateBucketResponse {
}
export interface MsgCancelMigrateBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgCancelMigrateBucketResponse";
    value: Uint8Array;
}
export interface MsgCancelMigrateBucketResponseAmino {
}
export interface MsgCancelMigrateBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgCancelMigrateBucketResponse";
    value: MsgCancelMigrateBucketResponseAmino;
}
export interface MsgCancelMigrateBucketResponseSDKType {
}
export interface MsgRejectMigrateBucket {
    /**
     * operator defines the account address of the msg operator.
     * only the Dest SP can send this transaction to reject the bucket migration.
     */
    operator: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucketName: string;
}
export interface MsgRejectMigrateBucketProtoMsg {
    typeUrl: "/greenfield.storage.MsgRejectMigrateBucket";
    value: Uint8Array;
}
export interface MsgRejectMigrateBucketAmino {
    /**
     * operator defines the account address of the msg operator.
     * only the Dest SP can send this transaction to reject the bucket migration.
     */
    operator?: string;
    /** bucket_name defines the name of the bucket that need to be migrated */
    bucket_name?: string;
}
export interface MsgRejectMigrateBucketAminoMsg {
    type: "/greenfield.storage.MsgRejectMigrateBucket";
    value: MsgRejectMigrateBucketAmino;
}
export interface MsgRejectMigrateBucketSDKType {
    operator: string;
    bucket_name: string;
}
export interface MsgRejectMigrateBucketResponse {
}
export interface MsgRejectMigrateBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgRejectMigrateBucketResponse";
    value: Uint8Array;
}
export interface MsgRejectMigrateBucketResponseAmino {
}
export interface MsgRejectMigrateBucketResponseAminoMsg {
    type: "/greenfield.storage.MsgRejectMigrateBucketResponse";
    value: MsgRejectMigrateBucketResponseAmino;
}
export interface MsgRejectMigrateBucketResponseSDKType {
}
export interface MsgSetTag {
    /** operator defines the operator who adds the tags */
    operator: string;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource: string;
    /** tags defines a list of tags which will be set to the resource */
    tags?: ResourceTags;
}
export interface MsgSetTagProtoMsg {
    typeUrl: "/greenfield.storage.MsgSetTag";
    value: Uint8Array;
}
export interface MsgSetTagAmino {
    /** operator defines the operator who adds the tags */
    operator?: string;
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource?: string;
    /** tags defines a list of tags which will be set to the resource */
    tags?: ResourceTagsAmino;
}
export interface MsgSetTagAminoMsg {
    type: "/greenfield.storage.MsgSetTag";
    value: MsgSetTagAmino;
}
export interface MsgSetTagSDKType {
    operator: string;
    resource: string;
    tags?: ResourceTagsSDKType;
}
export interface MsgSetTagResponse {
}
export interface MsgSetTagResponseProtoMsg {
    typeUrl: "/greenfield.storage.MsgSetTagResponse";
    value: Uint8Array;
}
export interface MsgSetTagResponseAmino {
}
export interface MsgSetTagResponseAminoMsg {
    type: "/greenfield.storage.MsgSetTagResponse";
    value: MsgSetTagResponseAmino;
}
export interface MsgSetTagResponseSDKType {
}
export declare const MsgCreateBucket: {
    typeUrl: string;
    encode(message: MsgCreateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBucket;
    fromJSON(object: any): MsgCreateBucket;
    toJSON(message: MsgCreateBucket): unknown;
    fromPartial<I extends {
        creator?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        paymentAddress?: string;
        primarySpAddress?: string;
        primarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        };
        chargedReadQuota?: string | number | Long.Long;
    } & {
        creator?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        paymentAddress?: string;
        primarySpAddress?: string;
        primarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & {
            expiredHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["primarySpApproval"]["expiredHeight"], keyof Long.Long>, never>);
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & Record<Exclude<keyof I["primarySpApproval"], keyof Approval>, never>;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof MsgCreateBucket>, never>>(object: I): MsgCreateBucket;
    fromSDK(object: MsgCreateBucketSDKType): MsgCreateBucket;
    toSDK(message: MsgCreateBucket): MsgCreateBucketSDKType;
    fromAmino(object: MsgCreateBucketAmino): MsgCreateBucket;
    toAmino(message: MsgCreateBucket): MsgCreateBucketAmino;
    fromAminoMsg(object: MsgCreateBucketAminoMsg): MsgCreateBucket;
    fromProtoMsg(message: MsgCreateBucketProtoMsg): MsgCreateBucket;
    toProto(message: MsgCreateBucket): Uint8Array;
    toProtoMsg(message: MsgCreateBucket): MsgCreateBucketProtoMsg;
};
export declare const MsgCreateBucketResponse: {
    typeUrl: string;
    encode(message: MsgCreateBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateBucketResponse;
    fromJSON(object: any): MsgCreateBucketResponse;
    toJSON(message: MsgCreateBucketResponse): unknown;
    fromPartial<I extends {
        bucketId?: string;
    } & {
        bucketId?: string;
    } & Record<Exclude<keyof I, "bucketId">, never>>(object: I): MsgCreateBucketResponse;
    fromSDK(object: MsgCreateBucketResponseSDKType): MsgCreateBucketResponse;
    toSDK(message: MsgCreateBucketResponse): MsgCreateBucketResponseSDKType;
    fromAmino(object: MsgCreateBucketResponseAmino): MsgCreateBucketResponse;
    toAmino(message: MsgCreateBucketResponse): MsgCreateBucketResponseAmino;
    fromAminoMsg(object: MsgCreateBucketResponseAminoMsg): MsgCreateBucketResponse;
    fromProtoMsg(message: MsgCreateBucketResponseProtoMsg): MsgCreateBucketResponse;
    toProto(message: MsgCreateBucketResponse): Uint8Array;
    toProtoMsg(message: MsgCreateBucketResponse): MsgCreateBucketResponseProtoMsg;
};
export declare const MsgDeleteBucket: {
    typeUrl: string;
    encode(message: MsgDeleteBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteBucket;
    fromJSON(object: any): MsgDeleteBucket;
    toJSON(message: MsgDeleteBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
    } & {
        operator?: string;
        bucketName?: string;
    } & Record<Exclude<keyof I, keyof MsgDeleteBucket>, never>>(object: I): MsgDeleteBucket;
    fromSDK(object: MsgDeleteBucketSDKType): MsgDeleteBucket;
    toSDK(message: MsgDeleteBucket): MsgDeleteBucketSDKType;
    fromAmino(object: MsgDeleteBucketAmino): MsgDeleteBucket;
    toAmino(message: MsgDeleteBucket): MsgDeleteBucketAmino;
    fromAminoMsg(object: MsgDeleteBucketAminoMsg): MsgDeleteBucket;
    fromProtoMsg(message: MsgDeleteBucketProtoMsg): MsgDeleteBucket;
    toProto(message: MsgDeleteBucket): Uint8Array;
    toProtoMsg(message: MsgDeleteBucket): MsgDeleteBucketProtoMsg;
};
export declare const MsgDeleteBucketResponse: {
    typeUrl: string;
    encode(_: MsgDeleteBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteBucketResponse;
    fromJSON(_: any): MsgDeleteBucketResponse;
    toJSON(_: MsgDeleteBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDeleteBucketResponse;
    fromSDK(_: MsgDeleteBucketResponseSDKType): MsgDeleteBucketResponse;
    toSDK(_: MsgDeleteBucketResponse): MsgDeleteBucketResponseSDKType;
    fromAmino(_: MsgDeleteBucketResponseAmino): MsgDeleteBucketResponse;
    toAmino(_: MsgDeleteBucketResponse): MsgDeleteBucketResponseAmino;
    fromAminoMsg(object: MsgDeleteBucketResponseAminoMsg): MsgDeleteBucketResponse;
    fromProtoMsg(message: MsgDeleteBucketResponseProtoMsg): MsgDeleteBucketResponse;
    toProto(message: MsgDeleteBucketResponse): Uint8Array;
    toProtoMsg(message: MsgDeleteBucketResponse): MsgDeleteBucketResponseProtoMsg;
};
export declare const MsgDiscontinueBucket: {
    typeUrl: string;
    encode(message: MsgDiscontinueBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueBucket;
    fromJSON(object: any): MsgDiscontinueBucket;
    toJSON(message: MsgDiscontinueBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        reason?: string;
    } & {
        operator?: string;
        bucketName?: string;
        reason?: string;
    } & Record<Exclude<keyof I, keyof MsgDiscontinueBucket>, never>>(object: I): MsgDiscontinueBucket;
    fromSDK(object: MsgDiscontinueBucketSDKType): MsgDiscontinueBucket;
    toSDK(message: MsgDiscontinueBucket): MsgDiscontinueBucketSDKType;
    fromAmino(object: MsgDiscontinueBucketAmino): MsgDiscontinueBucket;
    toAmino(message: MsgDiscontinueBucket): MsgDiscontinueBucketAmino;
    fromAminoMsg(object: MsgDiscontinueBucketAminoMsg): MsgDiscontinueBucket;
    fromProtoMsg(message: MsgDiscontinueBucketProtoMsg): MsgDiscontinueBucket;
    toProto(message: MsgDiscontinueBucket): Uint8Array;
    toProtoMsg(message: MsgDiscontinueBucket): MsgDiscontinueBucketProtoMsg;
};
export declare const MsgDiscontinueBucketResponse: {
    typeUrl: string;
    encode(_: MsgDiscontinueBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueBucketResponse;
    fromJSON(_: any): MsgDiscontinueBucketResponse;
    toJSON(_: MsgDiscontinueBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDiscontinueBucketResponse;
    fromSDK(_: MsgDiscontinueBucketResponseSDKType): MsgDiscontinueBucketResponse;
    toSDK(_: MsgDiscontinueBucketResponse): MsgDiscontinueBucketResponseSDKType;
    fromAmino(_: MsgDiscontinueBucketResponseAmino): MsgDiscontinueBucketResponse;
    toAmino(_: MsgDiscontinueBucketResponse): MsgDiscontinueBucketResponseAmino;
    fromAminoMsg(object: MsgDiscontinueBucketResponseAminoMsg): MsgDiscontinueBucketResponse;
    fromProtoMsg(message: MsgDiscontinueBucketResponseProtoMsg): MsgDiscontinueBucketResponse;
    toProto(message: MsgDiscontinueBucketResponse): Uint8Array;
    toProtoMsg(message: MsgDiscontinueBucketResponse): MsgDiscontinueBucketResponseProtoMsg;
};
export declare const MsgCreateObject: {
    typeUrl: string;
    encode(message: MsgCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateObject;
    fromJSON(object: any): MsgCreateObject;
    toJSON(message: MsgCreateObject): unknown;
    fromPartial<I extends {
        creator?: string;
        bucketName?: string;
        objectName?: string;
        payloadSize?: string | number | Long.Long;
        visibility?: VisibilityType;
        contentType?: string;
        primarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        };
        expectChecksums?: Uint8Array[];
        redundancyType?: RedundancyType;
    } & {
        creator?: string;
        bucketName?: string;
        objectName?: string;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>);
        visibility?: VisibilityType;
        contentType?: string;
        primarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & {
            expiredHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["primarySpApproval"]["expiredHeight"], keyof Long.Long>, never>);
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & Record<Exclude<keyof I["primarySpApproval"], keyof Approval>, never>;
        expectChecksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["expectChecksums"], keyof Uint8Array[]>, never>;
        redundancyType?: RedundancyType;
    } & Record<Exclude<keyof I, keyof MsgCreateObject>, never>>(object: I): MsgCreateObject;
    fromSDK(object: MsgCreateObjectSDKType): MsgCreateObject;
    toSDK(message: MsgCreateObject): MsgCreateObjectSDKType;
    fromAmino(object: MsgCreateObjectAmino): MsgCreateObject;
    toAmino(message: MsgCreateObject): MsgCreateObjectAmino;
    fromAminoMsg(object: MsgCreateObjectAminoMsg): MsgCreateObject;
    fromProtoMsg(message: MsgCreateObjectProtoMsg): MsgCreateObject;
    toProto(message: MsgCreateObject): Uint8Array;
    toProtoMsg(message: MsgCreateObject): MsgCreateObjectProtoMsg;
};
export declare const MsgCreateObjectResponse: {
    typeUrl: string;
    encode(message: MsgCreateObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateObjectResponse;
    fromJSON(object: any): MsgCreateObjectResponse;
    toJSON(message: MsgCreateObjectResponse): unknown;
    fromPartial<I extends {
        objectId?: string;
    } & {
        objectId?: string;
    } & Record<Exclude<keyof I, "objectId">, never>>(object: I): MsgCreateObjectResponse;
    fromSDK(object: MsgCreateObjectResponseSDKType): MsgCreateObjectResponse;
    toSDK(message: MsgCreateObjectResponse): MsgCreateObjectResponseSDKType;
    fromAmino(object: MsgCreateObjectResponseAmino): MsgCreateObjectResponse;
    toAmino(message: MsgCreateObjectResponse): MsgCreateObjectResponseAmino;
    fromAminoMsg(object: MsgCreateObjectResponseAminoMsg): MsgCreateObjectResponse;
    fromProtoMsg(message: MsgCreateObjectResponseProtoMsg): MsgCreateObjectResponse;
    toProto(message: MsgCreateObjectResponse): Uint8Array;
    toProtoMsg(message: MsgCreateObjectResponse): MsgCreateObjectResponseProtoMsg;
};
export declare const MsgSealObject: {
    typeUrl: string;
    encode(message: MsgSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSealObject;
    fromJSON(object: any): MsgSealObject;
    toJSON(message: MsgSealObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        globalVirtualGroupId?: number;
        secondarySpBlsAggSignatures?: Uint8Array;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        globalVirtualGroupId?: number;
        secondarySpBlsAggSignatures?: Uint8Array;
    } & Record<Exclude<keyof I, keyof MsgSealObject>, never>>(object: I): MsgSealObject;
    fromSDK(object: MsgSealObjectSDKType): MsgSealObject;
    toSDK(message: MsgSealObject): MsgSealObjectSDKType;
    fromAmino(object: MsgSealObjectAmino): MsgSealObject;
    toAmino(message: MsgSealObject): MsgSealObjectAmino;
    fromAminoMsg(object: MsgSealObjectAminoMsg): MsgSealObject;
    fromProtoMsg(message: MsgSealObjectProtoMsg): MsgSealObject;
    toProto(message: MsgSealObject): Uint8Array;
    toProtoMsg(message: MsgSealObject): MsgSealObjectProtoMsg;
};
export declare const MsgSealObjectResponse: {
    typeUrl: string;
    encode(_: MsgSealObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSealObjectResponse;
    fromJSON(_: any): MsgSealObjectResponse;
    toJSON(_: MsgSealObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgSealObjectResponse;
    fromSDK(_: MsgSealObjectResponseSDKType): MsgSealObjectResponse;
    toSDK(_: MsgSealObjectResponse): MsgSealObjectResponseSDKType;
    fromAmino(_: MsgSealObjectResponseAmino): MsgSealObjectResponse;
    toAmino(_: MsgSealObjectResponse): MsgSealObjectResponseAmino;
    fromAminoMsg(object: MsgSealObjectResponseAminoMsg): MsgSealObjectResponse;
    fromProtoMsg(message: MsgSealObjectResponseProtoMsg): MsgSealObjectResponse;
    toProto(message: MsgSealObjectResponse): Uint8Array;
    toProtoMsg(message: MsgSealObjectResponse): MsgSealObjectResponseProtoMsg;
};
export declare const MsgRejectSealObject: {
    typeUrl: string;
    encode(message: MsgRejectSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRejectSealObject;
    fromJSON(object: any): MsgRejectSealObject;
    toJSON(message: MsgRejectSealObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
    } & Record<Exclude<keyof I, keyof MsgRejectSealObject>, never>>(object: I): MsgRejectSealObject;
    fromSDK(object: MsgRejectSealObjectSDKType): MsgRejectSealObject;
    toSDK(message: MsgRejectSealObject): MsgRejectSealObjectSDKType;
    fromAmino(object: MsgRejectSealObjectAmino): MsgRejectSealObject;
    toAmino(message: MsgRejectSealObject): MsgRejectSealObjectAmino;
    fromAminoMsg(object: MsgRejectSealObjectAminoMsg): MsgRejectSealObject;
    fromProtoMsg(message: MsgRejectSealObjectProtoMsg): MsgRejectSealObject;
    toProto(message: MsgRejectSealObject): Uint8Array;
    toProtoMsg(message: MsgRejectSealObject): MsgRejectSealObjectProtoMsg;
};
export declare const MsgRejectSealObjectResponse: {
    typeUrl: string;
    encode(_: MsgRejectSealObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRejectSealObjectResponse;
    fromJSON(_: any): MsgRejectSealObjectResponse;
    toJSON(_: MsgRejectSealObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgRejectSealObjectResponse;
    fromSDK(_: MsgRejectSealObjectResponseSDKType): MsgRejectSealObjectResponse;
    toSDK(_: MsgRejectSealObjectResponse): MsgRejectSealObjectResponseSDKType;
    fromAmino(_: MsgRejectSealObjectResponseAmino): MsgRejectSealObjectResponse;
    toAmino(_: MsgRejectSealObjectResponse): MsgRejectSealObjectResponseAmino;
    fromAminoMsg(object: MsgRejectSealObjectResponseAminoMsg): MsgRejectSealObjectResponse;
    fromProtoMsg(message: MsgRejectSealObjectResponseProtoMsg): MsgRejectSealObjectResponse;
    toProto(message: MsgRejectSealObjectResponse): Uint8Array;
    toProtoMsg(message: MsgRejectSealObjectResponse): MsgRejectSealObjectResponseProtoMsg;
};
export declare const MsgCopyObject: {
    typeUrl: string;
    encode(message: MsgCopyObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCopyObject;
    fromJSON(object: any): MsgCopyObject;
    toJSON(message: MsgCopyObject): unknown;
    fromPartial<I extends {
        operator?: string;
        srcBucketName?: string;
        dstBucketName?: string;
        srcObjectName?: string;
        dstObjectName?: string;
        dstPrimarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        };
    } & {
        operator?: string;
        srcBucketName?: string;
        dstBucketName?: string;
        srcObjectName?: string;
        dstObjectName?: string;
        dstPrimarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & {
            expiredHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["dstPrimarySpApproval"]["expiredHeight"], keyof Long.Long>, never>);
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & Record<Exclude<keyof I["dstPrimarySpApproval"], keyof Approval>, never>;
    } & Record<Exclude<keyof I, keyof MsgCopyObject>, never>>(object: I): MsgCopyObject;
    fromSDK(object: MsgCopyObjectSDKType): MsgCopyObject;
    toSDK(message: MsgCopyObject): MsgCopyObjectSDKType;
    fromAmino(object: MsgCopyObjectAmino): MsgCopyObject;
    toAmino(message: MsgCopyObject): MsgCopyObjectAmino;
    fromAminoMsg(object: MsgCopyObjectAminoMsg): MsgCopyObject;
    fromProtoMsg(message: MsgCopyObjectProtoMsg): MsgCopyObject;
    toProto(message: MsgCopyObject): Uint8Array;
    toProtoMsg(message: MsgCopyObject): MsgCopyObjectProtoMsg;
};
export declare const MsgCopyObjectResponse: {
    typeUrl: string;
    encode(message: MsgCopyObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCopyObjectResponse;
    fromJSON(object: any): MsgCopyObjectResponse;
    toJSON(message: MsgCopyObjectResponse): unknown;
    fromPartial<I extends {
        objectId?: string;
    } & {
        objectId?: string;
    } & Record<Exclude<keyof I, "objectId">, never>>(object: I): MsgCopyObjectResponse;
    fromSDK(object: MsgCopyObjectResponseSDKType): MsgCopyObjectResponse;
    toSDK(message: MsgCopyObjectResponse): MsgCopyObjectResponseSDKType;
    fromAmino(object: MsgCopyObjectResponseAmino): MsgCopyObjectResponse;
    toAmino(message: MsgCopyObjectResponse): MsgCopyObjectResponseAmino;
    fromAminoMsg(object: MsgCopyObjectResponseAminoMsg): MsgCopyObjectResponse;
    fromProtoMsg(message: MsgCopyObjectResponseProtoMsg): MsgCopyObjectResponse;
    toProto(message: MsgCopyObjectResponse): Uint8Array;
    toProtoMsg(message: MsgCopyObjectResponse): MsgCopyObjectResponseProtoMsg;
};
export declare const MsgDeleteObject: {
    typeUrl: string;
    encode(message: MsgDeleteObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteObject;
    fromJSON(object: any): MsgDeleteObject;
    toJSON(message: MsgDeleteObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
    } & Record<Exclude<keyof I, keyof MsgDeleteObject>, never>>(object: I): MsgDeleteObject;
    fromSDK(object: MsgDeleteObjectSDKType): MsgDeleteObject;
    toSDK(message: MsgDeleteObject): MsgDeleteObjectSDKType;
    fromAmino(object: MsgDeleteObjectAmino): MsgDeleteObject;
    toAmino(message: MsgDeleteObject): MsgDeleteObjectAmino;
    fromAminoMsg(object: MsgDeleteObjectAminoMsg): MsgDeleteObject;
    fromProtoMsg(message: MsgDeleteObjectProtoMsg): MsgDeleteObject;
    toProto(message: MsgDeleteObject): Uint8Array;
    toProtoMsg(message: MsgDeleteObject): MsgDeleteObjectProtoMsg;
};
export declare const MsgDeleteObjectResponse: {
    typeUrl: string;
    encode(_: MsgDeleteObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteObjectResponse;
    fromJSON(_: any): MsgDeleteObjectResponse;
    toJSON(_: MsgDeleteObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDeleteObjectResponse;
    fromSDK(_: MsgDeleteObjectResponseSDKType): MsgDeleteObjectResponse;
    toSDK(_: MsgDeleteObjectResponse): MsgDeleteObjectResponseSDKType;
    fromAmino(_: MsgDeleteObjectResponseAmino): MsgDeleteObjectResponse;
    toAmino(_: MsgDeleteObjectResponse): MsgDeleteObjectResponseAmino;
    fromAminoMsg(object: MsgDeleteObjectResponseAminoMsg): MsgDeleteObjectResponse;
    fromProtoMsg(message: MsgDeleteObjectResponseProtoMsg): MsgDeleteObjectResponse;
    toProto(message: MsgDeleteObjectResponse): Uint8Array;
    toProtoMsg(message: MsgDeleteObjectResponse): MsgDeleteObjectResponseProtoMsg;
};
export declare const MsgDiscontinueObject: {
    typeUrl: string;
    encode(message: MsgDiscontinueObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueObject;
    fromJSON(object: any): MsgDiscontinueObject;
    toJSON(message: MsgDiscontinueObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectIds?: string[];
        reason?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectIds?: string[] & string[] & Record<Exclude<keyof I["objectIds"], keyof string[]>, never>;
        reason?: string;
    } & Record<Exclude<keyof I, keyof MsgDiscontinueObject>, never>>(object: I): MsgDiscontinueObject;
    fromSDK(object: MsgDiscontinueObjectSDKType): MsgDiscontinueObject;
    toSDK(message: MsgDiscontinueObject): MsgDiscontinueObjectSDKType;
    fromAmino(object: MsgDiscontinueObjectAmino): MsgDiscontinueObject;
    toAmino(message: MsgDiscontinueObject): MsgDiscontinueObjectAmino;
    fromAminoMsg(object: MsgDiscontinueObjectAminoMsg): MsgDiscontinueObject;
    fromProtoMsg(message: MsgDiscontinueObjectProtoMsg): MsgDiscontinueObject;
    toProto(message: MsgDiscontinueObject): Uint8Array;
    toProtoMsg(message: MsgDiscontinueObject): MsgDiscontinueObjectProtoMsg;
};
export declare const MsgDiscontinueObjectResponse: {
    typeUrl: string;
    encode(_: MsgDiscontinueObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDiscontinueObjectResponse;
    fromJSON(_: any): MsgDiscontinueObjectResponse;
    toJSON(_: MsgDiscontinueObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDiscontinueObjectResponse;
    fromSDK(_: MsgDiscontinueObjectResponseSDKType): MsgDiscontinueObjectResponse;
    toSDK(_: MsgDiscontinueObjectResponse): MsgDiscontinueObjectResponseSDKType;
    fromAmino(_: MsgDiscontinueObjectResponseAmino): MsgDiscontinueObjectResponse;
    toAmino(_: MsgDiscontinueObjectResponse): MsgDiscontinueObjectResponseAmino;
    fromAminoMsg(object: MsgDiscontinueObjectResponseAminoMsg): MsgDiscontinueObjectResponse;
    fromProtoMsg(message: MsgDiscontinueObjectResponseProtoMsg): MsgDiscontinueObjectResponse;
    toProto(message: MsgDiscontinueObjectResponse): Uint8Array;
    toProtoMsg(message: MsgDiscontinueObjectResponse): MsgDiscontinueObjectResponseProtoMsg;
};
export declare const MsgCreateGroup: {
    typeUrl: string;
    encode(message: MsgCreateGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateGroup;
    fromJSON(object: any): MsgCreateGroup;
    toJSON(message: MsgCreateGroup): unknown;
    fromPartial<I extends {
        creator?: string;
        groupName?: string;
        extra?: string;
    } & {
        creator?: string;
        groupName?: string;
        extra?: string;
    } & Record<Exclude<keyof I, keyof MsgCreateGroup>, never>>(object: I): MsgCreateGroup;
    fromSDK(object: MsgCreateGroupSDKType): MsgCreateGroup;
    toSDK(message: MsgCreateGroup): MsgCreateGroupSDKType;
    fromAmino(object: MsgCreateGroupAmino): MsgCreateGroup;
    toAmino(message: MsgCreateGroup): MsgCreateGroupAmino;
    fromAminoMsg(object: MsgCreateGroupAminoMsg): MsgCreateGroup;
    fromProtoMsg(message: MsgCreateGroupProtoMsg): MsgCreateGroup;
    toProto(message: MsgCreateGroup): Uint8Array;
    toProtoMsg(message: MsgCreateGroup): MsgCreateGroupProtoMsg;
};
export declare const MsgCreateGroupResponse: {
    typeUrl: string;
    encode(message: MsgCreateGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCreateGroupResponse;
    fromJSON(object: any): MsgCreateGroupResponse;
    toJSON(message: MsgCreateGroupResponse): unknown;
    fromPartial<I extends {
        groupId?: string;
    } & {
        groupId?: string;
    } & Record<Exclude<keyof I, "groupId">, never>>(object: I): MsgCreateGroupResponse;
    fromSDK(object: MsgCreateGroupResponseSDKType): MsgCreateGroupResponse;
    toSDK(message: MsgCreateGroupResponse): MsgCreateGroupResponseSDKType;
    fromAmino(object: MsgCreateGroupResponseAmino): MsgCreateGroupResponse;
    toAmino(message: MsgCreateGroupResponse): MsgCreateGroupResponseAmino;
    fromAminoMsg(object: MsgCreateGroupResponseAminoMsg): MsgCreateGroupResponse;
    fromProtoMsg(message: MsgCreateGroupResponseProtoMsg): MsgCreateGroupResponse;
    toProto(message: MsgCreateGroupResponse): Uint8Array;
    toProtoMsg(message: MsgCreateGroupResponse): MsgCreateGroupResponseProtoMsg;
};
export declare const MsgDeleteGroup: {
    typeUrl: string;
    encode(message: MsgDeleteGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteGroup;
    fromJSON(object: any): MsgDeleteGroup;
    toJSON(message: MsgDeleteGroup): unknown;
    fromPartial<I extends {
        operator?: string;
        groupName?: string;
    } & {
        operator?: string;
        groupName?: string;
    } & Record<Exclude<keyof I, keyof MsgDeleteGroup>, never>>(object: I): MsgDeleteGroup;
    fromSDK(object: MsgDeleteGroupSDKType): MsgDeleteGroup;
    toSDK(message: MsgDeleteGroup): MsgDeleteGroupSDKType;
    fromAmino(object: MsgDeleteGroupAmino): MsgDeleteGroup;
    toAmino(message: MsgDeleteGroup): MsgDeleteGroupAmino;
    fromAminoMsg(object: MsgDeleteGroupAminoMsg): MsgDeleteGroup;
    fromProtoMsg(message: MsgDeleteGroupProtoMsg): MsgDeleteGroup;
    toProto(message: MsgDeleteGroup): Uint8Array;
    toProtoMsg(message: MsgDeleteGroup): MsgDeleteGroupProtoMsg;
};
export declare const MsgDeleteGroupResponse: {
    typeUrl: string;
    encode(_: MsgDeleteGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeleteGroupResponse;
    fromJSON(_: any): MsgDeleteGroupResponse;
    toJSON(_: MsgDeleteGroupResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgDeleteGroupResponse;
    fromSDK(_: MsgDeleteGroupResponseSDKType): MsgDeleteGroupResponse;
    toSDK(_: MsgDeleteGroupResponse): MsgDeleteGroupResponseSDKType;
    fromAmino(_: MsgDeleteGroupResponseAmino): MsgDeleteGroupResponse;
    toAmino(_: MsgDeleteGroupResponse): MsgDeleteGroupResponseAmino;
    fromAminoMsg(object: MsgDeleteGroupResponseAminoMsg): MsgDeleteGroupResponse;
    fromProtoMsg(message: MsgDeleteGroupResponseProtoMsg): MsgDeleteGroupResponse;
    toProto(message: MsgDeleteGroupResponse): Uint8Array;
    toProtoMsg(message: MsgDeleteGroupResponse): MsgDeleteGroupResponseProtoMsg;
};
export declare const MsgUpdateGroupMember: {
    typeUrl: string;
    encode(message: MsgUpdateGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateGroupMember;
    fromJSON(object: any): MsgUpdateGroupMember;
    toJSON(message: MsgUpdateGroupMember): unknown;
    fromPartial<I extends {
        operator?: string;
        groupOwner?: string;
        groupName?: string;
        membersToAdd?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[];
        membersToDelete?: string[];
    } & {
        operator?: string;
        groupOwner?: string;
        groupName?: string;
        membersToAdd?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[] & ({
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["membersToAdd"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["membersToAdd"][number]["expirationTime"], keyof Timestamp>, never>;
        } & Record<Exclude<keyof I["membersToAdd"][number], keyof MsgGroupMember>, never>)[] & Record<Exclude<keyof I["membersToAdd"], keyof {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[]>, never>;
        membersToDelete?: string[] & string[] & Record<Exclude<keyof I["membersToDelete"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, keyof MsgUpdateGroupMember>, never>>(object: I): MsgUpdateGroupMember;
    fromSDK(object: MsgUpdateGroupMemberSDKType): MsgUpdateGroupMember;
    toSDK(message: MsgUpdateGroupMember): MsgUpdateGroupMemberSDKType;
    fromAmino(object: MsgUpdateGroupMemberAmino): MsgUpdateGroupMember;
    toAmino(message: MsgUpdateGroupMember): MsgUpdateGroupMemberAmino;
    fromAminoMsg(object: MsgUpdateGroupMemberAminoMsg): MsgUpdateGroupMember;
    fromProtoMsg(message: MsgUpdateGroupMemberProtoMsg): MsgUpdateGroupMember;
    toProto(message: MsgUpdateGroupMember): Uint8Array;
    toProtoMsg(message: MsgUpdateGroupMember): MsgUpdateGroupMemberProtoMsg;
};
export declare const MsgUpdateGroupMemberResponse: {
    typeUrl: string;
    encode(_: MsgUpdateGroupMemberResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateGroupMemberResponse;
    fromJSON(_: any): MsgUpdateGroupMemberResponse;
    toJSON(_: MsgUpdateGroupMemberResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateGroupMemberResponse;
    fromSDK(_: MsgUpdateGroupMemberResponseSDKType): MsgUpdateGroupMemberResponse;
    toSDK(_: MsgUpdateGroupMemberResponse): MsgUpdateGroupMemberResponseSDKType;
    fromAmino(_: MsgUpdateGroupMemberResponseAmino): MsgUpdateGroupMemberResponse;
    toAmino(_: MsgUpdateGroupMemberResponse): MsgUpdateGroupMemberResponseAmino;
    fromAminoMsg(object: MsgUpdateGroupMemberResponseAminoMsg): MsgUpdateGroupMemberResponse;
    fromProtoMsg(message: MsgUpdateGroupMemberResponseProtoMsg): MsgUpdateGroupMemberResponse;
    toProto(message: MsgUpdateGroupMemberResponse): Uint8Array;
    toProtoMsg(message: MsgUpdateGroupMemberResponse): MsgUpdateGroupMemberResponseProtoMsg;
};
export declare const MsgRenewGroupMember: {
    typeUrl: string;
    encode(message: MsgRenewGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRenewGroupMember;
    fromJSON(object: any): MsgRenewGroupMember;
    toJSON(message: MsgRenewGroupMember): unknown;
    fromPartial<I extends {
        operator?: string;
        groupOwner?: string;
        groupName?: string;
        members?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[];
    } & {
        operator?: string;
        groupOwner?: string;
        groupName?: string;
        members?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[] & ({
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["members"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["members"][number]["expirationTime"], keyof Timestamp>, never>;
        } & Record<Exclude<keyof I["members"][number], keyof MsgGroupMember>, never>)[] & Record<Exclude<keyof I["members"], keyof {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof MsgRenewGroupMember>, never>>(object: I): MsgRenewGroupMember;
    fromSDK(object: MsgRenewGroupMemberSDKType): MsgRenewGroupMember;
    toSDK(message: MsgRenewGroupMember): MsgRenewGroupMemberSDKType;
    fromAmino(object: MsgRenewGroupMemberAmino): MsgRenewGroupMember;
    toAmino(message: MsgRenewGroupMember): MsgRenewGroupMemberAmino;
    fromAminoMsg(object: MsgRenewGroupMemberAminoMsg): MsgRenewGroupMember;
    fromProtoMsg(message: MsgRenewGroupMemberProtoMsg): MsgRenewGroupMember;
    toProto(message: MsgRenewGroupMember): Uint8Array;
    toProtoMsg(message: MsgRenewGroupMember): MsgRenewGroupMemberProtoMsg;
};
export declare const MsgRenewGroupMemberResponse: {
    typeUrl: string;
    encode(_: MsgRenewGroupMemberResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRenewGroupMemberResponse;
    fromJSON(_: any): MsgRenewGroupMemberResponse;
    toJSON(_: MsgRenewGroupMemberResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgRenewGroupMemberResponse;
    fromSDK(_: MsgRenewGroupMemberResponseSDKType): MsgRenewGroupMemberResponse;
    toSDK(_: MsgRenewGroupMemberResponse): MsgRenewGroupMemberResponseSDKType;
    fromAmino(_: MsgRenewGroupMemberResponseAmino): MsgRenewGroupMemberResponse;
    toAmino(_: MsgRenewGroupMemberResponse): MsgRenewGroupMemberResponseAmino;
    fromAminoMsg(object: MsgRenewGroupMemberResponseAminoMsg): MsgRenewGroupMemberResponse;
    fromProtoMsg(message: MsgRenewGroupMemberResponseProtoMsg): MsgRenewGroupMemberResponse;
    toProto(message: MsgRenewGroupMemberResponse): Uint8Array;
    toProtoMsg(message: MsgRenewGroupMemberResponse): MsgRenewGroupMemberResponseProtoMsg;
};
export declare const MsgGroupMember: {
    typeUrl: string;
    encode(message: MsgGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgGroupMember;
    fromJSON(object: any): MsgGroupMember;
    toJSON(message: MsgGroupMember): unknown;
    fromPartial<I extends {
        member?: string;
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        };
    } & {
        member?: string;
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        } & {
            seconds?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["expirationTime"]["seconds"], keyof Long.Long>, never>);
            nanos?: number;
        } & Record<Exclude<keyof I["expirationTime"], keyof Timestamp>, never>;
    } & Record<Exclude<keyof I, keyof MsgGroupMember>, never>>(object: I): MsgGroupMember;
    fromSDK(object: MsgGroupMemberSDKType): MsgGroupMember;
    toSDK(message: MsgGroupMember): MsgGroupMemberSDKType;
    fromAmino(object: MsgGroupMemberAmino): MsgGroupMember;
    toAmino(message: MsgGroupMember): MsgGroupMemberAmino;
    fromAminoMsg(object: MsgGroupMemberAminoMsg): MsgGroupMember;
    fromProtoMsg(message: MsgGroupMemberProtoMsg): MsgGroupMember;
    toProto(message: MsgGroupMember): Uint8Array;
    toProtoMsg(message: MsgGroupMember): MsgGroupMemberProtoMsg;
};
export declare const MsgUpdateGroupExtra: {
    typeUrl: string;
    encode(message: MsgUpdateGroupExtra, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateGroupExtra;
    fromJSON(object: any): MsgUpdateGroupExtra;
    toJSON(message: MsgUpdateGroupExtra): unknown;
    fromPartial<I extends {
        operator?: string;
        groupOwner?: string;
        groupName?: string;
        extra?: string;
    } & {
        operator?: string;
        groupOwner?: string;
        groupName?: string;
        extra?: string;
    } & Record<Exclude<keyof I, keyof MsgUpdateGroupExtra>, never>>(object: I): MsgUpdateGroupExtra;
    fromSDK(object: MsgUpdateGroupExtraSDKType): MsgUpdateGroupExtra;
    toSDK(message: MsgUpdateGroupExtra): MsgUpdateGroupExtraSDKType;
    fromAmino(object: MsgUpdateGroupExtraAmino): MsgUpdateGroupExtra;
    toAmino(message: MsgUpdateGroupExtra): MsgUpdateGroupExtraAmino;
    fromAminoMsg(object: MsgUpdateGroupExtraAminoMsg): MsgUpdateGroupExtra;
    fromProtoMsg(message: MsgUpdateGroupExtraProtoMsg): MsgUpdateGroupExtra;
    toProto(message: MsgUpdateGroupExtra): Uint8Array;
    toProtoMsg(message: MsgUpdateGroupExtra): MsgUpdateGroupExtraProtoMsg;
};
export declare const MsgUpdateGroupExtraResponse: {
    typeUrl: string;
    encode(_: MsgUpdateGroupExtraResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateGroupExtraResponse;
    fromJSON(_: any): MsgUpdateGroupExtraResponse;
    toJSON(_: MsgUpdateGroupExtraResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateGroupExtraResponse;
    fromSDK(_: MsgUpdateGroupExtraResponseSDKType): MsgUpdateGroupExtraResponse;
    toSDK(_: MsgUpdateGroupExtraResponse): MsgUpdateGroupExtraResponseSDKType;
    fromAmino(_: MsgUpdateGroupExtraResponseAmino): MsgUpdateGroupExtraResponse;
    toAmino(_: MsgUpdateGroupExtraResponse): MsgUpdateGroupExtraResponseAmino;
    fromAminoMsg(object: MsgUpdateGroupExtraResponseAminoMsg): MsgUpdateGroupExtraResponse;
    fromProtoMsg(message: MsgUpdateGroupExtraResponseProtoMsg): MsgUpdateGroupExtraResponse;
    toProto(message: MsgUpdateGroupExtraResponse): Uint8Array;
    toProtoMsg(message: MsgUpdateGroupExtraResponse): MsgUpdateGroupExtraResponseProtoMsg;
};
export declare const MsgLeaveGroup: {
    typeUrl: string;
    encode(message: MsgLeaveGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgLeaveGroup;
    fromJSON(object: any): MsgLeaveGroup;
    toJSON(message: MsgLeaveGroup): unknown;
    fromPartial<I extends {
        member?: string;
        groupOwner?: string;
        groupName?: string;
    } & {
        member?: string;
        groupOwner?: string;
        groupName?: string;
    } & Record<Exclude<keyof I, keyof MsgLeaveGroup>, never>>(object: I): MsgLeaveGroup;
    fromSDK(object: MsgLeaveGroupSDKType): MsgLeaveGroup;
    toSDK(message: MsgLeaveGroup): MsgLeaveGroupSDKType;
    fromAmino(object: MsgLeaveGroupAmino): MsgLeaveGroup;
    toAmino(message: MsgLeaveGroup): MsgLeaveGroupAmino;
    fromAminoMsg(object: MsgLeaveGroupAminoMsg): MsgLeaveGroup;
    fromProtoMsg(message: MsgLeaveGroupProtoMsg): MsgLeaveGroup;
    toProto(message: MsgLeaveGroup): Uint8Array;
    toProtoMsg(message: MsgLeaveGroup): MsgLeaveGroupProtoMsg;
};
export declare const MsgLeaveGroupResponse: {
    typeUrl: string;
    encode(_: MsgLeaveGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgLeaveGroupResponse;
    fromJSON(_: any): MsgLeaveGroupResponse;
    toJSON(_: MsgLeaveGroupResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgLeaveGroupResponse;
    fromSDK(_: MsgLeaveGroupResponseSDKType): MsgLeaveGroupResponse;
    toSDK(_: MsgLeaveGroupResponse): MsgLeaveGroupResponseSDKType;
    fromAmino(_: MsgLeaveGroupResponseAmino): MsgLeaveGroupResponse;
    toAmino(_: MsgLeaveGroupResponse): MsgLeaveGroupResponseAmino;
    fromAminoMsg(object: MsgLeaveGroupResponseAminoMsg): MsgLeaveGroupResponse;
    fromProtoMsg(message: MsgLeaveGroupResponseProtoMsg): MsgLeaveGroupResponse;
    toProto(message: MsgLeaveGroupResponse): Uint8Array;
    toProtoMsg(message: MsgLeaveGroupResponse): MsgLeaveGroupResponseProtoMsg;
};
export declare const MsgUpdateBucketInfo: {
    typeUrl: string;
    encode(message: MsgUpdateBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateBucketInfo;
    fromJSON(object: any): MsgUpdateBucketInfo;
    toJSON(message: MsgUpdateBucketInfo): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        chargedReadQuota?: {
            value?: string | number | Long.Long;
        };
        paymentAddress?: string;
        visibility?: VisibilityType;
    } & {
        operator?: string;
        bucketName?: string;
        chargedReadQuota?: {
            value?: string | number | Long.Long;
        } & {
            value?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["chargedReadQuota"]["value"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["chargedReadQuota"], "value">, never>;
        paymentAddress?: string;
        visibility?: VisibilityType;
    } & Record<Exclude<keyof I, keyof MsgUpdateBucketInfo>, never>>(object: I): MsgUpdateBucketInfo;
    fromSDK(object: MsgUpdateBucketInfoSDKType): MsgUpdateBucketInfo;
    toSDK(message: MsgUpdateBucketInfo): MsgUpdateBucketInfoSDKType;
    fromAmino(object: MsgUpdateBucketInfoAmino): MsgUpdateBucketInfo;
    toAmino(message: MsgUpdateBucketInfo): MsgUpdateBucketInfoAmino;
    fromAminoMsg(object: MsgUpdateBucketInfoAminoMsg): MsgUpdateBucketInfo;
    fromProtoMsg(message: MsgUpdateBucketInfoProtoMsg): MsgUpdateBucketInfo;
    toProto(message: MsgUpdateBucketInfo): Uint8Array;
    toProtoMsg(message: MsgUpdateBucketInfo): MsgUpdateBucketInfoProtoMsg;
};
export declare const MsgUpdateBucketInfoResponse: {
    typeUrl: string;
    encode(_: MsgUpdateBucketInfoResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateBucketInfoResponse;
    fromJSON(_: any): MsgUpdateBucketInfoResponse;
    toJSON(_: MsgUpdateBucketInfoResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateBucketInfoResponse;
    fromSDK(_: MsgUpdateBucketInfoResponseSDKType): MsgUpdateBucketInfoResponse;
    toSDK(_: MsgUpdateBucketInfoResponse): MsgUpdateBucketInfoResponseSDKType;
    fromAmino(_: MsgUpdateBucketInfoResponseAmino): MsgUpdateBucketInfoResponse;
    toAmino(_: MsgUpdateBucketInfoResponse): MsgUpdateBucketInfoResponseAmino;
    fromAminoMsg(object: MsgUpdateBucketInfoResponseAminoMsg): MsgUpdateBucketInfoResponse;
    fromProtoMsg(message: MsgUpdateBucketInfoResponseProtoMsg): MsgUpdateBucketInfoResponse;
    toProto(message: MsgUpdateBucketInfoResponse): Uint8Array;
    toProtoMsg(message: MsgUpdateBucketInfoResponse): MsgUpdateBucketInfoResponseProtoMsg;
};
export declare const MsgCancelCreateObject: {
    typeUrl: string;
    encode(message: MsgCancelCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelCreateObject;
    fromJSON(object: any): MsgCancelCreateObject;
    toJSON(message: MsgCancelCreateObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
    } & Record<Exclude<keyof I, keyof MsgCancelCreateObject>, never>>(object: I): MsgCancelCreateObject;
    fromSDK(object: MsgCancelCreateObjectSDKType): MsgCancelCreateObject;
    toSDK(message: MsgCancelCreateObject): MsgCancelCreateObjectSDKType;
    fromAmino(object: MsgCancelCreateObjectAmino): MsgCancelCreateObject;
    toAmino(message: MsgCancelCreateObject): MsgCancelCreateObjectAmino;
    fromAminoMsg(object: MsgCancelCreateObjectAminoMsg): MsgCancelCreateObject;
    fromProtoMsg(message: MsgCancelCreateObjectProtoMsg): MsgCancelCreateObject;
    toProto(message: MsgCancelCreateObject): Uint8Array;
    toProtoMsg(message: MsgCancelCreateObject): MsgCancelCreateObjectProtoMsg;
};
export declare const MsgCancelCreateObjectResponse: {
    typeUrl: string;
    encode(_: MsgCancelCreateObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelCreateObjectResponse;
    fromJSON(_: any): MsgCancelCreateObjectResponse;
    toJSON(_: MsgCancelCreateObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCancelCreateObjectResponse;
    fromSDK(_: MsgCancelCreateObjectResponseSDKType): MsgCancelCreateObjectResponse;
    toSDK(_: MsgCancelCreateObjectResponse): MsgCancelCreateObjectResponseSDKType;
    fromAmino(_: MsgCancelCreateObjectResponseAmino): MsgCancelCreateObjectResponse;
    toAmino(_: MsgCancelCreateObjectResponse): MsgCancelCreateObjectResponseAmino;
    fromAminoMsg(object: MsgCancelCreateObjectResponseAminoMsg): MsgCancelCreateObjectResponse;
    fromProtoMsg(message: MsgCancelCreateObjectResponseProtoMsg): MsgCancelCreateObjectResponse;
    toProto(message: MsgCancelCreateObjectResponse): Uint8Array;
    toProtoMsg(message: MsgCancelCreateObjectResponse): MsgCancelCreateObjectResponseProtoMsg;
};
export declare const MsgPutPolicy: {
    typeUrl: string;
    encode(message: MsgPutPolicy, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgPutPolicy;
    fromJSON(object: any): MsgPutPolicy;
    toJSON(message: MsgPutPolicy): unknown;
    fromPartial<I extends {
        operator?: string;
        principal?: {
            type?: import("../permission/common").PrincipalType;
            value?: string;
        };
        resource?: string;
        statements?: {
            effect?: import("../permission/common").Effect;
            actions?: import("../permission/common").ActionType[];
            resources?: string[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
            limitSize?: {
                value?: string | number | Long.Long;
            };
        }[];
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        };
    } & {
        operator?: string;
        principal?: {
            type?: import("../permission/common").PrincipalType;
            value?: string;
        } & {
            type?: import("../permission/common").PrincipalType;
            value?: string;
        } & Record<Exclude<keyof I["principal"], keyof Principal>, never>;
        resource?: string;
        statements?: {
            effect?: import("../permission/common").Effect;
            actions?: import("../permission/common").ActionType[];
            resources?: string[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
            limitSize?: {
                value?: string | number | Long.Long;
            };
        }[] & ({
            effect?: import("../permission/common").Effect;
            actions?: import("../permission/common").ActionType[];
            resources?: string[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
            limitSize?: {
                value?: string | number | Long.Long;
            };
        } & {
            effect?: import("../permission/common").Effect;
            actions?: import("../permission/common").ActionType[] & import("../permission/common").ActionType[] & Record<Exclude<keyof I["statements"][number]["actions"], keyof import("../permission/common").ActionType[]>, never>;
            resources?: string[] & string[] & Record<Exclude<keyof I["statements"][number]["resources"], keyof string[]>, never>;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["statements"][number]["expirationTime"], keyof Timestamp>, never>;
            limitSize?: {
                value?: string | number | Long.Long;
            } & {
                value?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["statements"][number]["limitSize"], "value">, never>;
        } & Record<Exclude<keyof I["statements"][number], keyof Statement>, never>)[] & Record<Exclude<keyof I["statements"], keyof {
            effect?: import("../permission/common").Effect;
            actions?: import("../permission/common").ActionType[];
            resources?: string[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
            limitSize?: {
                value?: string | number | Long.Long;
            };
        }[]>, never>;
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        } & {
            seconds?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["expirationTime"]["seconds"], keyof Long.Long>, never>);
            nanos?: number;
        } & Record<Exclude<keyof I["expirationTime"], keyof Timestamp>, never>;
    } & Record<Exclude<keyof I, keyof MsgPutPolicy>, never>>(object: I): MsgPutPolicy;
    fromSDK(object: MsgPutPolicySDKType): MsgPutPolicy;
    toSDK(message: MsgPutPolicy): MsgPutPolicySDKType;
    fromAmino(object: MsgPutPolicyAmino): MsgPutPolicy;
    toAmino(message: MsgPutPolicy): MsgPutPolicyAmino;
    fromAminoMsg(object: MsgPutPolicyAminoMsg): MsgPutPolicy;
    fromProtoMsg(message: MsgPutPolicyProtoMsg): MsgPutPolicy;
    toProto(message: MsgPutPolicy): Uint8Array;
    toProtoMsg(message: MsgPutPolicy): MsgPutPolicyProtoMsg;
};
export declare const MsgPutPolicyResponse: {
    typeUrl: string;
    encode(message: MsgPutPolicyResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgPutPolicyResponse;
    fromJSON(object: any): MsgPutPolicyResponse;
    toJSON(message: MsgPutPolicyResponse): unknown;
    fromPartial<I extends {
        policyId?: string;
    } & {
        policyId?: string;
    } & Record<Exclude<keyof I, "policyId">, never>>(object: I): MsgPutPolicyResponse;
    fromSDK(object: MsgPutPolicyResponseSDKType): MsgPutPolicyResponse;
    toSDK(message: MsgPutPolicyResponse): MsgPutPolicyResponseSDKType;
    fromAmino(object: MsgPutPolicyResponseAmino): MsgPutPolicyResponse;
    toAmino(message: MsgPutPolicyResponse): MsgPutPolicyResponseAmino;
    fromAminoMsg(object: MsgPutPolicyResponseAminoMsg): MsgPutPolicyResponse;
    fromProtoMsg(message: MsgPutPolicyResponseProtoMsg): MsgPutPolicyResponse;
    toProto(message: MsgPutPolicyResponse): Uint8Array;
    toProtoMsg(message: MsgPutPolicyResponse): MsgPutPolicyResponseProtoMsg;
};
export declare const MsgDeletePolicy: {
    typeUrl: string;
    encode(message: MsgDeletePolicy, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeletePolicy;
    fromJSON(object: any): MsgDeletePolicy;
    toJSON(message: MsgDeletePolicy): unknown;
    fromPartial<I extends {
        operator?: string;
        principal?: {
            type?: import("../permission/common").PrincipalType;
            value?: string;
        };
        resource?: string;
    } & {
        operator?: string;
        principal?: {
            type?: import("../permission/common").PrincipalType;
            value?: string;
        } & {
            type?: import("../permission/common").PrincipalType;
            value?: string;
        } & Record<Exclude<keyof I["principal"], keyof Principal>, never>;
        resource?: string;
    } & Record<Exclude<keyof I, keyof MsgDeletePolicy>, never>>(object: I): MsgDeletePolicy;
    fromSDK(object: MsgDeletePolicySDKType): MsgDeletePolicy;
    toSDK(message: MsgDeletePolicy): MsgDeletePolicySDKType;
    fromAmino(object: MsgDeletePolicyAmino): MsgDeletePolicy;
    toAmino(message: MsgDeletePolicy): MsgDeletePolicyAmino;
    fromAminoMsg(object: MsgDeletePolicyAminoMsg): MsgDeletePolicy;
    fromProtoMsg(message: MsgDeletePolicyProtoMsg): MsgDeletePolicy;
    toProto(message: MsgDeletePolicy): Uint8Array;
    toProtoMsg(message: MsgDeletePolicy): MsgDeletePolicyProtoMsg;
};
export declare const MsgDeletePolicyResponse: {
    typeUrl: string;
    encode(message: MsgDeletePolicyResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgDeletePolicyResponse;
    fromJSON(object: any): MsgDeletePolicyResponse;
    toJSON(message: MsgDeletePolicyResponse): unknown;
    fromPartial<I extends {
        policyId?: string;
    } & {
        policyId?: string;
    } & Record<Exclude<keyof I, "policyId">, never>>(object: I): MsgDeletePolicyResponse;
    fromSDK(object: MsgDeletePolicyResponseSDKType): MsgDeletePolicyResponse;
    toSDK(message: MsgDeletePolicyResponse): MsgDeletePolicyResponseSDKType;
    fromAmino(object: MsgDeletePolicyResponseAmino): MsgDeletePolicyResponse;
    toAmino(message: MsgDeletePolicyResponse): MsgDeletePolicyResponseAmino;
    fromAminoMsg(object: MsgDeletePolicyResponseAminoMsg): MsgDeletePolicyResponse;
    fromProtoMsg(message: MsgDeletePolicyResponseProtoMsg): MsgDeletePolicyResponse;
    toProto(message: MsgDeletePolicyResponse): Uint8Array;
    toProtoMsg(message: MsgDeletePolicyResponse): MsgDeletePolicyResponseProtoMsg;
};
export declare const MsgMirrorObject: {
    typeUrl: string;
    encode(message: MsgMirrorObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorObject;
    fromJSON(object: any): MsgMirrorObject;
    toJSON(message: MsgMirrorObject): unknown;
    fromPartial<I extends {
        operator?: string;
        id?: string;
        bucketName?: string;
        objectName?: string;
        destChainId?: number;
    } & {
        operator?: string;
        id?: string;
        bucketName?: string;
        objectName?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof MsgMirrorObject>, never>>(object: I): MsgMirrorObject;
    fromSDK(object: MsgMirrorObjectSDKType): MsgMirrorObject;
    toSDK(message: MsgMirrorObject): MsgMirrorObjectSDKType;
    fromAmino(object: MsgMirrorObjectAmino): MsgMirrorObject;
    toAmino(message: MsgMirrorObject): MsgMirrorObjectAmino;
    fromAminoMsg(object: MsgMirrorObjectAminoMsg): MsgMirrorObject;
    fromProtoMsg(message: MsgMirrorObjectProtoMsg): MsgMirrorObject;
    toProto(message: MsgMirrorObject): Uint8Array;
    toProtoMsg(message: MsgMirrorObject): MsgMirrorObjectProtoMsg;
};
export declare const MsgMirrorObjectResponse: {
    typeUrl: string;
    encode(_: MsgMirrorObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorObjectResponse;
    fromJSON(_: any): MsgMirrorObjectResponse;
    toJSON(_: MsgMirrorObjectResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgMirrorObjectResponse;
    fromSDK(_: MsgMirrorObjectResponseSDKType): MsgMirrorObjectResponse;
    toSDK(_: MsgMirrorObjectResponse): MsgMirrorObjectResponseSDKType;
    fromAmino(_: MsgMirrorObjectResponseAmino): MsgMirrorObjectResponse;
    toAmino(_: MsgMirrorObjectResponse): MsgMirrorObjectResponseAmino;
    fromAminoMsg(object: MsgMirrorObjectResponseAminoMsg): MsgMirrorObjectResponse;
    fromProtoMsg(message: MsgMirrorObjectResponseProtoMsg): MsgMirrorObjectResponse;
    toProto(message: MsgMirrorObjectResponse): Uint8Array;
    toProtoMsg(message: MsgMirrorObjectResponse): MsgMirrorObjectResponseProtoMsg;
};
export declare const MsgMirrorBucket: {
    typeUrl: string;
    encode(message: MsgMirrorBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorBucket;
    fromJSON(object: any): MsgMirrorBucket;
    toJSON(message: MsgMirrorBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        id?: string;
        bucketName?: string;
        destChainId?: number;
    } & {
        operator?: string;
        id?: string;
        bucketName?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof MsgMirrorBucket>, never>>(object: I): MsgMirrorBucket;
    fromSDK(object: MsgMirrorBucketSDKType): MsgMirrorBucket;
    toSDK(message: MsgMirrorBucket): MsgMirrorBucketSDKType;
    fromAmino(object: MsgMirrorBucketAmino): MsgMirrorBucket;
    toAmino(message: MsgMirrorBucket): MsgMirrorBucketAmino;
    fromAminoMsg(object: MsgMirrorBucketAminoMsg): MsgMirrorBucket;
    fromProtoMsg(message: MsgMirrorBucketProtoMsg): MsgMirrorBucket;
    toProto(message: MsgMirrorBucket): Uint8Array;
    toProtoMsg(message: MsgMirrorBucket): MsgMirrorBucketProtoMsg;
};
export declare const MsgUpdateObjectInfoResponse: {
    typeUrl: string;
    encode(_: MsgUpdateObjectInfoResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateObjectInfoResponse;
    fromJSON(_: any): MsgUpdateObjectInfoResponse;
    toJSON(_: MsgUpdateObjectInfoResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateObjectInfoResponse;
    fromSDK(_: MsgUpdateObjectInfoResponseSDKType): MsgUpdateObjectInfoResponse;
    toSDK(_: MsgUpdateObjectInfoResponse): MsgUpdateObjectInfoResponseSDKType;
    fromAmino(_: MsgUpdateObjectInfoResponseAmino): MsgUpdateObjectInfoResponse;
    toAmino(_: MsgUpdateObjectInfoResponse): MsgUpdateObjectInfoResponseAmino;
    fromAminoMsg(object: MsgUpdateObjectInfoResponseAminoMsg): MsgUpdateObjectInfoResponse;
    fromProtoMsg(message: MsgUpdateObjectInfoResponseProtoMsg): MsgUpdateObjectInfoResponse;
    toProto(message: MsgUpdateObjectInfoResponse): Uint8Array;
    toProtoMsg(message: MsgUpdateObjectInfoResponse): MsgUpdateObjectInfoResponseProtoMsg;
};
export declare const MsgUpdateObjectInfo: {
    typeUrl: string;
    encode(message: MsgUpdateObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateObjectInfo;
    fromJSON(object: any): MsgUpdateObjectInfo;
    toJSON(message: MsgUpdateObjectInfo): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        visibility?: VisibilityType;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        visibility?: VisibilityType;
    } & Record<Exclude<keyof I, keyof MsgUpdateObjectInfo>, never>>(object: I): MsgUpdateObjectInfo;
    fromSDK(object: MsgUpdateObjectInfoSDKType): MsgUpdateObjectInfo;
    toSDK(message: MsgUpdateObjectInfo): MsgUpdateObjectInfoSDKType;
    fromAmino(object: MsgUpdateObjectInfoAmino): MsgUpdateObjectInfo;
    toAmino(message: MsgUpdateObjectInfo): MsgUpdateObjectInfoAmino;
    fromAminoMsg(object: MsgUpdateObjectInfoAminoMsg): MsgUpdateObjectInfo;
    fromProtoMsg(message: MsgUpdateObjectInfoProtoMsg): MsgUpdateObjectInfo;
    toProto(message: MsgUpdateObjectInfo): Uint8Array;
    toProtoMsg(message: MsgUpdateObjectInfo): MsgUpdateObjectInfoProtoMsg;
};
export declare const MsgMirrorBucketResponse: {
    typeUrl: string;
    encode(_: MsgMirrorBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorBucketResponse;
    fromJSON(_: any): MsgMirrorBucketResponse;
    toJSON(_: MsgMirrorBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgMirrorBucketResponse;
    fromSDK(_: MsgMirrorBucketResponseSDKType): MsgMirrorBucketResponse;
    toSDK(_: MsgMirrorBucketResponse): MsgMirrorBucketResponseSDKType;
    fromAmino(_: MsgMirrorBucketResponseAmino): MsgMirrorBucketResponse;
    toAmino(_: MsgMirrorBucketResponse): MsgMirrorBucketResponseAmino;
    fromAminoMsg(object: MsgMirrorBucketResponseAminoMsg): MsgMirrorBucketResponse;
    fromProtoMsg(message: MsgMirrorBucketResponseProtoMsg): MsgMirrorBucketResponse;
    toProto(message: MsgMirrorBucketResponse): Uint8Array;
    toProtoMsg(message: MsgMirrorBucketResponse): MsgMirrorBucketResponseProtoMsg;
};
export declare const MsgMirrorGroup: {
    typeUrl: string;
    encode(message: MsgMirrorGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorGroup;
    fromJSON(object: any): MsgMirrorGroup;
    toJSON(message: MsgMirrorGroup): unknown;
    fromPartial<I extends {
        operator?: string;
        id?: string;
        groupName?: string;
        destChainId?: number;
    } & {
        operator?: string;
        id?: string;
        groupName?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof MsgMirrorGroup>, never>>(object: I): MsgMirrorGroup;
    fromSDK(object: MsgMirrorGroupSDKType): MsgMirrorGroup;
    toSDK(message: MsgMirrorGroup): MsgMirrorGroupSDKType;
    fromAmino(object: MsgMirrorGroupAmino): MsgMirrorGroup;
    toAmino(message: MsgMirrorGroup): MsgMirrorGroupAmino;
    fromAminoMsg(object: MsgMirrorGroupAminoMsg): MsgMirrorGroup;
    fromProtoMsg(message: MsgMirrorGroupProtoMsg): MsgMirrorGroup;
    toProto(message: MsgMirrorGroup): Uint8Array;
    toProtoMsg(message: MsgMirrorGroup): MsgMirrorGroupProtoMsg;
};
export declare const MsgMirrorGroupResponse: {
    typeUrl: string;
    encode(_: MsgMirrorGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMirrorGroupResponse;
    fromJSON(_: any): MsgMirrorGroupResponse;
    toJSON(_: MsgMirrorGroupResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgMirrorGroupResponse;
    fromSDK(_: MsgMirrorGroupResponseSDKType): MsgMirrorGroupResponse;
    toSDK(_: MsgMirrorGroupResponse): MsgMirrorGroupResponseSDKType;
    fromAmino(_: MsgMirrorGroupResponseAmino): MsgMirrorGroupResponse;
    toAmino(_: MsgMirrorGroupResponse): MsgMirrorGroupResponseAmino;
    fromAminoMsg(object: MsgMirrorGroupResponseAminoMsg): MsgMirrorGroupResponse;
    fromProtoMsg(message: MsgMirrorGroupResponseProtoMsg): MsgMirrorGroupResponse;
    toProto(message: MsgMirrorGroupResponse): Uint8Array;
    toProtoMsg(message: MsgMirrorGroupResponse): MsgMirrorGroupResponseProtoMsg;
};
export declare const MsgUpdateParams: {
    typeUrl: string;
    encode(message: MsgUpdateParams, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParams;
    fromJSON(object: any): MsgUpdateParams;
    toJSON(message: MsgUpdateParams): unknown;
    fromPartial<I extends {
        authority?: string;
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        };
    } & {
        authority?: string;
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            } & {
                maxSegmentSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["maxSegmentSize"], keyof Long.Long>, never>);
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["minChargeSize"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>;
            maxPayloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxPayloadSize"], keyof Long.Long>, never>);
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueCountingWindow"], keyof Long.Long>, never>);
            discontinueObjectMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueObjectMax"], keyof Long.Long>, never>);
            discontinueBucketMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueBucketMax"], keyof Long.Long>, never>);
            discontinueConfirmPeriod?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueConfirmPeriod"], keyof Long.Long>, never>);
            discontinueDeletionMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueDeletionMax"], keyof Long.Long>, never>);
            stalePolicyCleanupMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["stalePolicyCleanupMax"], keyof Long.Long>, never>);
            minQuotaUpdateInterval?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["minQuotaUpdateInterval"], keyof Long.Long>, never>);
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, keyof MsgUpdateParams>, never>>(object: I): MsgUpdateParams;
    fromSDK(object: MsgUpdateParamsSDKType): MsgUpdateParams;
    toSDK(message: MsgUpdateParams): MsgUpdateParamsSDKType;
    fromAmino(object: MsgUpdateParamsAmino): MsgUpdateParams;
    toAmino(message: MsgUpdateParams): MsgUpdateParamsAmino;
    fromAminoMsg(object: MsgUpdateParamsAminoMsg): MsgUpdateParams;
    fromProtoMsg(message: MsgUpdateParamsProtoMsg): MsgUpdateParams;
    toProto(message: MsgUpdateParams): Uint8Array;
    toProtoMsg(message: MsgUpdateParams): MsgUpdateParamsProtoMsg;
};
export declare const MsgUpdateParamsResponse: {
    typeUrl: string;
    encode(_: MsgUpdateParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgUpdateParamsResponse;
    fromJSON(_: any): MsgUpdateParamsResponse;
    toJSON(_: MsgUpdateParamsResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgUpdateParamsResponse;
    fromSDK(_: MsgUpdateParamsResponseSDKType): MsgUpdateParamsResponse;
    toSDK(_: MsgUpdateParamsResponse): MsgUpdateParamsResponseSDKType;
    fromAmino(_: MsgUpdateParamsResponseAmino): MsgUpdateParamsResponse;
    toAmino(_: MsgUpdateParamsResponse): MsgUpdateParamsResponseAmino;
    fromAminoMsg(object: MsgUpdateParamsResponseAminoMsg): MsgUpdateParamsResponse;
    fromProtoMsg(message: MsgUpdateParamsResponseProtoMsg): MsgUpdateParamsResponse;
    toProto(message: MsgUpdateParamsResponse): Uint8Array;
    toProtoMsg(message: MsgUpdateParamsResponse): MsgUpdateParamsResponseProtoMsg;
};
export declare const MsgMigrateBucket: {
    typeUrl: string;
    encode(message: MsgMigrateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMigrateBucket;
    fromJSON(object: any): MsgMigrateBucket;
    toJSON(message: MsgMigrateBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        dstPrimarySpId?: number;
        dstPrimarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        };
    } & {
        operator?: string;
        bucketName?: string;
        dstPrimarySpId?: number;
        dstPrimarySpApproval?: {
            expiredHeight?: string | number | Long.Long;
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & {
            expiredHeight?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["dstPrimarySpApproval"]["expiredHeight"], keyof Long.Long>, never>);
            globalVirtualGroupFamilyId?: number;
            sig?: Uint8Array;
        } & Record<Exclude<keyof I["dstPrimarySpApproval"], keyof Approval>, never>;
    } & Record<Exclude<keyof I, keyof MsgMigrateBucket>, never>>(object: I): MsgMigrateBucket;
    fromSDK(object: MsgMigrateBucketSDKType): MsgMigrateBucket;
    toSDK(message: MsgMigrateBucket): MsgMigrateBucketSDKType;
    fromAmino(object: MsgMigrateBucketAmino): MsgMigrateBucket;
    toAmino(message: MsgMigrateBucket): MsgMigrateBucketAmino;
    fromAminoMsg(object: MsgMigrateBucketAminoMsg): MsgMigrateBucket;
    fromProtoMsg(message: MsgMigrateBucketProtoMsg): MsgMigrateBucket;
    toProto(message: MsgMigrateBucket): Uint8Array;
    toProtoMsg(message: MsgMigrateBucket): MsgMigrateBucketProtoMsg;
};
export declare const MsgMigrateBucketResponse: {
    typeUrl: string;
    encode(_: MsgMigrateBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgMigrateBucketResponse;
    fromJSON(_: any): MsgMigrateBucketResponse;
    toJSON(_: MsgMigrateBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgMigrateBucketResponse;
    fromSDK(_: MsgMigrateBucketResponseSDKType): MsgMigrateBucketResponse;
    toSDK(_: MsgMigrateBucketResponse): MsgMigrateBucketResponseSDKType;
    fromAmino(_: MsgMigrateBucketResponseAmino): MsgMigrateBucketResponse;
    toAmino(_: MsgMigrateBucketResponse): MsgMigrateBucketResponseAmino;
    fromAminoMsg(object: MsgMigrateBucketResponseAminoMsg): MsgMigrateBucketResponse;
    fromProtoMsg(message: MsgMigrateBucketResponseProtoMsg): MsgMigrateBucketResponse;
    toProto(message: MsgMigrateBucketResponse): Uint8Array;
    toProtoMsg(message: MsgMigrateBucketResponse): MsgMigrateBucketResponseProtoMsg;
};
export declare const MsgCompleteMigrateBucket: {
    typeUrl: string;
    encode(message: MsgCompleteMigrateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCompleteMigrateBucket;
    fromJSON(object: any): MsgCompleteMigrateBucket;
    toJSON(message: MsgCompleteMigrateBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        globalVirtualGroupFamilyId?: number;
        gvgMappings?: {
            srcGlobalVirtualGroupId?: number;
            dstGlobalVirtualGroupId?: number;
            secondarySpBlsSignature?: Uint8Array;
        }[];
    } & {
        operator?: string;
        bucketName?: string;
        globalVirtualGroupFamilyId?: number;
        gvgMappings?: {
            srcGlobalVirtualGroupId?: number;
            dstGlobalVirtualGroupId?: number;
            secondarySpBlsSignature?: Uint8Array;
        }[] & ({
            srcGlobalVirtualGroupId?: number;
            dstGlobalVirtualGroupId?: number;
            secondarySpBlsSignature?: Uint8Array;
        } & {
            srcGlobalVirtualGroupId?: number;
            dstGlobalVirtualGroupId?: number;
            secondarySpBlsSignature?: Uint8Array;
        } & Record<Exclude<keyof I["gvgMappings"][number], keyof GVGMapping>, never>)[] & Record<Exclude<keyof I["gvgMappings"], keyof {
            srcGlobalVirtualGroupId?: number;
            dstGlobalVirtualGroupId?: number;
            secondarySpBlsSignature?: Uint8Array;
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof MsgCompleteMigrateBucket>, never>>(object: I): MsgCompleteMigrateBucket;
    fromSDK(object: MsgCompleteMigrateBucketSDKType): MsgCompleteMigrateBucket;
    toSDK(message: MsgCompleteMigrateBucket): MsgCompleteMigrateBucketSDKType;
    fromAmino(object: MsgCompleteMigrateBucketAmino): MsgCompleteMigrateBucket;
    toAmino(message: MsgCompleteMigrateBucket): MsgCompleteMigrateBucketAmino;
    fromAminoMsg(object: MsgCompleteMigrateBucketAminoMsg): MsgCompleteMigrateBucket;
    fromProtoMsg(message: MsgCompleteMigrateBucketProtoMsg): MsgCompleteMigrateBucket;
    toProto(message: MsgCompleteMigrateBucket): Uint8Array;
    toProtoMsg(message: MsgCompleteMigrateBucket): MsgCompleteMigrateBucketProtoMsg;
};
export declare const MsgCompleteMigrateBucketResponse: {
    typeUrl: string;
    encode(_: MsgCompleteMigrateBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCompleteMigrateBucketResponse;
    fromJSON(_: any): MsgCompleteMigrateBucketResponse;
    toJSON(_: MsgCompleteMigrateBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCompleteMigrateBucketResponse;
    fromSDK(_: MsgCompleteMigrateBucketResponseSDKType): MsgCompleteMigrateBucketResponse;
    toSDK(_: MsgCompleteMigrateBucketResponse): MsgCompleteMigrateBucketResponseSDKType;
    fromAmino(_: MsgCompleteMigrateBucketResponseAmino): MsgCompleteMigrateBucketResponse;
    toAmino(_: MsgCompleteMigrateBucketResponse): MsgCompleteMigrateBucketResponseAmino;
    fromAminoMsg(object: MsgCompleteMigrateBucketResponseAminoMsg): MsgCompleteMigrateBucketResponse;
    fromProtoMsg(message: MsgCompleteMigrateBucketResponseProtoMsg): MsgCompleteMigrateBucketResponse;
    toProto(message: MsgCompleteMigrateBucketResponse): Uint8Array;
    toProtoMsg(message: MsgCompleteMigrateBucketResponse): MsgCompleteMigrateBucketResponseProtoMsg;
};
export declare const MsgCancelMigrateBucket: {
    typeUrl: string;
    encode(message: MsgCancelMigrateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelMigrateBucket;
    fromJSON(object: any): MsgCancelMigrateBucket;
    toJSON(message: MsgCancelMigrateBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
    } & {
        operator?: string;
        bucketName?: string;
    } & Record<Exclude<keyof I, keyof MsgCancelMigrateBucket>, never>>(object: I): MsgCancelMigrateBucket;
    fromSDK(object: MsgCancelMigrateBucketSDKType): MsgCancelMigrateBucket;
    toSDK(message: MsgCancelMigrateBucket): MsgCancelMigrateBucketSDKType;
    fromAmino(object: MsgCancelMigrateBucketAmino): MsgCancelMigrateBucket;
    toAmino(message: MsgCancelMigrateBucket): MsgCancelMigrateBucketAmino;
    fromAminoMsg(object: MsgCancelMigrateBucketAminoMsg): MsgCancelMigrateBucket;
    fromProtoMsg(message: MsgCancelMigrateBucketProtoMsg): MsgCancelMigrateBucket;
    toProto(message: MsgCancelMigrateBucket): Uint8Array;
    toProtoMsg(message: MsgCancelMigrateBucket): MsgCancelMigrateBucketProtoMsg;
};
export declare const MsgCancelMigrateBucketResponse: {
    typeUrl: string;
    encode(_: MsgCancelMigrateBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgCancelMigrateBucketResponse;
    fromJSON(_: any): MsgCancelMigrateBucketResponse;
    toJSON(_: MsgCancelMigrateBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgCancelMigrateBucketResponse;
    fromSDK(_: MsgCancelMigrateBucketResponseSDKType): MsgCancelMigrateBucketResponse;
    toSDK(_: MsgCancelMigrateBucketResponse): MsgCancelMigrateBucketResponseSDKType;
    fromAmino(_: MsgCancelMigrateBucketResponseAmino): MsgCancelMigrateBucketResponse;
    toAmino(_: MsgCancelMigrateBucketResponse): MsgCancelMigrateBucketResponseAmino;
    fromAminoMsg(object: MsgCancelMigrateBucketResponseAminoMsg): MsgCancelMigrateBucketResponse;
    fromProtoMsg(message: MsgCancelMigrateBucketResponseProtoMsg): MsgCancelMigrateBucketResponse;
    toProto(message: MsgCancelMigrateBucketResponse): Uint8Array;
    toProtoMsg(message: MsgCancelMigrateBucketResponse): MsgCancelMigrateBucketResponseProtoMsg;
};
export declare const MsgRejectMigrateBucket: {
    typeUrl: string;
    encode(message: MsgRejectMigrateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRejectMigrateBucket;
    fromJSON(object: any): MsgRejectMigrateBucket;
    toJSON(message: MsgRejectMigrateBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
    } & {
        operator?: string;
        bucketName?: string;
    } & Record<Exclude<keyof I, keyof MsgRejectMigrateBucket>, never>>(object: I): MsgRejectMigrateBucket;
    fromSDK(object: MsgRejectMigrateBucketSDKType): MsgRejectMigrateBucket;
    toSDK(message: MsgRejectMigrateBucket): MsgRejectMigrateBucketSDKType;
    fromAmino(object: MsgRejectMigrateBucketAmino): MsgRejectMigrateBucket;
    toAmino(message: MsgRejectMigrateBucket): MsgRejectMigrateBucketAmino;
    fromAminoMsg(object: MsgRejectMigrateBucketAminoMsg): MsgRejectMigrateBucket;
    fromProtoMsg(message: MsgRejectMigrateBucketProtoMsg): MsgRejectMigrateBucket;
    toProto(message: MsgRejectMigrateBucket): Uint8Array;
    toProtoMsg(message: MsgRejectMigrateBucket): MsgRejectMigrateBucketProtoMsg;
};
export declare const MsgRejectMigrateBucketResponse: {
    typeUrl: string;
    encode(_: MsgRejectMigrateBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgRejectMigrateBucketResponse;
    fromJSON(_: any): MsgRejectMigrateBucketResponse;
    toJSON(_: MsgRejectMigrateBucketResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgRejectMigrateBucketResponse;
    fromSDK(_: MsgRejectMigrateBucketResponseSDKType): MsgRejectMigrateBucketResponse;
    toSDK(_: MsgRejectMigrateBucketResponse): MsgRejectMigrateBucketResponseSDKType;
    fromAmino(_: MsgRejectMigrateBucketResponseAmino): MsgRejectMigrateBucketResponse;
    toAmino(_: MsgRejectMigrateBucketResponse): MsgRejectMigrateBucketResponseAmino;
    fromAminoMsg(object: MsgRejectMigrateBucketResponseAminoMsg): MsgRejectMigrateBucketResponse;
    fromProtoMsg(message: MsgRejectMigrateBucketResponseProtoMsg): MsgRejectMigrateBucketResponse;
    toProto(message: MsgRejectMigrateBucketResponse): Uint8Array;
    toProtoMsg(message: MsgRejectMigrateBucketResponse): MsgRejectMigrateBucketResponseProtoMsg;
};
export declare const MsgSetTag: {
    typeUrl: string;
    encode(message: MsgSetTag, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSetTag;
    fromJSON(object: any): MsgSetTag;
    toJSON(message: MsgSetTag): unknown;
    fromPartial<I extends {
        operator?: string;
        resource?: string;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        };
    } & {
        operator?: string;
        resource?: string;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        } & {
            tags?: {
                key?: string;
                value?: string;
            }[] & ({
                key?: string;
                value?: string;
            } & {
                key?: string;
                value?: string;
            } & Record<Exclude<keyof I["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["tags"]["tags"], keyof {
                key?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["tags"], "tags">, never>;
    } & Record<Exclude<keyof I, keyof MsgSetTag>, never>>(object: I): MsgSetTag;
    fromSDK(object: MsgSetTagSDKType): MsgSetTag;
    toSDK(message: MsgSetTag): MsgSetTagSDKType;
    fromAmino(object: MsgSetTagAmino): MsgSetTag;
    toAmino(message: MsgSetTag): MsgSetTagAmino;
    fromAminoMsg(object: MsgSetTagAminoMsg): MsgSetTag;
    fromProtoMsg(message: MsgSetTagProtoMsg): MsgSetTag;
    toProto(message: MsgSetTag): Uint8Array;
    toProtoMsg(message: MsgSetTag): MsgSetTagProtoMsg;
};
export declare const MsgSetTagResponse: {
    typeUrl: string;
    encode(_: MsgSetTagResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): MsgSetTagResponse;
    fromJSON(_: any): MsgSetTagResponse;
    toJSON(_: MsgSetTagResponse): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): MsgSetTagResponse;
    fromSDK(_: MsgSetTagResponseSDKType): MsgSetTagResponse;
    toSDK(_: MsgSetTagResponse): MsgSetTagResponseSDKType;
    fromAmino(_: MsgSetTagResponseAmino): MsgSetTagResponse;
    toAmino(_: MsgSetTagResponse): MsgSetTagResponseAmino;
    fromAminoMsg(object: MsgSetTagResponseAminoMsg): MsgSetTagResponse;
    fromProtoMsg(message: MsgSetTagResponseProtoMsg): MsgSetTagResponse;
    toProto(message: MsgSetTagResponse): Uint8Array;
    toProtoMsg(message: MsgSetTagResponse): MsgSetTagResponseProtoMsg;
};
/** Msg defines the Msg service. */
export interface Msg {
    /** basic operation of bucket */
    CreateBucket(request: MsgCreateBucket): Promise<MsgCreateBucketResponse>;
    DeleteBucket(request: MsgDeleteBucket): Promise<MsgDeleteBucketResponse>;
    UpdateBucketInfo(request: MsgUpdateBucketInfo): Promise<MsgUpdateBucketInfoResponse>;
    MirrorBucket(request: MsgMirrorBucket): Promise<MsgMirrorBucketResponse>;
    DiscontinueBucket(request: MsgDiscontinueBucket): Promise<MsgDiscontinueBucketResponse>;
    /** basic operation of object */
    CreateObject(request: MsgCreateObject): Promise<MsgCreateObjectResponse>;
    SealObject(request: MsgSealObject): Promise<MsgSealObjectResponse>;
    RejectSealObject(request: MsgRejectSealObject): Promise<MsgRejectSealObjectResponse>;
    CopyObject(request: MsgCopyObject): Promise<MsgCopyObjectResponse>;
    DeleteObject(request: MsgDeleteObject): Promise<MsgDeleteObjectResponse>;
    CancelCreateObject(request: MsgCancelCreateObject): Promise<MsgCancelCreateObjectResponse>;
    MirrorObject(request: MsgMirrorObject): Promise<MsgMirrorObjectResponse>;
    DiscontinueObject(request: MsgDiscontinueObject): Promise<MsgDiscontinueObjectResponse>;
    UpdateObjectInfo(request: MsgUpdateObjectInfo): Promise<MsgUpdateObjectInfoResponse>;
    /** basic operation of group */
    CreateGroup(request: MsgCreateGroup): Promise<MsgCreateGroupResponse>;
    DeleteGroup(request: MsgDeleteGroup): Promise<MsgDeleteGroupResponse>;
    UpdateGroupMember(request: MsgUpdateGroupMember): Promise<MsgUpdateGroupMemberResponse>;
    UpdateGroupExtra(request: MsgUpdateGroupExtra): Promise<MsgUpdateGroupExtraResponse>;
    LeaveGroup(request: MsgLeaveGroup): Promise<MsgLeaveGroupResponse>;
    MirrorGroup(request: MsgMirrorGroup): Promise<MsgMirrorGroupResponse>;
    RenewGroupMember(request: MsgRenewGroupMember): Promise<MsgRenewGroupMemberResponse>;
    /** basic operation of policy */
    PutPolicy(request: MsgPutPolicy): Promise<MsgPutPolicyResponse>;
    DeletePolicy(request: MsgDeletePolicy): Promise<MsgDeletePolicyResponse>;
    /** Since: cosmos-sdk 0.47 */
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
    MigrateBucket(request: MsgMigrateBucket): Promise<MsgMigrateBucketResponse>;
    CompleteMigrateBucket(request: MsgCompleteMigrateBucket): Promise<MsgCompleteMigrateBucketResponse>;
    CancelMigrateBucket(request: MsgCancelMigrateBucket): Promise<MsgCancelMigrateBucketResponse>;
    RejectMigrateBucket(request: MsgRejectMigrateBucket): Promise<MsgRejectMigrateBucketResponse>;
    /** Since: Manchurian upgrade */
    SetTag(request: MsgSetTag): Promise<MsgSetTagResponse>;
}
export declare class MsgClientImpl implements Msg {
    private readonly rpc;
    constructor(rpc: Rpc);
    CreateBucket(request: MsgCreateBucket): Promise<MsgCreateBucketResponse>;
    DeleteBucket(request: MsgDeleteBucket): Promise<MsgDeleteBucketResponse>;
    UpdateBucketInfo(request: MsgUpdateBucketInfo): Promise<MsgUpdateBucketInfoResponse>;
    MirrorBucket(request: MsgMirrorBucket): Promise<MsgMirrorBucketResponse>;
    DiscontinueBucket(request: MsgDiscontinueBucket): Promise<MsgDiscontinueBucketResponse>;
    CreateObject(request: MsgCreateObject): Promise<MsgCreateObjectResponse>;
    SealObject(request: MsgSealObject): Promise<MsgSealObjectResponse>;
    RejectSealObject(request: MsgRejectSealObject): Promise<MsgRejectSealObjectResponse>;
    CopyObject(request: MsgCopyObject): Promise<MsgCopyObjectResponse>;
    DeleteObject(request: MsgDeleteObject): Promise<MsgDeleteObjectResponse>;
    CancelCreateObject(request: MsgCancelCreateObject): Promise<MsgCancelCreateObjectResponse>;
    MirrorObject(request: MsgMirrorObject): Promise<MsgMirrorObjectResponse>;
    DiscontinueObject(request: MsgDiscontinueObject): Promise<MsgDiscontinueObjectResponse>;
    UpdateObjectInfo(request: MsgUpdateObjectInfo): Promise<MsgUpdateObjectInfoResponse>;
    CreateGroup(request: MsgCreateGroup): Promise<MsgCreateGroupResponse>;
    DeleteGroup(request: MsgDeleteGroup): Promise<MsgDeleteGroupResponse>;
    UpdateGroupMember(request: MsgUpdateGroupMember): Promise<MsgUpdateGroupMemberResponse>;
    UpdateGroupExtra(request: MsgUpdateGroupExtra): Promise<MsgUpdateGroupExtraResponse>;
    LeaveGroup(request: MsgLeaveGroup): Promise<MsgLeaveGroupResponse>;
    MirrorGroup(request: MsgMirrorGroup): Promise<MsgMirrorGroupResponse>;
    RenewGroupMember(request: MsgRenewGroupMember): Promise<MsgRenewGroupMemberResponse>;
    PutPolicy(request: MsgPutPolicy): Promise<MsgPutPolicyResponse>;
    DeletePolicy(request: MsgDeletePolicy): Promise<MsgDeletePolicyResponse>;
    UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
    MigrateBucket(request: MsgMigrateBucket): Promise<MsgMigrateBucketResponse>;
    CompleteMigrateBucket(request: MsgCompleteMigrateBucket): Promise<MsgCompleteMigrateBucketResponse>;
    CancelMigrateBucket(request: MsgCancelMigrateBucket): Promise<MsgCancelMigrateBucketResponse>;
    RejectMigrateBucket(request: MsgRejectMigrateBucket): Promise<MsgRejectMigrateBucketResponse>;
    SetTag(request: MsgSetTag): Promise<MsgSetTagResponse>;
}
