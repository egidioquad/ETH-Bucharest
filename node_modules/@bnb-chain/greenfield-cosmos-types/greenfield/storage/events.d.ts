/// <reference types="long" />
import { VisibilityType, SourceType, BucketStatus, ObjectStatus, RedundancyType } from "./common";
import { Timestamp, TimestampSDKType } from "../../google/protobuf/timestamp";
import { DeleteInfo, DeleteInfoAmino, DeleteInfoSDKType, ResourceTags, ResourceTagsAmino, ResourceTagsSDKType } from "./types";
import { Long } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
/** EventCreateBucket is emitted on MsgCreateBucket */
export interface EventCreateBucket {
    /** owner define the account address of bucket owner */
    owner: string;
    /** bucket_name is a globally unique name of bucket */
    bucketName: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get the object under it. */
    visibility: VisibilityType;
    /** create_at define the block timestamp when the bucket has been created */
    createAt: Long;
    /** bucket_id is the unique u256 for bucket. Not global, only unique in buckets. */
    bucketId: string;
    /** source_type define the source of the bucket. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** read_quota defines the charged traffic quota for read, not include free quota which provided by each storage provider */
    chargedReadQuota: Long;
    /** payment_address is the address of the payment account */
    paymentAddress: string;
    /** primary_sp_id is the unique id of primary sp. */
    primarySpId: number;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    globalVirtualGroupFamilyId: number;
    /** status define the status of the bucket. */
    status: BucketStatus;
}
export interface EventCreateBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventCreateBucket";
    value: Uint8Array;
}
/** EventCreateBucket is emitted on MsgCreateBucket */
export interface EventCreateBucketAmino {
    /** owner define the account address of bucket owner */
    owner?: string;
    /** bucket_name is a globally unique name of bucket */
    bucket_name?: string;
    /** visibility defines the highest permissions for bucket. When a bucket is public, everyone can get the object under it. */
    visibility?: VisibilityType;
    /** create_at define the block timestamp when the bucket has been created */
    create_at?: string;
    /** bucket_id is the unique u256 for bucket. Not global, only unique in buckets. */
    bucket_id?: string;
    /** source_type define the source of the bucket. CrossChain or Greenfield origin */
    source_type?: SourceType;
    /** read_quota defines the charged traffic quota for read, not include free quota which provided by each storage provider */
    charged_read_quota?: string;
    /** payment_address is the address of the payment account */
    payment_address?: string;
    /** primary_sp_id is the unique id of primary sp. */
    primary_sp_id?: number;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    global_virtual_group_family_id?: number;
    /** status define the status of the bucket. */
    status?: BucketStatus;
}
export interface EventCreateBucketAminoMsg {
    type: "/greenfield.storage.EventCreateBucket";
    value: EventCreateBucketAmino;
}
/** EventCreateBucket is emitted on MsgCreateBucket */
export interface EventCreateBucketSDKType {
    owner: string;
    bucket_name: string;
    visibility: VisibilityType;
    create_at: Long;
    bucket_id: string;
    source_type: SourceType;
    charged_read_quota: Long;
    payment_address: string;
    primary_sp_id: number;
    global_virtual_group_family_id: number;
    status: BucketStatus;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */
export interface EventDeleteBucket {
    /** operator define the account address of operator who delete the bucket */
    operator: string;
    /** owner define the account address of the bucket owner */
    owner: string;
    /** bucket_name define the name of the deleted bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    globalVirtualGroupFamilyId: number;
}
export interface EventDeleteBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventDeleteBucket";
    value: Uint8Array;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */
export interface EventDeleteBucketAmino {
    /** operator define the account address of operator who delete the bucket */
    operator?: string;
    /** owner define the account address of the bucket owner */
    owner?: string;
    /** bucket_name define the name of the deleted bucket */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
    /** global_virtual_group_family_id defines the unique id of gvg family */
    global_virtual_group_family_id?: number;
}
export interface EventDeleteBucketAminoMsg {
    type: "/greenfield.storage.EventDeleteBucket";
    value: EventDeleteBucketAmino;
}
/** EventDeleteBucket is emitted on MsgDeleteBucket */
export interface EventDeleteBucketSDKType {
    operator: string;
    owner: string;
    bucket_name: string;
    bucket_id: string;
    global_virtual_group_family_id: number;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */
export interface EventUpdateBucketInfo {
    /** operator define the account address of operator who update the bucket */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** charged_read_quota_after define the read quota after updated */
    chargedReadQuota: Long;
    /** payment_address define the payment address after updated */
    paymentAddress: string;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
    /** global_virtual_group_family_id defines the gvg family id after migrated. */
    globalVirtualGroupFamilyId: number;
}
export interface EventUpdateBucketInfoProtoMsg {
    typeUrl: "/greenfield.storage.EventUpdateBucketInfo";
    value: Uint8Array;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */
export interface EventUpdateBucketInfoAmino {
    /** operator define the account address of operator who update the bucket */
    operator?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
    /** charged_read_quota_after define the read quota after updated */
    charged_read_quota?: string;
    /** payment_address define the payment address after updated */
    payment_address?: string;
    /** visibility defines the highest permission of object. */
    visibility?: VisibilityType;
    /** global_virtual_group_family_id defines the gvg family id after migrated. */
    global_virtual_group_family_id?: number;
}
export interface EventUpdateBucketInfoAminoMsg {
    type: "/greenfield.storage.EventUpdateBucketInfo";
    value: EventUpdateBucketInfoAmino;
}
/** EventUpdateBucketInfo is emitted on MsgUpdateBucketInfo */
export interface EventUpdateBucketInfoSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    charged_read_quota: Long;
    payment_address: string;
    visibility: VisibilityType;
    global_virtual_group_family_id: number;
}
/** EventDiscontinueBucket is emitted on MsgDiscontinueBucket */
export interface EventDiscontinueBucket {
    /** bucket_id define id of the bucket */
    bucketId: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** the reason */
    reason: string;
    /** the timestamp after which the metadata will be deleted */
    deleteAt: Long;
}
export interface EventDiscontinueBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventDiscontinueBucket";
    value: Uint8Array;
}
/** EventDiscontinueBucket is emitted on MsgDiscontinueBucket */
export interface EventDiscontinueBucketAmino {
    /** bucket_id define id of the bucket */
    bucket_id?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** the reason */
    reason?: string;
    /** the timestamp after which the metadata will be deleted */
    delete_at?: string;
}
export interface EventDiscontinueBucketAminoMsg {
    type: "/greenfield.storage.EventDiscontinueBucket";
    value: EventDiscontinueBucketAmino;
}
/** EventDiscontinueBucket is emitted on MsgDiscontinueBucket */
export interface EventDiscontinueBucketSDKType {
    bucket_id: string;
    bucket_name: string;
    reason: string;
    delete_at: Long;
}
/** EventCreateObject is emitted on MsgCreateObject */
export interface EventCreateObject {
    /** creator define the account address of msg creator */
    creator: string;
    /** owner define the account address of object owner */
    owner: string;
    /** bucket_name define the name of bucket */
    bucketName: string;
    /** object_name define the name of object */
    objectName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** primary_sp_id define the unique id of primary sp */
    primarySpId: number;
    /** payload_size define the size of payload data which you want upload */
    payloadSize: Long;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
    /** content_type define the content type of the payload data */
    contentType: string;
    /** create_at define the block timestamp when the object created */
    createAt: Long;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status: ObjectStatus;
    /** redundancy_type define the type of redundancy. Replication or EC */
    redundancyType: RedundancyType;
    /** source_type define the source of the object.  CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** checksums define the total checksums of the object which generated by redundancy */
    checksums: Uint8Array[];
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    localVirtualGroupId: number;
}
export interface EventCreateObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventCreateObject";
    value: Uint8Array;
}
/** EventCreateObject is emitted on MsgCreateObject */
export interface EventCreateObjectAmino {
    /** creator define the account address of msg creator */
    creator?: string;
    /** owner define the account address of object owner */
    owner?: string;
    /** bucket_name define the name of bucket */
    bucket_name?: string;
    /** object_name define the name of object */
    object_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
    /** object_id define an u256 id for object */
    object_id?: string;
    /** primary_sp_id define the unique id of primary sp */
    primary_sp_id?: number;
    /** payload_size define the size of payload data which you want upload */
    payload_size?: string;
    /** visibility defines the highest permission of object. */
    visibility?: VisibilityType;
    /** content_type define the content type of the payload data */
    content_type?: string;
    /** create_at define the block timestamp when the object created */
    create_at?: string;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status?: ObjectStatus;
    /** redundancy_type define the type of redundancy. Replication or EC */
    redundancy_type?: RedundancyType;
    /** source_type define the source of the object.  CrossChain or Greenfield origin */
    source_type?: SourceType;
    /** checksums define the total checksums of the object which generated by redundancy */
    checksums?: string[];
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    local_virtual_group_id?: number;
}
export interface EventCreateObjectAminoMsg {
    type: "/greenfield.storage.EventCreateObject";
    value: EventCreateObjectAmino;
}
/** EventCreateObject is emitted on MsgCreateObject */
export interface EventCreateObjectSDKType {
    creator: string;
    owner: string;
    bucket_name: string;
    object_name: string;
    bucket_id: string;
    object_id: string;
    primary_sp_id: number;
    payload_size: Long;
    visibility: VisibilityType;
    content_type: string;
    create_at: Long;
    status: ObjectStatus;
    redundancy_type: RedundancyType;
    source_type: SourceType;
    checksums: Uint8Array[];
    local_virtual_group_id: number;
}
/** EventCancelCreateObject is emitted on MsgCancelCreateObject */
export interface EventCancelCreateObject {
    /** operator define the account address of operator who cancel create object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** primary_sp_id define the unique id of primary sp */
    primarySpId: number;
    /** id define an u256 id for object */
    objectId: string;
}
export interface EventCancelCreateObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventCancelCreateObject";
    value: Uint8Array;
}
/** EventCancelCreateObject is emitted on MsgCancelCreateObject */
export interface EventCancelCreateObjectAmino {
    /** operator define the account address of operator who cancel create object */
    operator?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_name define the name of the object */
    object_name?: string;
    /** primary_sp_id define the unique id of primary sp */
    primary_sp_id?: number;
    /** id define an u256 id for object */
    object_id?: string;
}
export interface EventCancelCreateObjectAminoMsg {
    type: "/greenfield.storage.EventCancelCreateObject";
    value: EventCancelCreateObjectAmino;
}
/** EventCancelCreateObject is emitted on MsgCancelCreateObject */
export interface EventCancelCreateObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    primary_sp_id: number;
    object_id: string;
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventSealObject {
    /** operator define the account address of operator who seal object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status: ObjectStatus;
    /** global_virtual_group_id defines the unique id of gvg which the object stored */
    globalVirtualGroupId: number;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    localVirtualGroupId: number;
}
export interface EventSealObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventSealObject";
    value: Uint8Array;
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventSealObjectAmino {
    /** operator define the account address of operator who seal object */
    operator?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_name define the name of the object */
    object_name?: string;
    /** id define an u256 id for object */
    object_id?: string;
    /** status define the status of the object. INIT or IN_SERVICE or others */
    status?: ObjectStatus;
    /** global_virtual_group_id defines the unique id of gvg which the object stored */
    global_virtual_group_id?: number;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    local_virtual_group_id?: number;
}
export interface EventSealObjectAminoMsg {
    type: "/greenfield.storage.EventSealObject";
    value: EventSealObjectAmino;
}
/** EventSealObject is emitted on MsgSealObject */
export interface EventSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    status: ObjectStatus;
    global_virtual_group_id: number;
    local_virtual_group_id: number;
}
/** EventCopyObject is emitted on MsgCopyObject */
export interface EventCopyObject {
    /** operator define the account address of operator who copy the object */
    operator: string;
    /** src_bucket_name define the name of the src bucket */
    srcBucketName: string;
    /** src_object_name define the name of the src object */
    srcObjectName: string;
    /** dst_bucket_name define the name of the dst bucket */
    dstBucketName: string;
    /** dst_object_name define the name of the dst object */
    dstObjectName: string;
    /** src_object_id define the u256 id for src object */
    srcObjectId: string;
    /** dst_object_id define the u256 id for dst object */
    dstObjectId: string;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    localVirtualGroupId: number;
}
export interface EventCopyObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventCopyObject";
    value: Uint8Array;
}
/** EventCopyObject is emitted on MsgCopyObject */
export interface EventCopyObjectAmino {
    /** operator define the account address of operator who copy the object */
    operator?: string;
    /** src_bucket_name define the name of the src bucket */
    src_bucket_name?: string;
    /** src_object_name define the name of the src object */
    src_object_name?: string;
    /** dst_bucket_name define the name of the dst bucket */
    dst_bucket_name?: string;
    /** dst_object_name define the name of the dst object */
    dst_object_name?: string;
    /** src_object_id define the u256 id for src object */
    src_object_id?: string;
    /** dst_object_id define the u256 id for dst object */
    dst_object_id?: string;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    local_virtual_group_id?: number;
}
export interface EventCopyObjectAminoMsg {
    type: "/greenfield.storage.EventCopyObject";
    value: EventCopyObjectAmino;
}
/** EventCopyObject is emitted on MsgCopyObject */
export interface EventCopyObjectSDKType {
    operator: string;
    src_bucket_name: string;
    src_object_name: string;
    dst_bucket_name: string;
    dst_object_name: string;
    src_object_id: string;
    dst_object_id: string;
    local_virtual_group_id: number;
}
/** EventDeleteObject is emitted on MsgDeleteObject */
export interface EventDeleteObject {
    /** operator define the account address of operator who delete the object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    localVirtualGroupId: number;
}
export interface EventDeleteObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventDeleteObject";
    value: Uint8Array;
}
/** EventDeleteObject is emitted on MsgDeleteObject */
export interface EventDeleteObjectAmino {
    /** operator define the account address of operator who delete the object */
    operator?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_name define the name of the object */
    object_name?: string;
    /** id define an u256 id for object */
    object_id?: string;
    /** local_virtual_group_id defines the unique id of lvg which the object stored */
    local_virtual_group_id?: number;
}
export interface EventDeleteObjectAminoMsg {
    type: "/greenfield.storage.EventDeleteObject";
    value: EventDeleteObjectAmino;
}
/** EventDeleteObject is emitted on MsgDeleteObject */
export interface EventDeleteObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    local_virtual_group_id: number;
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */
export interface EventRejectSealObject {
    /** operator define the account address of operator who reject seal object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** id define an u256 id for object */
    objectId: string;
}
export interface EventRejectSealObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventRejectSealObject";
    value: Uint8Array;
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */
export interface EventRejectSealObjectAmino {
    /** operator define the account address of operator who reject seal object */
    operator?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_name define the name of the object */
    object_name?: string;
    /** id define an u256 id for object */
    object_id?: string;
}
export interface EventRejectSealObjectAminoMsg {
    type: "/greenfield.storage.EventRejectSealObject";
    value: EventRejectSealObjectAmino;
}
/** EventRejectSealObject is emitted on MsgRejectSealObject */
export interface EventRejectSealObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
}
/** EventDiscontinueObject is emitted on MsgDiscontinueObject */
export interface EventDiscontinueObject {
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_id defines id of the object */
    objectId: string;
    /** the reason */
    reason: string;
    /** the timestamp after which the metadata will be deleted */
    deleteAt: Long;
}
export interface EventDiscontinueObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventDiscontinueObject";
    value: Uint8Array;
}
/** EventDiscontinueObject is emitted on MsgDiscontinueObject */
export interface EventDiscontinueObjectAmino {
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_id defines id of the object */
    object_id?: string;
    /** the reason */
    reason?: string;
    /** the timestamp after which the metadata will be deleted */
    delete_at?: string;
}
export interface EventDiscontinueObjectAminoMsg {
    type: "/greenfield.storage.EventDiscontinueObject";
    value: EventDiscontinueObjectAmino;
}
/** EventDiscontinueObject is emitted on MsgDiscontinueObject */
export interface EventDiscontinueObjectSDKType {
    bucket_name: string;
    object_id: string;
    reason: string;
    delete_at: Long;
}
/** EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo */
export interface EventUpdateObjectInfo {
    /** operator define the account address of operator who update the bucket */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** visibility defines the highest permission of object. */
    visibility: VisibilityType;
}
export interface EventUpdateObjectInfoProtoMsg {
    typeUrl: "/greenfield.storage.EventUpdateObjectInfo";
    value: Uint8Array;
}
/** EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo */
export interface EventUpdateObjectInfoAmino {
    /** operator define the account address of operator who update the bucket */
    operator?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_name define the name of the object */
    object_name?: string;
    /** object_id define an u256 id for object */
    object_id?: string;
    /** visibility defines the highest permission of object. */
    visibility?: VisibilityType;
}
export interface EventUpdateObjectInfoAminoMsg {
    type: "/greenfield.storage.EventUpdateObjectInfo";
    value: EventUpdateObjectInfoAmino;
}
/** EventUpdateObjectInfo is emitted on MsgUpdateObjectInfo */
export interface EventUpdateObjectInfoSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    visibility: VisibilityType;
}
/** EventCreateGroup is emitted on MsgCreateGroup */
export interface EventCreateGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** source_type define the source of the group. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** extra defines extra info for the group */
    extra: string;
}
export interface EventCreateGroupProtoMsg {
    typeUrl: "/greenfield.storage.EventCreateGroup";
    value: Uint8Array;
}
/** EventCreateGroup is emitted on MsgCreateGroup */
export interface EventCreateGroupAmino {
    /** owner define the account address of group owner */
    owner?: string;
    /** group_name define the name of the group */
    group_name?: string;
    /** id define an u256 id for group */
    group_id?: string;
    /** source_type define the source of the group. CrossChain or Greenfield origin */
    source_type?: SourceType;
    /** extra defines extra info for the group */
    extra?: string;
}
export interface EventCreateGroupAminoMsg {
    type: "/greenfield.storage.EventCreateGroup";
    value: EventCreateGroupAmino;
}
/** EventCreateGroup is emitted on MsgCreateGroup */
export interface EventCreateGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
    source_type: SourceType;
    extra: string;
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */
export interface EventDeleteGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
}
export interface EventDeleteGroupProtoMsg {
    typeUrl: "/greenfield.storage.EventDeleteGroup";
    value: Uint8Array;
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */
export interface EventDeleteGroupAmino {
    /** owner define the account address of group owner */
    owner?: string;
    /** group_name define the name of the group */
    group_name?: string;
    /** id define an u256 id for group */
    group_id?: string;
}
export interface EventDeleteGroupAminoMsg {
    type: "/greenfield.storage.EventDeleteGroup";
    value: EventDeleteGroupAmino;
}
/** EventDeleteGroup is emitted on MsgDeleteGroup */
export interface EventDeleteGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */
export interface EventLeaveGroup {
    /** member_address define the address of the member who leave the group */
    memberAddress: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
}
export interface EventLeaveGroupProtoMsg {
    typeUrl: "/greenfield.storage.EventLeaveGroup";
    value: Uint8Array;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */
export interface EventLeaveGroupAmino {
    /** member_address define the address of the member who leave the group */
    member_address?: string;
    /** owner define the account address of group owner */
    owner?: string;
    /** group_name define the name of the group */
    group_name?: string;
    /** id define an u256 id for group */
    group_id?: string;
}
export interface EventLeaveGroupAminoMsg {
    type: "/greenfield.storage.EventLeaveGroup";
    value: EventLeaveGroupAmino;
}
/** EventLeaveGroup is emitted on MsgLeaveGroup */
export interface EventLeaveGroupSDKType {
    member_address: string;
    owner: string;
    group_name: string;
    group_id: string;
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */
export interface EventUpdateGroupMember {
    /** operator define the account address of operator who update the group member */
    operator: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** members_to_add defines all the members to be added to the group */
    membersToAdd: EventGroupMemberDetail[];
    /** members_to_add defines all the members to be deleted from the group */
    membersToDelete: string[];
}
export interface EventUpdateGroupMemberProtoMsg {
    typeUrl: "/greenfield.storage.EventUpdateGroupMember";
    value: Uint8Array;
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */
export interface EventUpdateGroupMemberAmino {
    /** operator define the account address of operator who update the group member */
    operator?: string;
    /** owner define the account address of group owner */
    owner?: string;
    /** group_name define the name of the group */
    group_name?: string;
    /** id define an u256 id for group */
    group_id?: string;
    /** members_to_add defines all the members to be added to the group */
    members_to_add?: EventGroupMemberDetailAmino[];
    /** members_to_add defines all the members to be deleted from the group */
    members_to_delete?: string[];
}
export interface EventUpdateGroupMemberAminoMsg {
    type: "/greenfield.storage.EventUpdateGroupMember";
    value: EventUpdateGroupMemberAmino;
}
/** EventUpdateGroupMember is emitted on MsgUpdateGroupMember */
export interface EventUpdateGroupMemberSDKType {
    operator: string;
    owner: string;
    group_name: string;
    group_id: string;
    members_to_add: EventGroupMemberDetailSDKType[];
    members_to_delete: string[];
}
export interface EventRenewGroupMember {
    /** operator define the account address of operator who update the group member */
    operator: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** source_type define the source of the group. CrossChain or Greenfield origin */
    sourceType: SourceType;
    /** members define the all the address of the members. */
    members: EventGroupMemberDetail[];
}
export interface EventRenewGroupMemberProtoMsg {
    typeUrl: "/greenfield.storage.EventRenewGroupMember";
    value: Uint8Array;
}
export interface EventRenewGroupMemberAmino {
    /** operator define the account address of operator who update the group member */
    operator?: string;
    /** owner define the account address of group owner */
    owner?: string;
    /** group_name define the name of the group */
    group_name?: string;
    /** id define an u256 id for group */
    group_id?: string;
    /** source_type define the source of the group. CrossChain or Greenfield origin */
    source_type?: SourceType;
    /** members define the all the address of the members. */
    members?: EventGroupMemberDetailAmino[];
}
export interface EventRenewGroupMemberAminoMsg {
    type: "/greenfield.storage.EventRenewGroupMember";
    value: EventRenewGroupMemberAmino;
}
export interface EventRenewGroupMemberSDKType {
    operator: string;
    owner: string;
    group_name: string;
    group_id: string;
    source_type: SourceType;
    members: EventGroupMemberDetailSDKType[];
}
export interface EventGroupMemberDetail {
    /** member defines the account address of the group member */
    member: string;
    /** expiration_time defines the expiration time of the group member */
    expirationTime?: Timestamp;
}
export interface EventGroupMemberDetailProtoMsg {
    typeUrl: "/greenfield.storage.EventGroupMemberDetail";
    value: Uint8Array;
}
export interface EventGroupMemberDetailAmino {
    /** member defines the account address of the group member */
    member?: string;
    /** expiration_time defines the expiration time of the group member */
    expiration_time?: string;
}
export interface EventGroupMemberDetailAminoMsg {
    type: "/greenfield.storage.EventGroupMemberDetail";
    value: EventGroupMemberDetailAmino;
}
export interface EventGroupMemberDetailSDKType {
    member: string;
    expiration_time?: TimestampSDKType;
}
/** EventUpdateGroupExtra is emitted on MsgUpdateGroupExtra */
export interface EventUpdateGroupExtra {
    /** operator define the account address of operator who update the group member */
    operator: string;
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** id define an u256 id for group */
    groupId: string;
    /** extra defines extra info for the group to update */
    extra: string;
}
export interface EventUpdateGroupExtraProtoMsg {
    typeUrl: "/greenfield.storage.EventUpdateGroupExtra";
    value: Uint8Array;
}
/** EventUpdateGroupExtra is emitted on MsgUpdateGroupExtra */
export interface EventUpdateGroupExtraAmino {
    /** operator define the account address of operator who update the group member */
    operator?: string;
    /** owner define the account address of group owner */
    owner?: string;
    /** group_name define the name of the group */
    group_name?: string;
    /** id define an u256 id for group */
    group_id?: string;
    /** extra defines extra info for the group to update */
    extra?: string;
}
export interface EventUpdateGroupExtraAminoMsg {
    type: "/greenfield.storage.EventUpdateGroupExtra";
    value: EventUpdateGroupExtraAmino;
}
/** EventUpdateGroupExtra is emitted on MsgUpdateGroupExtra */
export interface EventUpdateGroupExtraSDKType {
    operator: string;
    owner: string;
    group_name: string;
    group_id: string;
    extra: string;
}
/** EventMirrorBucket is emitted on MirrorBucket */
export interface EventMirrorBucket {
    /** operator define the account address of operator who mirror the bucket */
    operator: string;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
export interface EventMirrorBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventMirrorBucket";
    value: Uint8Array;
}
/** EventMirrorBucket is emitted on MirrorBucket */
export interface EventMirrorBucketAmino {
    /** operator define the account address of operator who mirror the bucket */
    operator?: string;
    /** bucket_name defines the name of the bucket */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
    /** chain id of the destination chain */
    dest_chain_id?: number;
}
export interface EventMirrorBucketAminoMsg {
    type: "/greenfield.storage.EventMirrorBucket";
    value: EventMirrorBucketAmino;
}
/** EventMirrorBucket is emitted on MirrorBucket */
export interface EventMirrorBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    dest_chain_id: number;
}
/** EventMirrorBucketResult is emitted on receiving ack package from destination chain */
export interface EventMirrorBucketResult {
    /** status define the status of the result */
    status: number;
    /** bucket_name defines the name of the bucket */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
export interface EventMirrorBucketResultProtoMsg {
    typeUrl: "/greenfield.storage.EventMirrorBucketResult";
    value: Uint8Array;
}
/** EventMirrorBucketResult is emitted on receiving ack package from destination chain */
export interface EventMirrorBucketResultAmino {
    /** status define the status of the result */
    status?: number;
    /** bucket_name defines the name of the bucket */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
    /** chain id of the destination chain */
    dest_chain_id?: number;
}
export interface EventMirrorBucketResultAminoMsg {
    type: "/greenfield.storage.EventMirrorBucketResult";
    value: EventMirrorBucketResultAmino;
}
/** EventMirrorBucketResult is emitted on receiving ack package from destination chain */
export interface EventMirrorBucketResultSDKType {
    status: number;
    bucket_name: string;
    bucket_id: string;
    dest_chain_id: number;
}
/** EventMirrorObject is emitted on MirrorObject */
export interface EventMirrorObject {
    /** operator define the account address of operator who delete the object */
    operator: string;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
export interface EventMirrorObjectProtoMsg {
    typeUrl: "/greenfield.storage.EventMirrorObject";
    value: Uint8Array;
}
/** EventMirrorObject is emitted on MirrorObject */
export interface EventMirrorObjectAmino {
    /** operator define the account address of operator who delete the object */
    operator?: string;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_name define the name of the object */
    object_name?: string;
    /** object_id define an u256 id for object */
    object_id?: string;
    /** chain id of the destination chain */
    dest_chain_id?: number;
}
export interface EventMirrorObjectAminoMsg {
    type: "/greenfield.storage.EventMirrorObject";
    value: EventMirrorObjectAmino;
}
/** EventMirrorObject is emitted on MirrorObject */
export interface EventMirrorObjectSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    object_id: string;
    dest_chain_id: number;
}
/** EventMirrorObjectResult is emitted on receiving ack package from destination chain */
export interface EventMirrorObjectResult {
    /** status define the status of the result */
    status: number;
    /** bucket_name define the name of the bucket */
    bucketName: string;
    /** object_name define the name of the object */
    objectName: string;
    /** object_id define an u256 id for object */
    objectId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
export interface EventMirrorObjectResultProtoMsg {
    typeUrl: "/greenfield.storage.EventMirrorObjectResult";
    value: Uint8Array;
}
/** EventMirrorObjectResult is emitted on receiving ack package from destination chain */
export interface EventMirrorObjectResultAmino {
    /** status define the status of the result */
    status?: number;
    /** bucket_name define the name of the bucket */
    bucket_name?: string;
    /** object_name define the name of the object */
    object_name?: string;
    /** object_id define an u256 id for object */
    object_id?: string;
    /** chain id of the destination chain */
    dest_chain_id?: number;
}
export interface EventMirrorObjectResultAminoMsg {
    type: "/greenfield.storage.EventMirrorObjectResult";
    value: EventMirrorObjectResultAmino;
}
/** EventMirrorObjectResult is emitted on receiving ack package from destination chain */
export interface EventMirrorObjectResultSDKType {
    status: number;
    bucket_name: string;
    object_name: string;
    object_id: string;
    dest_chain_id: number;
}
/** EventMirrorGroup is emitted on MirrorGroup */
export interface EventMirrorGroup {
    /** owner define the account address of group owner */
    owner: string;
    /** group_name define the name of the group */
    groupName: string;
    /** group_id define an u256 id for group */
    groupId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
export interface EventMirrorGroupProtoMsg {
    typeUrl: "/greenfield.storage.EventMirrorGroup";
    value: Uint8Array;
}
/** EventMirrorGroup is emitted on MirrorGroup */
export interface EventMirrorGroupAmino {
    /** owner define the account address of group owner */
    owner?: string;
    /** group_name define the name of the group */
    group_name?: string;
    /** group_id define an u256 id for group */
    group_id?: string;
    /** chain id of the destination chain */
    dest_chain_id?: number;
}
export interface EventMirrorGroupAminoMsg {
    type: "/greenfield.storage.EventMirrorGroup";
    value: EventMirrorGroupAmino;
}
/** EventMirrorGroup is emitted on MirrorGroup */
export interface EventMirrorGroupSDKType {
    owner: string;
    group_name: string;
    group_id: string;
    dest_chain_id: number;
}
/** EventMirrorGroupResult is emitted on receiving ack package from destination chain */
export interface EventMirrorGroupResult {
    /** status define the status of the result */
    status: number;
    /** group_name define the name of the group */
    groupName: string;
    /** group_id define an u256 id for group */
    groupId: string;
    /** chain id of the destination chain */
    destChainId: number;
}
export interface EventMirrorGroupResultProtoMsg {
    typeUrl: "/greenfield.storage.EventMirrorGroupResult";
    value: Uint8Array;
}
/** EventMirrorGroupResult is emitted on receiving ack package from destination chain */
export interface EventMirrorGroupResultAmino {
    /** status define the status of the result */
    status?: number;
    /** group_name define the name of the group */
    group_name?: string;
    /** group_id define an u256 id for group */
    group_id?: string;
    /** chain id of the destination chain */
    dest_chain_id?: number;
}
export interface EventMirrorGroupResultAminoMsg {
    type: "/greenfield.storage.EventMirrorGroupResult";
    value: EventMirrorGroupResultAmino;
}
/** EventMirrorGroupResult is emitted on receiving ack package from destination chain */
export interface EventMirrorGroupResultSDKType {
    status: number;
    group_name: string;
    group_id: string;
    dest_chain_id: number;
}
/** EventStalePolicyCleanup is emitted when specified block height's stale policies need to be Garbage collected */
export interface EventStalePolicyCleanup {
    blockNum: Long;
    deleteInfo?: DeleteInfo;
}
export interface EventStalePolicyCleanupProtoMsg {
    typeUrl: "/greenfield.storage.EventStalePolicyCleanup";
    value: Uint8Array;
}
/** EventStalePolicyCleanup is emitted when specified block height's stale policies need to be Garbage collected */
export interface EventStalePolicyCleanupAmino {
    blockNum?: string;
    delete_info?: DeleteInfoAmino;
}
export interface EventStalePolicyCleanupAminoMsg {
    type: "/greenfield.storage.EventStalePolicyCleanup";
    value: EventStalePolicyCleanupAmino;
}
/** EventStalePolicyCleanup is emitted when specified block height's stale policies need to be Garbage collected */
export interface EventStalePolicyCleanupSDKType {
    blockNum: Long;
    delete_info?: DeleteInfoSDKType;
}
export interface EventMigrationBucket {
    /**
     * The address of the operator that initiated the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator: string;
    /** The name of the bucket to be migrated */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** The id of the destination primary sp */
    dstPrimarySpId: number;
}
export interface EventMigrationBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventMigrationBucket";
    value: Uint8Array;
}
export interface EventMigrationBucketAmino {
    /**
     * The address of the operator that initiated the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator?: string;
    /** The name of the bucket to be migrated */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
    /** The id of the destination primary sp */
    dst_primary_sp_id?: number;
}
export interface EventMigrationBucketAminoMsg {
    type: "/greenfield.storage.EventMigrationBucket";
    value: EventMigrationBucketAmino;
}
export interface EventMigrationBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    dst_primary_sp_id: number;
}
export interface EventCancelMigrationBucket {
    /**
     * The address of the operator that canceled the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator: string;
    /** The name of the bucket to be migrated */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
}
export interface EventCancelMigrationBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventCancelMigrationBucket";
    value: Uint8Array;
}
export interface EventCancelMigrationBucketAmino {
    /**
     * The address of the operator that canceled the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator?: string;
    /** The name of the bucket to be migrated */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
}
export interface EventCancelMigrationBucketAminoMsg {
    type: "/greenfield.storage.EventCancelMigrationBucket";
    value: EventCancelMigrationBucketAmino;
}
export interface EventCancelMigrationBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
}
export interface EventRejectMigrateBucket {
    /** The address of the operator that reject the bucket migration, must be the dest SP */
    operator: string;
    /** The name of the bucket to be migrated */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
}
export interface EventRejectMigrateBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventRejectMigrateBucket";
    value: Uint8Array;
}
export interface EventRejectMigrateBucketAmino {
    /** The address of the operator that reject the bucket migration, must be the dest SP */
    operator?: string;
    /** The name of the bucket to be migrated */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
}
export interface EventRejectMigrateBucketAminoMsg {
    type: "/greenfield.storage.EventRejectMigrateBucket";
    value: EventRejectMigrateBucketAmino;
}
export interface EventRejectMigrateBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
}
export interface EventCompleteMigrationBucket {
    /**
     * The address of the operator that initiated the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator: string;
    /** The name of the bucket to be migrated */
    bucketName: string;
    /** bucket_id define an u256 id for bucket */
    bucketId: string;
    /** The family id that the bucket to be migrated to */
    globalVirtualGroupFamilyId: number;
    /** The src_primary_sp_id defines the primary sp id of the bucket before migrate. */
    srcPrimarySpId: number;
}
export interface EventCompleteMigrationBucketProtoMsg {
    typeUrl: "/greenfield.storage.EventCompleteMigrationBucket";
    value: Uint8Array;
}
export interface EventCompleteMigrationBucketAmino {
    /**
     * The address of the operator that initiated the bucket migration,
     * usually the owner of the bucket or another account which has permission to operate
     */
    operator?: string;
    /** The name of the bucket to be migrated */
    bucket_name?: string;
    /** bucket_id define an u256 id for bucket */
    bucket_id?: string;
    /** The family id that the bucket to be migrated to */
    global_virtual_group_family_id?: number;
    /** The src_primary_sp_id defines the primary sp id of the bucket before migrate. */
    src_primary_sp_id?: number;
}
export interface EventCompleteMigrationBucketAminoMsg {
    type: "/greenfield.storage.EventCompleteMigrationBucket";
    value: EventCompleteMigrationBucketAmino;
}
export interface EventCompleteMigrationBucketSDKType {
    operator: string;
    bucket_name: string;
    bucket_id: string;
    global_virtual_group_family_id: number;
    src_primary_sp_id: number;
}
export interface EventSetTag {
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource: string;
    /** tags define the tag of the source */
    tags?: ResourceTags;
}
export interface EventSetTagProtoMsg {
    typeUrl: "/greenfield.storage.EventSetTag";
    value: Uint8Array;
}
export interface EventSetTagAmino {
    /** resource defines a greenfield standard resource name that can be generated by GRN structure */
    resource?: string;
    /** tags define the tag of the source */
    tags?: ResourceTagsAmino;
}
export interface EventSetTagAminoMsg {
    type: "/greenfield.storage.EventSetTag";
    value: EventSetTagAmino;
}
export interface EventSetTagSDKType {
    resource: string;
    tags?: ResourceTagsSDKType;
}
export declare const EventCreateBucket: {
    typeUrl: string;
    encode(message: EventCreateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateBucket;
    fromJSON(object: any): EventCreateBucket;
    toJSON(message: EventCreateBucket): unknown;
    fromPartial<I extends {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        createAt?: string | number | Long.Long;
        bucketId?: string;
        sourceType?: SourceType;
        chargedReadQuota?: string | number | Long.Long;
        paymentAddress?: string;
        primarySpId?: number;
        globalVirtualGroupFamilyId?: number;
        status?: BucketStatus;
    } & {
        owner?: string;
        bucketName?: string;
        visibility?: VisibilityType;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        bucketId?: string;
        sourceType?: SourceType;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>);
        paymentAddress?: string;
        primarySpId?: number;
        globalVirtualGroupFamilyId?: number;
        status?: BucketStatus;
    } & Record<Exclude<keyof I, keyof EventCreateBucket>, never>>(object: I): EventCreateBucket;
    fromSDK(object: EventCreateBucketSDKType): EventCreateBucket;
    toSDK(message: EventCreateBucket): EventCreateBucketSDKType;
    fromAmino(object: EventCreateBucketAmino): EventCreateBucket;
    toAmino(message: EventCreateBucket): EventCreateBucketAmino;
    fromAminoMsg(object: EventCreateBucketAminoMsg): EventCreateBucket;
    fromProtoMsg(message: EventCreateBucketProtoMsg): EventCreateBucket;
    toProto(message: EventCreateBucket): Uint8Array;
    toProtoMsg(message: EventCreateBucket): EventCreateBucketProtoMsg;
};
export declare const EventDeleteBucket: {
    typeUrl: string;
    encode(message: EventDeleteBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteBucket;
    fromJSON(object: any): EventDeleteBucket;
    toJSON(message: EventDeleteBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
    } & {
        operator?: string;
        owner?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
    } & Record<Exclude<keyof I, keyof EventDeleteBucket>, never>>(object: I): EventDeleteBucket;
    fromSDK(object: EventDeleteBucketSDKType): EventDeleteBucket;
    toSDK(message: EventDeleteBucket): EventDeleteBucketSDKType;
    fromAmino(object: EventDeleteBucketAmino): EventDeleteBucket;
    toAmino(message: EventDeleteBucket): EventDeleteBucketAmino;
    fromAminoMsg(object: EventDeleteBucketAminoMsg): EventDeleteBucket;
    fromProtoMsg(message: EventDeleteBucketProtoMsg): EventDeleteBucket;
    toProto(message: EventDeleteBucket): Uint8Array;
    toProtoMsg(message: EventDeleteBucket): EventDeleteBucketProtoMsg;
};
export declare const EventUpdateBucketInfo: {
    typeUrl: string;
    encode(message: EventUpdateBucketInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateBucketInfo;
    fromJSON(object: any): EventUpdateBucketInfo;
    toJSON(message: EventUpdateBucketInfo): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        chargedReadQuota?: string | number | Long.Long;
        paymentAddress?: string;
        visibility?: VisibilityType;
        globalVirtualGroupFamilyId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        chargedReadQuota?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["chargedReadQuota"], keyof Long.Long>, never>);
        paymentAddress?: string;
        visibility?: VisibilityType;
        globalVirtualGroupFamilyId?: number;
    } & Record<Exclude<keyof I, keyof EventUpdateBucketInfo>, never>>(object: I): EventUpdateBucketInfo;
    fromSDK(object: EventUpdateBucketInfoSDKType): EventUpdateBucketInfo;
    toSDK(message: EventUpdateBucketInfo): EventUpdateBucketInfoSDKType;
    fromAmino(object: EventUpdateBucketInfoAmino): EventUpdateBucketInfo;
    toAmino(message: EventUpdateBucketInfo): EventUpdateBucketInfoAmino;
    fromAminoMsg(object: EventUpdateBucketInfoAminoMsg): EventUpdateBucketInfo;
    fromProtoMsg(message: EventUpdateBucketInfoProtoMsg): EventUpdateBucketInfo;
    toProto(message: EventUpdateBucketInfo): Uint8Array;
    toProtoMsg(message: EventUpdateBucketInfo): EventUpdateBucketInfoProtoMsg;
};
export declare const EventDiscontinueBucket: {
    typeUrl: string;
    encode(message: EventDiscontinueBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDiscontinueBucket;
    fromJSON(object: any): EventDiscontinueBucket;
    toJSON(message: EventDiscontinueBucket): unknown;
    fromPartial<I extends {
        bucketId?: string;
        bucketName?: string;
        reason?: string;
        deleteAt?: string | number | Long.Long;
    } & {
        bucketId?: string;
        bucketName?: string;
        reason?: string;
        deleteAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["deleteAt"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof EventDiscontinueBucket>, never>>(object: I): EventDiscontinueBucket;
    fromSDK(object: EventDiscontinueBucketSDKType): EventDiscontinueBucket;
    toSDK(message: EventDiscontinueBucket): EventDiscontinueBucketSDKType;
    fromAmino(object: EventDiscontinueBucketAmino): EventDiscontinueBucket;
    toAmino(message: EventDiscontinueBucket): EventDiscontinueBucketAmino;
    fromAminoMsg(object: EventDiscontinueBucketAminoMsg): EventDiscontinueBucket;
    fromProtoMsg(message: EventDiscontinueBucketProtoMsg): EventDiscontinueBucket;
    toProto(message: EventDiscontinueBucket): Uint8Array;
    toProtoMsg(message: EventDiscontinueBucket): EventDiscontinueBucketProtoMsg;
};
export declare const EventCreateObject: {
    typeUrl: string;
    encode(message: EventCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateObject;
    fromJSON(object: any): EventCreateObject;
    toJSON(message: EventCreateObject): unknown;
    fromPartial<I extends {
        creator?: string;
        owner?: string;
        bucketName?: string;
        objectName?: string;
        bucketId?: string;
        objectId?: string;
        primarySpId?: number;
        payloadSize?: string | number | Long.Long;
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | Long.Long;
        status?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[];
        localVirtualGroupId?: number;
    } & {
        creator?: string;
        owner?: string;
        bucketName?: string;
        objectName?: string;
        bucketId?: string;
        objectId?: string;
        primarySpId?: number;
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>);
        visibility?: VisibilityType;
        contentType?: string;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        status?: ObjectStatus;
        redundancyType?: RedundancyType;
        sourceType?: SourceType;
        checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["checksums"], keyof Uint8Array[]>, never>;
        localVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof EventCreateObject>, never>>(object: I): EventCreateObject;
    fromSDK(object: EventCreateObjectSDKType): EventCreateObject;
    toSDK(message: EventCreateObject): EventCreateObjectSDKType;
    fromAmino(object: EventCreateObjectAmino): EventCreateObject;
    toAmino(message: EventCreateObject): EventCreateObjectAmino;
    fromAminoMsg(object: EventCreateObjectAminoMsg): EventCreateObject;
    fromProtoMsg(message: EventCreateObjectProtoMsg): EventCreateObject;
    toProto(message: EventCreateObject): Uint8Array;
    toProtoMsg(message: EventCreateObject): EventCreateObjectProtoMsg;
};
export declare const EventCancelCreateObject: {
    typeUrl: string;
    encode(message: EventCancelCreateObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCancelCreateObject;
    fromJSON(object: any): EventCancelCreateObject;
    toJSON(message: EventCancelCreateObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        primarySpId?: number;
        objectId?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        primarySpId?: number;
        objectId?: string;
    } & Record<Exclude<keyof I, keyof EventCancelCreateObject>, never>>(object: I): EventCancelCreateObject;
    fromSDK(object: EventCancelCreateObjectSDKType): EventCancelCreateObject;
    toSDK(message: EventCancelCreateObject): EventCancelCreateObjectSDKType;
    fromAmino(object: EventCancelCreateObjectAmino): EventCancelCreateObject;
    toAmino(message: EventCancelCreateObject): EventCancelCreateObjectAmino;
    fromAminoMsg(object: EventCancelCreateObjectAminoMsg): EventCancelCreateObject;
    fromProtoMsg(message: EventCancelCreateObjectProtoMsg): EventCancelCreateObject;
    toProto(message: EventCancelCreateObject): Uint8Array;
    toProtoMsg(message: EventCancelCreateObject): EventCancelCreateObjectProtoMsg;
};
export declare const EventSealObject: {
    typeUrl: string;
    encode(message: EventSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSealObject;
    fromJSON(object: any): EventSealObject;
    toJSON(message: EventSealObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        status?: ObjectStatus;
        globalVirtualGroupId?: number;
        localVirtualGroupId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        status?: ObjectStatus;
        globalVirtualGroupId?: number;
        localVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof EventSealObject>, never>>(object: I): EventSealObject;
    fromSDK(object: EventSealObjectSDKType): EventSealObject;
    toSDK(message: EventSealObject): EventSealObjectSDKType;
    fromAmino(object: EventSealObjectAmino): EventSealObject;
    toAmino(message: EventSealObject): EventSealObjectAmino;
    fromAminoMsg(object: EventSealObjectAminoMsg): EventSealObject;
    fromProtoMsg(message: EventSealObjectProtoMsg): EventSealObject;
    toProto(message: EventSealObject): Uint8Array;
    toProtoMsg(message: EventSealObject): EventSealObjectProtoMsg;
};
export declare const EventCopyObject: {
    typeUrl: string;
    encode(message: EventCopyObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCopyObject;
    fromJSON(object: any): EventCopyObject;
    toJSON(message: EventCopyObject): unknown;
    fromPartial<I extends {
        operator?: string;
        srcBucketName?: string;
        srcObjectName?: string;
        dstBucketName?: string;
        dstObjectName?: string;
        srcObjectId?: string;
        dstObjectId?: string;
        localVirtualGroupId?: number;
    } & {
        operator?: string;
        srcBucketName?: string;
        srcObjectName?: string;
        dstBucketName?: string;
        dstObjectName?: string;
        srcObjectId?: string;
        dstObjectId?: string;
        localVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof EventCopyObject>, never>>(object: I): EventCopyObject;
    fromSDK(object: EventCopyObjectSDKType): EventCopyObject;
    toSDK(message: EventCopyObject): EventCopyObjectSDKType;
    fromAmino(object: EventCopyObjectAmino): EventCopyObject;
    toAmino(message: EventCopyObject): EventCopyObjectAmino;
    fromAminoMsg(object: EventCopyObjectAminoMsg): EventCopyObject;
    fromProtoMsg(message: EventCopyObjectProtoMsg): EventCopyObject;
    toProto(message: EventCopyObject): Uint8Array;
    toProtoMsg(message: EventCopyObject): EventCopyObjectProtoMsg;
};
export declare const EventDeleteObject: {
    typeUrl: string;
    encode(message: EventDeleteObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteObject;
    fromJSON(object: any): EventDeleteObject;
    toJSON(message: EventDeleteObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        localVirtualGroupId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        localVirtualGroupId?: number;
    } & Record<Exclude<keyof I, keyof EventDeleteObject>, never>>(object: I): EventDeleteObject;
    fromSDK(object: EventDeleteObjectSDKType): EventDeleteObject;
    toSDK(message: EventDeleteObject): EventDeleteObjectSDKType;
    fromAmino(object: EventDeleteObjectAmino): EventDeleteObject;
    toAmino(message: EventDeleteObject): EventDeleteObjectAmino;
    fromAminoMsg(object: EventDeleteObjectAminoMsg): EventDeleteObject;
    fromProtoMsg(message: EventDeleteObjectProtoMsg): EventDeleteObject;
    toProto(message: EventDeleteObject): Uint8Array;
    toProtoMsg(message: EventDeleteObject): EventDeleteObjectProtoMsg;
};
export declare const EventRejectSealObject: {
    typeUrl: string;
    encode(message: EventRejectSealObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRejectSealObject;
    fromJSON(object: any): EventRejectSealObject;
    toJSON(message: EventRejectSealObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
    } & Record<Exclude<keyof I, keyof EventRejectSealObject>, never>>(object: I): EventRejectSealObject;
    fromSDK(object: EventRejectSealObjectSDKType): EventRejectSealObject;
    toSDK(message: EventRejectSealObject): EventRejectSealObjectSDKType;
    fromAmino(object: EventRejectSealObjectAmino): EventRejectSealObject;
    toAmino(message: EventRejectSealObject): EventRejectSealObjectAmino;
    fromAminoMsg(object: EventRejectSealObjectAminoMsg): EventRejectSealObject;
    fromProtoMsg(message: EventRejectSealObjectProtoMsg): EventRejectSealObject;
    toProto(message: EventRejectSealObject): Uint8Array;
    toProtoMsg(message: EventRejectSealObject): EventRejectSealObjectProtoMsg;
};
export declare const EventDiscontinueObject: {
    typeUrl: string;
    encode(message: EventDiscontinueObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDiscontinueObject;
    fromJSON(object: any): EventDiscontinueObject;
    toJSON(message: EventDiscontinueObject): unknown;
    fromPartial<I extends {
        bucketName?: string;
        objectId?: string;
        reason?: string;
        deleteAt?: string | number | Long.Long;
    } & {
        bucketName?: string;
        objectId?: string;
        reason?: string;
        deleteAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["deleteAt"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof EventDiscontinueObject>, never>>(object: I): EventDiscontinueObject;
    fromSDK(object: EventDiscontinueObjectSDKType): EventDiscontinueObject;
    toSDK(message: EventDiscontinueObject): EventDiscontinueObjectSDKType;
    fromAmino(object: EventDiscontinueObjectAmino): EventDiscontinueObject;
    toAmino(message: EventDiscontinueObject): EventDiscontinueObjectAmino;
    fromAminoMsg(object: EventDiscontinueObjectAminoMsg): EventDiscontinueObject;
    fromProtoMsg(message: EventDiscontinueObjectProtoMsg): EventDiscontinueObject;
    toProto(message: EventDiscontinueObject): Uint8Array;
    toProtoMsg(message: EventDiscontinueObject): EventDiscontinueObjectProtoMsg;
};
export declare const EventUpdateObjectInfo: {
    typeUrl: string;
    encode(message: EventUpdateObjectInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateObjectInfo;
    fromJSON(object: any): EventUpdateObjectInfo;
    toJSON(message: EventUpdateObjectInfo): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        visibility?: VisibilityType;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        visibility?: VisibilityType;
    } & Record<Exclude<keyof I, keyof EventUpdateObjectInfo>, never>>(object: I): EventUpdateObjectInfo;
    fromSDK(object: EventUpdateObjectInfoSDKType): EventUpdateObjectInfo;
    toSDK(message: EventUpdateObjectInfo): EventUpdateObjectInfoSDKType;
    fromAmino(object: EventUpdateObjectInfoAmino): EventUpdateObjectInfo;
    toAmino(message: EventUpdateObjectInfo): EventUpdateObjectInfoAmino;
    fromAminoMsg(object: EventUpdateObjectInfoAminoMsg): EventUpdateObjectInfo;
    fromProtoMsg(message: EventUpdateObjectInfoProtoMsg): EventUpdateObjectInfo;
    toProto(message: EventUpdateObjectInfo): Uint8Array;
    toProtoMsg(message: EventUpdateObjectInfo): EventUpdateObjectInfoProtoMsg;
};
export declare const EventCreateGroup: {
    typeUrl: string;
    encode(message: EventCreateGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCreateGroup;
    fromJSON(object: any): EventCreateGroup;
    toJSON(message: EventCreateGroup): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        extra?: string;
    } & {
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        extra?: string;
    } & Record<Exclude<keyof I, keyof EventCreateGroup>, never>>(object: I): EventCreateGroup;
    fromSDK(object: EventCreateGroupSDKType): EventCreateGroup;
    toSDK(message: EventCreateGroup): EventCreateGroupSDKType;
    fromAmino(object: EventCreateGroupAmino): EventCreateGroup;
    toAmino(message: EventCreateGroup): EventCreateGroupAmino;
    fromAminoMsg(object: EventCreateGroupAminoMsg): EventCreateGroup;
    fromProtoMsg(message: EventCreateGroupProtoMsg): EventCreateGroup;
    toProto(message: EventCreateGroup): Uint8Array;
    toProtoMsg(message: EventCreateGroup): EventCreateGroupProtoMsg;
};
export declare const EventDeleteGroup: {
    typeUrl: string;
    encode(message: EventDeleteGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventDeleteGroup;
    fromJSON(object: any): EventDeleteGroup;
    toJSON(message: EventDeleteGroup): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & {
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & Record<Exclude<keyof I, keyof EventDeleteGroup>, never>>(object: I): EventDeleteGroup;
    fromSDK(object: EventDeleteGroupSDKType): EventDeleteGroup;
    toSDK(message: EventDeleteGroup): EventDeleteGroupSDKType;
    fromAmino(object: EventDeleteGroupAmino): EventDeleteGroup;
    toAmino(message: EventDeleteGroup): EventDeleteGroupAmino;
    fromAminoMsg(object: EventDeleteGroupAminoMsg): EventDeleteGroup;
    fromProtoMsg(message: EventDeleteGroupProtoMsg): EventDeleteGroup;
    toProto(message: EventDeleteGroup): Uint8Array;
    toProtoMsg(message: EventDeleteGroup): EventDeleteGroupProtoMsg;
};
export declare const EventLeaveGroup: {
    typeUrl: string;
    encode(message: EventLeaveGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventLeaveGroup;
    fromJSON(object: any): EventLeaveGroup;
    toJSON(message: EventLeaveGroup): unknown;
    fromPartial<I extends {
        memberAddress?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & {
        memberAddress?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
    } & Record<Exclude<keyof I, keyof EventLeaveGroup>, never>>(object: I): EventLeaveGroup;
    fromSDK(object: EventLeaveGroupSDKType): EventLeaveGroup;
    toSDK(message: EventLeaveGroup): EventLeaveGroupSDKType;
    fromAmino(object: EventLeaveGroupAmino): EventLeaveGroup;
    toAmino(message: EventLeaveGroup): EventLeaveGroupAmino;
    fromAminoMsg(object: EventLeaveGroupAminoMsg): EventLeaveGroup;
    fromProtoMsg(message: EventLeaveGroupProtoMsg): EventLeaveGroup;
    toProto(message: EventLeaveGroup): Uint8Array;
    toProtoMsg(message: EventLeaveGroup): EventLeaveGroupProtoMsg;
};
export declare const EventUpdateGroupMember: {
    typeUrl: string;
    encode(message: EventUpdateGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateGroupMember;
    fromJSON(object: any): EventUpdateGroupMember;
    toJSON(message: EventUpdateGroupMember): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        membersToAdd?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[];
        membersToDelete?: string[];
    } & {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        membersToAdd?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[] & ({
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["membersToAdd"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["membersToAdd"][number]["expirationTime"], keyof Timestamp>, never>;
        } & Record<Exclude<keyof I["membersToAdd"][number], keyof EventGroupMemberDetail>, never>)[] & Record<Exclude<keyof I["membersToAdd"], keyof {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[]>, never>;
        membersToDelete?: string[] & string[] & Record<Exclude<keyof I["membersToDelete"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, keyof EventUpdateGroupMember>, never>>(object: I): EventUpdateGroupMember;
    fromSDK(object: EventUpdateGroupMemberSDKType): EventUpdateGroupMember;
    toSDK(message: EventUpdateGroupMember): EventUpdateGroupMemberSDKType;
    fromAmino(object: EventUpdateGroupMemberAmino): EventUpdateGroupMember;
    toAmino(message: EventUpdateGroupMember): EventUpdateGroupMemberAmino;
    fromAminoMsg(object: EventUpdateGroupMemberAminoMsg): EventUpdateGroupMember;
    fromProtoMsg(message: EventUpdateGroupMemberProtoMsg): EventUpdateGroupMember;
    toProto(message: EventUpdateGroupMember): Uint8Array;
    toProtoMsg(message: EventUpdateGroupMember): EventUpdateGroupMemberProtoMsg;
};
export declare const EventRenewGroupMember: {
    typeUrl: string;
    encode(message: EventRenewGroupMember, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRenewGroupMember;
    fromJSON(object: any): EventRenewGroupMember;
    toJSON(message: EventRenewGroupMember): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        members?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[];
    } & {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        sourceType?: SourceType;
        members?: {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[] & ({
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["members"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["members"][number]["expirationTime"], keyof Timestamp>, never>;
        } & Record<Exclude<keyof I["members"][number], keyof EventGroupMemberDetail>, never>)[] & Record<Exclude<keyof I["members"], keyof {
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof EventRenewGroupMember>, never>>(object: I): EventRenewGroupMember;
    fromSDK(object: EventRenewGroupMemberSDKType): EventRenewGroupMember;
    toSDK(message: EventRenewGroupMember): EventRenewGroupMemberSDKType;
    fromAmino(object: EventRenewGroupMemberAmino): EventRenewGroupMember;
    toAmino(message: EventRenewGroupMember): EventRenewGroupMemberAmino;
    fromAminoMsg(object: EventRenewGroupMemberAminoMsg): EventRenewGroupMember;
    fromProtoMsg(message: EventRenewGroupMemberProtoMsg): EventRenewGroupMember;
    toProto(message: EventRenewGroupMember): Uint8Array;
    toProtoMsg(message: EventRenewGroupMember): EventRenewGroupMemberProtoMsg;
};
export declare const EventGroupMemberDetail: {
    typeUrl: string;
    encode(message: EventGroupMemberDetail, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventGroupMemberDetail;
    fromJSON(object: any): EventGroupMemberDetail;
    toJSON(message: EventGroupMemberDetail): unknown;
    fromPartial<I extends {
        member?: string;
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        };
    } & {
        member?: string;
        expirationTime?: {
            seconds?: string | number | Long.Long;
            nanos?: number;
        } & {
            seconds?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["expirationTime"]["seconds"], keyof Long.Long>, never>);
            nanos?: number;
        } & Record<Exclude<keyof I["expirationTime"], keyof Timestamp>, never>;
    } & Record<Exclude<keyof I, keyof EventGroupMemberDetail>, never>>(object: I): EventGroupMemberDetail;
    fromSDK(object: EventGroupMemberDetailSDKType): EventGroupMemberDetail;
    toSDK(message: EventGroupMemberDetail): EventGroupMemberDetailSDKType;
    fromAmino(object: EventGroupMemberDetailAmino): EventGroupMemberDetail;
    toAmino(message: EventGroupMemberDetail): EventGroupMemberDetailAmino;
    fromAminoMsg(object: EventGroupMemberDetailAminoMsg): EventGroupMemberDetail;
    fromProtoMsg(message: EventGroupMemberDetailProtoMsg): EventGroupMemberDetail;
    toProto(message: EventGroupMemberDetail): Uint8Array;
    toProtoMsg(message: EventGroupMemberDetail): EventGroupMemberDetailProtoMsg;
};
export declare const EventUpdateGroupExtra: {
    typeUrl: string;
    encode(message: EventUpdateGroupExtra, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventUpdateGroupExtra;
    fromJSON(object: any): EventUpdateGroupExtra;
    toJSON(message: EventUpdateGroupExtra): unknown;
    fromPartial<I extends {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        extra?: string;
    } & {
        operator?: string;
        owner?: string;
        groupName?: string;
        groupId?: string;
        extra?: string;
    } & Record<Exclude<keyof I, keyof EventUpdateGroupExtra>, never>>(object: I): EventUpdateGroupExtra;
    fromSDK(object: EventUpdateGroupExtraSDKType): EventUpdateGroupExtra;
    toSDK(message: EventUpdateGroupExtra): EventUpdateGroupExtraSDKType;
    fromAmino(object: EventUpdateGroupExtraAmino): EventUpdateGroupExtra;
    toAmino(message: EventUpdateGroupExtra): EventUpdateGroupExtraAmino;
    fromAminoMsg(object: EventUpdateGroupExtraAminoMsg): EventUpdateGroupExtra;
    fromProtoMsg(message: EventUpdateGroupExtraProtoMsg): EventUpdateGroupExtra;
    toProto(message: EventUpdateGroupExtra): Uint8Array;
    toProtoMsg(message: EventUpdateGroupExtra): EventUpdateGroupExtraProtoMsg;
};
export declare const EventMirrorBucket: {
    typeUrl: string;
    encode(message: EventMirrorBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorBucket;
    fromJSON(object: any): EventMirrorBucket;
    toJSON(message: EventMirrorBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorBucket>, never>>(object: I): EventMirrorBucket;
    fromSDK(object: EventMirrorBucketSDKType): EventMirrorBucket;
    toSDK(message: EventMirrorBucket): EventMirrorBucketSDKType;
    fromAmino(object: EventMirrorBucketAmino): EventMirrorBucket;
    toAmino(message: EventMirrorBucket): EventMirrorBucketAmino;
    fromAminoMsg(object: EventMirrorBucketAminoMsg): EventMirrorBucket;
    fromProtoMsg(message: EventMirrorBucketProtoMsg): EventMirrorBucket;
    toProto(message: EventMirrorBucket): Uint8Array;
    toProtoMsg(message: EventMirrorBucket): EventMirrorBucketProtoMsg;
};
export declare const EventMirrorBucketResult: {
    typeUrl: string;
    encode(message: EventMirrorBucketResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorBucketResult;
    fromJSON(object: any): EventMirrorBucketResult;
    toJSON(message: EventMirrorBucketResult): unknown;
    fromPartial<I extends {
        status?: number;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & {
        status?: number;
        bucketName?: string;
        bucketId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorBucketResult>, never>>(object: I): EventMirrorBucketResult;
    fromSDK(object: EventMirrorBucketResultSDKType): EventMirrorBucketResult;
    toSDK(message: EventMirrorBucketResult): EventMirrorBucketResultSDKType;
    fromAmino(object: EventMirrorBucketResultAmino): EventMirrorBucketResult;
    toAmino(message: EventMirrorBucketResult): EventMirrorBucketResultAmino;
    fromAminoMsg(object: EventMirrorBucketResultAminoMsg): EventMirrorBucketResult;
    fromProtoMsg(message: EventMirrorBucketResultProtoMsg): EventMirrorBucketResult;
    toProto(message: EventMirrorBucketResult): Uint8Array;
    toProtoMsg(message: EventMirrorBucketResult): EventMirrorBucketResultProtoMsg;
};
export declare const EventMirrorObject: {
    typeUrl: string;
    encode(message: EventMirrorObject, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorObject;
    fromJSON(object: any): EventMirrorObject;
    toJSON(message: EventMirrorObject): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorObject>, never>>(object: I): EventMirrorObject;
    fromSDK(object: EventMirrorObjectSDKType): EventMirrorObject;
    toSDK(message: EventMirrorObject): EventMirrorObjectSDKType;
    fromAmino(object: EventMirrorObjectAmino): EventMirrorObject;
    toAmino(message: EventMirrorObject): EventMirrorObjectAmino;
    fromAminoMsg(object: EventMirrorObjectAminoMsg): EventMirrorObject;
    fromProtoMsg(message: EventMirrorObjectProtoMsg): EventMirrorObject;
    toProto(message: EventMirrorObject): Uint8Array;
    toProtoMsg(message: EventMirrorObject): EventMirrorObjectProtoMsg;
};
export declare const EventMirrorObjectResult: {
    typeUrl: string;
    encode(message: EventMirrorObjectResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorObjectResult;
    fromJSON(object: any): EventMirrorObjectResult;
    toJSON(message: EventMirrorObjectResult): unknown;
    fromPartial<I extends {
        status?: number;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & {
        status?: number;
        bucketName?: string;
        objectName?: string;
        objectId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorObjectResult>, never>>(object: I): EventMirrorObjectResult;
    fromSDK(object: EventMirrorObjectResultSDKType): EventMirrorObjectResult;
    toSDK(message: EventMirrorObjectResult): EventMirrorObjectResultSDKType;
    fromAmino(object: EventMirrorObjectResultAmino): EventMirrorObjectResult;
    toAmino(message: EventMirrorObjectResult): EventMirrorObjectResultAmino;
    fromAminoMsg(object: EventMirrorObjectResultAminoMsg): EventMirrorObjectResult;
    fromProtoMsg(message: EventMirrorObjectResultProtoMsg): EventMirrorObjectResult;
    toProto(message: EventMirrorObjectResult): Uint8Array;
    toProtoMsg(message: EventMirrorObjectResult): EventMirrorObjectResultProtoMsg;
};
export declare const EventMirrorGroup: {
    typeUrl: string;
    encode(message: EventMirrorGroup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorGroup;
    fromJSON(object: any): EventMirrorGroup;
    toJSON(message: EventMirrorGroup): unknown;
    fromPartial<I extends {
        owner?: string;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & {
        owner?: string;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorGroup>, never>>(object: I): EventMirrorGroup;
    fromSDK(object: EventMirrorGroupSDKType): EventMirrorGroup;
    toSDK(message: EventMirrorGroup): EventMirrorGroupSDKType;
    fromAmino(object: EventMirrorGroupAmino): EventMirrorGroup;
    toAmino(message: EventMirrorGroup): EventMirrorGroupAmino;
    fromAminoMsg(object: EventMirrorGroupAminoMsg): EventMirrorGroup;
    fromProtoMsg(message: EventMirrorGroupProtoMsg): EventMirrorGroup;
    toProto(message: EventMirrorGroup): Uint8Array;
    toProtoMsg(message: EventMirrorGroup): EventMirrorGroupProtoMsg;
};
export declare const EventMirrorGroupResult: {
    typeUrl: string;
    encode(message: EventMirrorGroupResult, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMirrorGroupResult;
    fromJSON(object: any): EventMirrorGroupResult;
    toJSON(message: EventMirrorGroupResult): unknown;
    fromPartial<I extends {
        status?: number;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & {
        status?: number;
        groupName?: string;
        groupId?: string;
        destChainId?: number;
    } & Record<Exclude<keyof I, keyof EventMirrorGroupResult>, never>>(object: I): EventMirrorGroupResult;
    fromSDK(object: EventMirrorGroupResultSDKType): EventMirrorGroupResult;
    toSDK(message: EventMirrorGroupResult): EventMirrorGroupResultSDKType;
    fromAmino(object: EventMirrorGroupResultAmino): EventMirrorGroupResult;
    toAmino(message: EventMirrorGroupResult): EventMirrorGroupResultAmino;
    fromAminoMsg(object: EventMirrorGroupResultAminoMsg): EventMirrorGroupResult;
    fromProtoMsg(message: EventMirrorGroupResultProtoMsg): EventMirrorGroupResult;
    toProto(message: EventMirrorGroupResult): Uint8Array;
    toProtoMsg(message: EventMirrorGroupResult): EventMirrorGroupResultProtoMsg;
};
export declare const EventStalePolicyCleanup: {
    typeUrl: string;
    encode(message: EventStalePolicyCleanup, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventStalePolicyCleanup;
    fromJSON(object: any): EventStalePolicyCleanup;
    toJSON(message: EventStalePolicyCleanup): unknown;
    fromPartial<I extends {
        blockNum?: string | number | Long.Long;
        deleteInfo?: {
            bucketIds?: {
                id?: string[];
            };
            objectIds?: {
                id?: string[];
            };
            groupIds?: {
                id?: string[];
            };
        };
    } & {
        blockNum?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["blockNum"], keyof Long.Long>, never>);
        deleteInfo?: {
            bucketIds?: {
                id?: string[];
            };
            objectIds?: {
                id?: string[];
            };
            groupIds?: {
                id?: string[];
            };
        } & {
            bucketIds?: {
                id?: string[];
            } & {
                id?: string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["bucketIds"]["id"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["deleteInfo"]["bucketIds"], "id">, never>;
            objectIds?: {
                id?: string[];
            } & {
                id?: string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["objectIds"]["id"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["deleteInfo"]["objectIds"], "id">, never>;
            groupIds?: {
                id?: string[];
            } & {
                id?: string[] & string[] & Record<Exclude<keyof I["deleteInfo"]["groupIds"]["id"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["deleteInfo"]["groupIds"], "id">, never>;
        } & Record<Exclude<keyof I["deleteInfo"], keyof DeleteInfo>, never>;
    } & Record<Exclude<keyof I, keyof EventStalePolicyCleanup>, never>>(object: I): EventStalePolicyCleanup;
    fromSDK(object: EventStalePolicyCleanupSDKType): EventStalePolicyCleanup;
    toSDK(message: EventStalePolicyCleanup): EventStalePolicyCleanupSDKType;
    fromAmino(object: EventStalePolicyCleanupAmino): EventStalePolicyCleanup;
    toAmino(message: EventStalePolicyCleanup): EventStalePolicyCleanupAmino;
    fromAminoMsg(object: EventStalePolicyCleanupAminoMsg): EventStalePolicyCleanup;
    fromProtoMsg(message: EventStalePolicyCleanupProtoMsg): EventStalePolicyCleanup;
    toProto(message: EventStalePolicyCleanup): Uint8Array;
    toProtoMsg(message: EventStalePolicyCleanup): EventStalePolicyCleanupProtoMsg;
};
export declare const EventMigrationBucket: {
    typeUrl: string;
    encode(message: EventMigrationBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventMigrationBucket;
    fromJSON(object: any): EventMigrationBucket;
    toJSON(message: EventMigrationBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        dstPrimarySpId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        dstPrimarySpId?: number;
    } & Record<Exclude<keyof I, keyof EventMigrationBucket>, never>>(object: I): EventMigrationBucket;
    fromSDK(object: EventMigrationBucketSDKType): EventMigrationBucket;
    toSDK(message: EventMigrationBucket): EventMigrationBucketSDKType;
    fromAmino(object: EventMigrationBucketAmino): EventMigrationBucket;
    toAmino(message: EventMigrationBucket): EventMigrationBucketAmino;
    fromAminoMsg(object: EventMigrationBucketAminoMsg): EventMigrationBucket;
    fromProtoMsg(message: EventMigrationBucketProtoMsg): EventMigrationBucket;
    toProto(message: EventMigrationBucket): Uint8Array;
    toProtoMsg(message: EventMigrationBucket): EventMigrationBucketProtoMsg;
};
export declare const EventCancelMigrationBucket: {
    typeUrl: string;
    encode(message: EventCancelMigrationBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCancelMigrationBucket;
    fromJSON(object: any): EventCancelMigrationBucket;
    toJSON(message: EventCancelMigrationBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
    } & Record<Exclude<keyof I, keyof EventCancelMigrationBucket>, never>>(object: I): EventCancelMigrationBucket;
    fromSDK(object: EventCancelMigrationBucketSDKType): EventCancelMigrationBucket;
    toSDK(message: EventCancelMigrationBucket): EventCancelMigrationBucketSDKType;
    fromAmino(object: EventCancelMigrationBucketAmino): EventCancelMigrationBucket;
    toAmino(message: EventCancelMigrationBucket): EventCancelMigrationBucketAmino;
    fromAminoMsg(object: EventCancelMigrationBucketAminoMsg): EventCancelMigrationBucket;
    fromProtoMsg(message: EventCancelMigrationBucketProtoMsg): EventCancelMigrationBucket;
    toProto(message: EventCancelMigrationBucket): Uint8Array;
    toProtoMsg(message: EventCancelMigrationBucket): EventCancelMigrationBucketProtoMsg;
};
export declare const EventRejectMigrateBucket: {
    typeUrl: string;
    encode(message: EventRejectMigrateBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventRejectMigrateBucket;
    fromJSON(object: any): EventRejectMigrateBucket;
    toJSON(message: EventRejectMigrateBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
    } & Record<Exclude<keyof I, keyof EventRejectMigrateBucket>, never>>(object: I): EventRejectMigrateBucket;
    fromSDK(object: EventRejectMigrateBucketSDKType): EventRejectMigrateBucket;
    toSDK(message: EventRejectMigrateBucket): EventRejectMigrateBucketSDKType;
    fromAmino(object: EventRejectMigrateBucketAmino): EventRejectMigrateBucket;
    toAmino(message: EventRejectMigrateBucket): EventRejectMigrateBucketAmino;
    fromAminoMsg(object: EventRejectMigrateBucketAminoMsg): EventRejectMigrateBucket;
    fromProtoMsg(message: EventRejectMigrateBucketProtoMsg): EventRejectMigrateBucket;
    toProto(message: EventRejectMigrateBucket): Uint8Array;
    toProtoMsg(message: EventRejectMigrateBucket): EventRejectMigrateBucketProtoMsg;
};
export declare const EventCompleteMigrationBucket: {
    typeUrl: string;
    encode(message: EventCompleteMigrationBucket, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventCompleteMigrationBucket;
    fromJSON(object: any): EventCompleteMigrationBucket;
    toJSON(message: EventCompleteMigrationBucket): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
        srcPrimarySpId?: number;
    } & {
        operator?: string;
        bucketName?: string;
        bucketId?: string;
        globalVirtualGroupFamilyId?: number;
        srcPrimarySpId?: number;
    } & Record<Exclude<keyof I, keyof EventCompleteMigrationBucket>, never>>(object: I): EventCompleteMigrationBucket;
    fromSDK(object: EventCompleteMigrationBucketSDKType): EventCompleteMigrationBucket;
    toSDK(message: EventCompleteMigrationBucket): EventCompleteMigrationBucketSDKType;
    fromAmino(object: EventCompleteMigrationBucketAmino): EventCompleteMigrationBucket;
    toAmino(message: EventCompleteMigrationBucket): EventCompleteMigrationBucketAmino;
    fromAminoMsg(object: EventCompleteMigrationBucketAminoMsg): EventCompleteMigrationBucket;
    fromProtoMsg(message: EventCompleteMigrationBucketProtoMsg): EventCompleteMigrationBucket;
    toProto(message: EventCompleteMigrationBucket): Uint8Array;
    toProtoMsg(message: EventCompleteMigrationBucket): EventCompleteMigrationBucketProtoMsg;
};
export declare const EventSetTag: {
    typeUrl: string;
    encode(message: EventSetTag, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): EventSetTag;
    fromJSON(object: any): EventSetTag;
    toJSON(message: EventSetTag): unknown;
    fromPartial<I extends {
        resource?: string;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        };
    } & {
        resource?: string;
        tags?: {
            tags?: {
                key?: string;
                value?: string;
            }[];
        } & {
            tags?: {
                key?: string;
                value?: string;
            }[] & ({
                key?: string;
                value?: string;
            } & {
                key?: string;
                value?: string;
            } & Record<Exclude<keyof I["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["tags"]["tags"], keyof {
                key?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["tags"], "tags">, never>;
    } & Record<Exclude<keyof I, keyof EventSetTag>, never>>(object: I): EventSetTag;
    fromSDK(object: EventSetTagSDKType): EventSetTag;
    toSDK(message: EventSetTag): EventSetTagSDKType;
    fromAmino(object: EventSetTagAmino): EventSetTag;
    toAmino(message: EventSetTag): EventSetTagAmino;
    fromAminoMsg(object: EventSetTagAminoMsg): EventSetTag;
    fromProtoMsg(message: EventSetTagProtoMsg): EventSetTag;
    toProto(message: EventSetTag): Uint8Array;
    toProtoMsg(message: EventSetTag): EventSetTagProtoMsg;
};
