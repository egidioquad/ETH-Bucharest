/// <reference types="long" />
import { PageRequest, PageRequestAmino, PageRequestSDKType, PageResponse, PageResponseAmino, PageResponseSDKType } from "../../cosmos/base/query/v1beta1/pagination";
import { ActionType, Effect } from "../permission/common";
import { Params, ParamsAmino, ParamsSDKType } from "./params";
import { BucketInfo, BucketInfoAmino, BucketInfoSDKType, ObjectInfo, ObjectInfoAmino, ObjectInfoSDKType, BucketMetaData, BucketMetaDataAmino, BucketMetaDataSDKType, ObjectMetaData, ObjectMetaDataAmino, ObjectMetaDataSDKType, GroupMetaData, GroupMetaDataAmino, GroupMetaDataSDKType, GroupInfo, GroupInfoAmino, GroupInfoSDKType, InternalBucketInfo, InternalBucketInfoAmino, InternalBucketInfoSDKType } from "./types";
import { GlobalVirtualGroup, GlobalVirtualGroupAmino, GlobalVirtualGroupSDKType } from "../virtualgroup/types";
import { Policy, PolicyAmino, PolicySDKType, GroupMember, GroupMemberAmino, GroupMemberSDKType } from "../permission/types";
import { Long, Rpc } from "../../helpers";
import * as _m0 from "protobufjs/minimal";
export declare const protobufPackage = "greenfield.storage";
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}
export interface QueryParamsRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryParamsRequest";
    value: Uint8Array;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestAmino {
}
export interface QueryParamsRequestAminoMsg {
    type: "/greenfield.storage.QueryParamsRequest";
    value: QueryParamsRequestAmino;
}
/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequestSDKType {
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
export interface QueryParamsResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryParamsResponse";
    value: Uint8Array;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseAmino {
    /** params holds all the parameters of this module. */
    params?: ParamsAmino;
}
export interface QueryParamsResponseAminoMsg {
    type: "/greenfield.storage.QueryParamsResponse";
    value: QueryParamsResponseAmino;
}
/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponseSDKType {
    params: ParamsSDKType;
}
/** QueryVersionedParamsRequest is request type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampRequest {
    /** the timestamp of the block time you want to query */
    timestamp: Long;
}
export interface QueryParamsByTimestampRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryParamsByTimestampRequest";
    value: Uint8Array;
}
/** QueryVersionedParamsRequest is request type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampRequestAmino {
    /** the timestamp of the block time you want to query */
    timestamp?: string;
}
export interface QueryParamsByTimestampRequestAminoMsg {
    type: "/greenfield.storage.QueryParamsByTimestampRequest";
    value: QueryParamsByTimestampRequestAmino;
}
/** QueryVersionedParamsRequest is request type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampRequestSDKType {
    timestamp: Long;
}
/** QueryVersionedParamsResponse is response type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampResponse {
    /** params holds all the parameters of this module. */
    params: Params;
}
export interface QueryParamsByTimestampResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryParamsByTimestampResponse";
    value: Uint8Array;
}
/** QueryVersionedParamsResponse is response type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampResponseAmino {
    /** params holds all the parameters of this module. */
    params?: ParamsAmino;
}
export interface QueryParamsByTimestampResponseAminoMsg {
    type: "/greenfield.storage.QueryParamsByTimestampResponse";
    value: QueryParamsByTimestampResponseAmino;
}
/** QueryVersionedParamsResponse is response type for the Query/Params RPC method with timestamp. */
export interface QueryParamsByTimestampResponseSDKType {
    params: ParamsSDKType;
}
export interface QueryHeadBucketRequest {
    bucketName: string;
}
export interface QueryHeadBucketRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadBucketRequest";
    value: Uint8Array;
}
export interface QueryHeadBucketRequestAmino {
    bucket_name?: string;
}
export interface QueryHeadBucketRequestAminoMsg {
    type: "/greenfield.storage.QueryHeadBucketRequest";
    value: QueryHeadBucketRequestAmino;
}
export interface QueryHeadBucketRequestSDKType {
    bucket_name: string;
}
export interface QueryHeadBucketByIdRequest {
    bucketId: string;
}
export interface QueryHeadBucketByIdRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadBucketByIdRequest";
    value: Uint8Array;
}
export interface QueryHeadBucketByIdRequestAmino {
    bucket_id?: string;
}
export interface QueryHeadBucketByIdRequestAminoMsg {
    type: "/greenfield.storage.QueryHeadBucketByIdRequest";
    value: QueryHeadBucketByIdRequestAmino;
}
export interface QueryHeadBucketByIdRequestSDKType {
    bucket_id: string;
}
export interface QueryHeadBucketResponse {
    bucketInfo?: BucketInfo;
}
export interface QueryHeadBucketResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadBucketResponse";
    value: Uint8Array;
}
export interface QueryHeadBucketResponseAmino {
    bucket_info?: BucketInfoAmino;
}
export interface QueryHeadBucketResponseAminoMsg {
    type: "/greenfield.storage.QueryHeadBucketResponse";
    value: QueryHeadBucketResponseAmino;
}
export interface QueryHeadBucketResponseSDKType {
    bucket_info?: BucketInfoSDKType;
}
export interface QueryHeadObjectRequest {
    bucketName: string;
    objectName: string;
}
export interface QueryHeadObjectRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadObjectRequest";
    value: Uint8Array;
}
export interface QueryHeadObjectRequestAmino {
    bucket_name?: string;
    object_name?: string;
}
export interface QueryHeadObjectRequestAminoMsg {
    type: "/greenfield.storage.QueryHeadObjectRequest";
    value: QueryHeadObjectRequestAmino;
}
export interface QueryHeadObjectRequestSDKType {
    bucket_name: string;
    object_name: string;
}
export interface QueryHeadObjectByIdRequest {
    objectId: string;
}
export interface QueryHeadObjectByIdRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadObjectByIdRequest";
    value: Uint8Array;
}
export interface QueryHeadObjectByIdRequestAmino {
    object_id?: string;
}
export interface QueryHeadObjectByIdRequestAminoMsg {
    type: "/greenfield.storage.QueryHeadObjectByIdRequest";
    value: QueryHeadObjectByIdRequestAmino;
}
export interface QueryHeadObjectByIdRequestSDKType {
    object_id: string;
}
export interface QueryHeadObjectResponse {
    objectInfo?: ObjectInfo;
    globalVirtualGroup?: GlobalVirtualGroup;
}
export interface QueryHeadObjectResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadObjectResponse";
    value: Uint8Array;
}
export interface QueryHeadObjectResponseAmino {
    object_info?: ObjectInfoAmino;
    global_virtual_group?: GlobalVirtualGroupAmino;
}
export interface QueryHeadObjectResponseAminoMsg {
    type: "/greenfield.storage.QueryHeadObjectResponse";
    value: QueryHeadObjectResponseAmino;
}
export interface QueryHeadObjectResponseSDKType {
    object_info?: ObjectInfoSDKType;
    global_virtual_group?: GlobalVirtualGroupSDKType;
}
export interface QueryListBucketsRequest {
    pagination?: PageRequest;
}
export interface QueryListBucketsRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryListBucketsRequest";
    value: Uint8Array;
}
export interface QueryListBucketsRequestAmino {
    pagination?: PageRequestAmino;
}
export interface QueryListBucketsRequestAminoMsg {
    type: "/greenfield.storage.QueryListBucketsRequest";
    value: QueryListBucketsRequestAmino;
}
export interface QueryListBucketsRequestSDKType {
    pagination?: PageRequestSDKType;
}
export interface QueryListBucketsResponse {
    bucketInfos: BucketInfo[];
    pagination?: PageResponse;
}
export interface QueryListBucketsResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryListBucketsResponse";
    value: Uint8Array;
}
export interface QueryListBucketsResponseAmino {
    bucket_infos?: BucketInfoAmino[];
    pagination?: PageResponseAmino;
}
export interface QueryListBucketsResponseAminoMsg {
    type: "/greenfield.storage.QueryListBucketsResponse";
    value: QueryListBucketsResponseAmino;
}
export interface QueryListBucketsResponseSDKType {
    bucket_infos: BucketInfoSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryListObjectsRequest {
    pagination?: PageRequest;
    bucketName: string;
}
export interface QueryListObjectsRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryListObjectsRequest";
    value: Uint8Array;
}
export interface QueryListObjectsRequestAmino {
    pagination?: PageRequestAmino;
    bucket_name?: string;
}
export interface QueryListObjectsRequestAminoMsg {
    type: "/greenfield.storage.QueryListObjectsRequest";
    value: QueryListObjectsRequestAmino;
}
export interface QueryListObjectsRequestSDKType {
    pagination?: PageRequestSDKType;
    bucket_name: string;
}
export interface QueryListObjectsByBucketIdRequest {
    pagination?: PageRequest;
    bucketId: string;
}
export interface QueryListObjectsByBucketIdRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryListObjectsByBucketIdRequest";
    value: Uint8Array;
}
export interface QueryListObjectsByBucketIdRequestAmino {
    pagination?: PageRequestAmino;
    bucket_id?: string;
}
export interface QueryListObjectsByBucketIdRequestAminoMsg {
    type: "/greenfield.storage.QueryListObjectsByBucketIdRequest";
    value: QueryListObjectsByBucketIdRequestAmino;
}
export interface QueryListObjectsByBucketIdRequestSDKType {
    pagination?: PageRequestSDKType;
    bucket_id: string;
}
export interface QueryListObjectsResponse {
    objectInfos: ObjectInfo[];
    pagination?: PageResponse;
}
export interface QueryListObjectsResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryListObjectsResponse";
    value: Uint8Array;
}
export interface QueryListObjectsResponseAmino {
    object_infos?: ObjectInfoAmino[];
    pagination?: PageResponseAmino;
}
export interface QueryListObjectsResponseAminoMsg {
    type: "/greenfield.storage.QueryListObjectsResponse";
    value: QueryListObjectsResponseAmino;
}
export interface QueryListObjectsResponseSDKType {
    object_infos: ObjectInfoSDKType[];
    pagination?: PageResponseSDKType;
}
export interface QueryNFTRequest {
    tokenId: string;
}
export interface QueryNFTRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryNFTRequest";
    value: Uint8Array;
}
export interface QueryNFTRequestAmino {
    token_id?: string;
}
export interface QueryNFTRequestAminoMsg {
    type: "/greenfield.storage.QueryNFTRequest";
    value: QueryNFTRequestAmino;
}
export interface QueryNFTRequestSDKType {
    token_id: string;
}
export interface QueryBucketNFTResponse {
    metaData?: BucketMetaData;
}
export interface QueryBucketNFTResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryBucketNFTResponse";
    value: Uint8Array;
}
export interface QueryBucketNFTResponseAmino {
    meta_data?: BucketMetaDataAmino;
}
export interface QueryBucketNFTResponseAminoMsg {
    type: "/greenfield.storage.QueryBucketNFTResponse";
    value: QueryBucketNFTResponseAmino;
}
export interface QueryBucketNFTResponseSDKType {
    meta_data?: BucketMetaDataSDKType;
}
export interface QueryObjectNFTResponse {
    metaData?: ObjectMetaData;
}
export interface QueryObjectNFTResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryObjectNFTResponse";
    value: Uint8Array;
}
export interface QueryObjectNFTResponseAmino {
    meta_data?: ObjectMetaDataAmino;
}
export interface QueryObjectNFTResponseAminoMsg {
    type: "/greenfield.storage.QueryObjectNFTResponse";
    value: QueryObjectNFTResponseAmino;
}
export interface QueryObjectNFTResponseSDKType {
    meta_data?: ObjectMetaDataSDKType;
}
export interface QueryGroupNFTResponse {
    metaData?: GroupMetaData;
}
export interface QueryGroupNFTResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryGroupNFTResponse";
    value: Uint8Array;
}
export interface QueryGroupNFTResponseAmino {
    meta_data?: GroupMetaDataAmino;
}
export interface QueryGroupNFTResponseAminoMsg {
    type: "/greenfield.storage.QueryGroupNFTResponse";
    value: QueryGroupNFTResponseAmino;
}
export interface QueryGroupNFTResponseSDKType {
    meta_data?: GroupMetaDataSDKType;
}
export interface QueryPolicyForAccountRequest {
    resource: string;
    principalAddress: string;
}
export interface QueryPolicyForAccountRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryPolicyForAccountRequest";
    value: Uint8Array;
}
export interface QueryPolicyForAccountRequestAmino {
    resource?: string;
    principal_address?: string;
}
export interface QueryPolicyForAccountRequestAminoMsg {
    type: "/greenfield.storage.QueryPolicyForAccountRequest";
    value: QueryPolicyForAccountRequestAmino;
}
export interface QueryPolicyForAccountRequestSDKType {
    resource: string;
    principal_address: string;
}
export interface QueryPolicyForAccountResponse {
    policy?: Policy;
}
export interface QueryPolicyForAccountResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryPolicyForAccountResponse";
    value: Uint8Array;
}
export interface QueryPolicyForAccountResponseAmino {
    policy?: PolicyAmino;
}
export interface QueryPolicyForAccountResponseAminoMsg {
    type: "/greenfield.storage.QueryPolicyForAccountResponse";
    value: QueryPolicyForAccountResponseAmino;
}
export interface QueryPolicyForAccountResponseSDKType {
    policy?: PolicySDKType;
}
export interface QueryVerifyPermissionRequest {
    operator: string;
    bucketName: string;
    objectName: string;
    actionType: ActionType;
}
export interface QueryVerifyPermissionRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryVerifyPermissionRequest";
    value: Uint8Array;
}
export interface QueryVerifyPermissionRequestAmino {
    operator?: string;
    bucket_name?: string;
    object_name?: string;
    action_type?: ActionType;
}
export interface QueryVerifyPermissionRequestAminoMsg {
    type: "/greenfield.storage.QueryVerifyPermissionRequest";
    value: QueryVerifyPermissionRequestAmino;
}
export interface QueryVerifyPermissionRequestSDKType {
    operator: string;
    bucket_name: string;
    object_name: string;
    action_type: ActionType;
}
export interface QueryVerifyPermissionResponse {
    effect: Effect;
}
export interface QueryVerifyPermissionResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryVerifyPermissionResponse";
    value: Uint8Array;
}
export interface QueryVerifyPermissionResponseAmino {
    effect?: Effect;
}
export interface QueryVerifyPermissionResponseAminoMsg {
    type: "/greenfield.storage.QueryVerifyPermissionResponse";
    value: QueryVerifyPermissionResponseAmino;
}
export interface QueryVerifyPermissionResponseSDKType {
    effect: Effect;
}
export interface QueryHeadGroupRequest {
    groupOwner: string;
    groupName: string;
}
export interface QueryHeadGroupRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadGroupRequest";
    value: Uint8Array;
}
export interface QueryHeadGroupRequestAmino {
    group_owner?: string;
    group_name?: string;
}
export interface QueryHeadGroupRequestAminoMsg {
    type: "/greenfield.storage.QueryHeadGroupRequest";
    value: QueryHeadGroupRequestAmino;
}
export interface QueryHeadGroupRequestSDKType {
    group_owner: string;
    group_name: string;
}
export interface QueryHeadGroupResponse {
    groupInfo?: GroupInfo;
}
export interface QueryHeadGroupResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadGroupResponse";
    value: Uint8Array;
}
export interface QueryHeadGroupResponseAmino {
    group_info?: GroupInfoAmino;
}
export interface QueryHeadGroupResponseAminoMsg {
    type: "/greenfield.storage.QueryHeadGroupResponse";
    value: QueryHeadGroupResponseAmino;
}
export interface QueryHeadGroupResponseSDKType {
    group_info?: GroupInfoSDKType;
}
export interface QueryListGroupsRequest {
    pagination?: PageRequest;
    groupOwner: string;
}
export interface QueryListGroupsRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryListGroupsRequest";
    value: Uint8Array;
}
export interface QueryListGroupsRequestAmino {
    pagination?: PageRequestAmino;
    group_owner?: string;
}
export interface QueryListGroupsRequestAminoMsg {
    type: "/greenfield.storage.QueryListGroupsRequest";
    value: QueryListGroupsRequestAmino;
}
export interface QueryListGroupsRequestSDKType {
    pagination?: PageRequestSDKType;
    group_owner: string;
}
export interface QueryListGroupsResponse {
    pagination?: PageResponse;
    groupInfos: GroupInfo[];
}
export interface QueryListGroupsResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryListGroupsResponse";
    value: Uint8Array;
}
export interface QueryListGroupsResponseAmino {
    pagination?: PageResponseAmino;
    group_infos?: GroupInfoAmino[];
}
export interface QueryListGroupsResponseAminoMsg {
    type: "/greenfield.storage.QueryListGroupsResponse";
    value: QueryListGroupsResponseAmino;
}
export interface QueryListGroupsResponseSDKType {
    pagination?: PageResponseSDKType;
    group_infos: GroupInfoSDKType[];
}
export interface QueryHeadGroupMemberRequest {
    member: string;
    groupOwner: string;
    groupName: string;
}
export interface QueryHeadGroupMemberRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadGroupMemberRequest";
    value: Uint8Array;
}
export interface QueryHeadGroupMemberRequestAmino {
    member?: string;
    group_owner?: string;
    group_name?: string;
}
export interface QueryHeadGroupMemberRequestAminoMsg {
    type: "/greenfield.storage.QueryHeadGroupMemberRequest";
    value: QueryHeadGroupMemberRequestAmino;
}
export interface QueryHeadGroupMemberRequestSDKType {
    member: string;
    group_owner: string;
    group_name: string;
}
export interface QueryHeadGroupMemberResponse {
    groupMember?: GroupMember;
}
export interface QueryHeadGroupMemberResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadGroupMemberResponse";
    value: Uint8Array;
}
export interface QueryHeadGroupMemberResponseAmino {
    group_member?: GroupMemberAmino;
}
export interface QueryHeadGroupMemberResponseAminoMsg {
    type: "/greenfield.storage.QueryHeadGroupMemberResponse";
    value: QueryHeadGroupMemberResponseAmino;
}
export interface QueryHeadGroupMemberResponseSDKType {
    group_member?: GroupMemberSDKType;
}
export interface QueryPolicyForGroupRequest {
    resource: string;
    principalGroupId: string;
}
export interface QueryPolicyForGroupRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryPolicyForGroupRequest";
    value: Uint8Array;
}
export interface QueryPolicyForGroupRequestAmino {
    resource?: string;
    principal_group_id?: string;
}
export interface QueryPolicyForGroupRequestAminoMsg {
    type: "/greenfield.storage.QueryPolicyForGroupRequest";
    value: QueryPolicyForGroupRequestAmino;
}
export interface QueryPolicyForGroupRequestSDKType {
    resource: string;
    principal_group_id: string;
}
export interface QueryPolicyForGroupResponse {
    policy?: Policy;
}
export interface QueryPolicyForGroupResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryPolicyForGroupResponse";
    value: Uint8Array;
}
export interface QueryPolicyForGroupResponseAmino {
    policy?: PolicyAmino;
}
export interface QueryPolicyForGroupResponseAminoMsg {
    type: "/greenfield.storage.QueryPolicyForGroupResponse";
    value: QueryPolicyForGroupResponseAmino;
}
export interface QueryPolicyForGroupResponseSDKType {
    policy?: PolicySDKType;
}
export interface QueryPolicyByIdRequest {
    policyId: string;
}
export interface QueryPolicyByIdRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryPolicyByIdRequest";
    value: Uint8Array;
}
export interface QueryPolicyByIdRequestAmino {
    policy_id?: string;
}
export interface QueryPolicyByIdRequestAminoMsg {
    type: "/greenfield.storage.QueryPolicyByIdRequest";
    value: QueryPolicyByIdRequestAmino;
}
export interface QueryPolicyByIdRequestSDKType {
    policy_id: string;
}
export interface QueryPolicyByIdResponse {
    policy?: Policy;
}
export interface QueryPolicyByIdResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryPolicyByIdResponse";
    value: Uint8Array;
}
export interface QueryPolicyByIdResponseAmino {
    policy?: PolicyAmino;
}
export interface QueryPolicyByIdResponseAminoMsg {
    type: "/greenfield.storage.QueryPolicyByIdResponse";
    value: QueryPolicyByIdResponseAmino;
}
export interface QueryPolicyByIdResponseSDKType {
    policy?: PolicySDKType;
}
export interface QueryLockFeeRequest {
    /** primary_sp_address is the address of the primary sp. */
    primarySpAddress: string;
    /** create_at define the block timestamp when the object created. */
    createAt: Long;
    /** payloadSize is the total size of the object payload */
    payloadSize: Long;
}
export interface QueryLockFeeRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryLockFeeRequest";
    value: Uint8Array;
}
export interface QueryLockFeeRequestAmino {
    /** primary_sp_address is the address of the primary sp. */
    primary_sp_address?: string;
    /** create_at define the block timestamp when the object created. */
    create_at?: string;
    /** payloadSize is the total size of the object payload */
    payload_size?: string;
}
export interface QueryLockFeeRequestAminoMsg {
    type: "/greenfield.storage.QueryLockFeeRequest";
    value: QueryLockFeeRequestAmino;
}
export interface QueryLockFeeRequestSDKType {
    primary_sp_address: string;
    create_at: Long;
    payload_size: Long;
}
export interface QueryLockFeeResponse {
    amount: string;
}
export interface QueryLockFeeResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryLockFeeResponse";
    value: Uint8Array;
}
export interface QueryLockFeeResponseAmino {
    amount?: string;
}
export interface QueryLockFeeResponseAminoMsg {
    type: "/greenfield.storage.QueryLockFeeResponse";
    value: QueryLockFeeResponseAmino;
}
export interface QueryLockFeeResponseSDKType {
    amount: string;
}
export interface QueryHeadBucketExtraRequest {
    bucketName: string;
}
export interface QueryHeadBucketExtraRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadBucketExtraRequest";
    value: Uint8Array;
}
export interface QueryHeadBucketExtraRequestAmino {
    bucket_name?: string;
}
export interface QueryHeadBucketExtraRequestAminoMsg {
    type: "/greenfield.storage.QueryHeadBucketExtraRequest";
    value: QueryHeadBucketExtraRequestAmino;
}
export interface QueryHeadBucketExtraRequestSDKType {
    bucket_name: string;
}
export interface QueryHeadBucketExtraResponse {
    extraInfo?: InternalBucketInfo;
}
export interface QueryHeadBucketExtraResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryHeadBucketExtraResponse";
    value: Uint8Array;
}
export interface QueryHeadBucketExtraResponseAmino {
    extra_info?: InternalBucketInfoAmino;
}
export interface QueryHeadBucketExtraResponseAminoMsg {
    type: "/greenfield.storage.QueryHeadBucketExtraResponse";
    value: QueryHeadBucketExtraResponseAmino;
}
export interface QueryHeadBucketExtraResponseSDKType {
    extra_info?: InternalBucketInfoSDKType;
}
export interface QueryIsPriceChangedRequest {
    bucketName: string;
}
export interface QueryIsPriceChangedRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryIsPriceChangedRequest";
    value: Uint8Array;
}
export interface QueryIsPriceChangedRequestAmino {
    bucket_name?: string;
}
export interface QueryIsPriceChangedRequestAminoMsg {
    type: "/greenfield.storage.QueryIsPriceChangedRequest";
    value: QueryIsPriceChangedRequestAmino;
}
export interface QueryIsPriceChangedRequestSDKType {
    bucket_name: string;
}
export interface QueryIsPriceChangedResponse {
    changed: boolean;
    currentReadPrice: string;
    currentPrimaryStorePrice: string;
    currentSecondaryStorePrice: string;
    currentValidatorTaxRate: string;
    newReadPrice: string;
    newPrimaryStorePrice: string;
    newSecondaryStorePrice: string;
    newValidatorTaxRate: string;
}
export interface QueryIsPriceChangedResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryIsPriceChangedResponse";
    value: Uint8Array;
}
export interface QueryIsPriceChangedResponseAmino {
    changed?: boolean;
    current_read_price?: string;
    current_primary_store_price?: string;
    current_secondary_store_price?: string;
    current_validator_tax_rate?: string;
    new_read_price?: string;
    new_primary_store_price?: string;
    new_secondary_store_price?: string;
    new_validator_tax_rate?: string;
}
export interface QueryIsPriceChangedResponseAminoMsg {
    type: "/greenfield.storage.QueryIsPriceChangedResponse";
    value: QueryIsPriceChangedResponseAmino;
}
export interface QueryIsPriceChangedResponseSDKType {
    changed: boolean;
    current_read_price: string;
    current_primary_store_price: string;
    current_secondary_store_price: string;
    current_validator_tax_rate: string;
    new_read_price: string;
    new_primary_store_price: string;
    new_secondary_store_price: string;
    new_validator_tax_rate: string;
}
export interface QueryQuoteUpdateTimeRequest {
    bucketName: string;
}
export interface QueryQuoteUpdateTimeRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryQuoteUpdateTimeRequest";
    value: Uint8Array;
}
export interface QueryQuoteUpdateTimeRequestAmino {
    bucket_name?: string;
}
export interface QueryQuoteUpdateTimeRequestAminoMsg {
    type: "/greenfield.storage.QueryQuoteUpdateTimeRequest";
    value: QueryQuoteUpdateTimeRequestAmino;
}
export interface QueryQuoteUpdateTimeRequestSDKType {
    bucket_name: string;
}
export interface QueryQuoteUpdateTimeResponse {
    updateAt: Long;
}
export interface QueryQuoteUpdateTimeResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryQuoteUpdateTimeResponse";
    value: Uint8Array;
}
export interface QueryQuoteUpdateTimeResponseAmino {
    update_at?: string;
}
export interface QueryQuoteUpdateTimeResponseAminoMsg {
    type: "/greenfield.storage.QueryQuoteUpdateTimeResponse";
    value: QueryQuoteUpdateTimeResponseAmino;
}
export interface QueryQuoteUpdateTimeResponseSDKType {
    update_at: Long;
}
export interface QueryGroupMembersExistRequest {
    groupId: string;
    members: string[];
}
export interface QueryGroupMembersExistRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryGroupMembersExistRequest";
    value: Uint8Array;
}
export interface QueryGroupMembersExistRequestAmino {
    group_id?: string;
    members?: string[];
}
export interface QueryGroupMembersExistRequestAminoMsg {
    type: "/greenfield.storage.QueryGroupMembersExistRequest";
    value: QueryGroupMembersExistRequestAmino;
}
export interface QueryGroupMembersExistRequestSDKType {
    group_id: string;
    members: string[];
}
export interface QueryGroupMembersExistResponse_ExistsEntry {
    key: string;
    value: boolean;
}
export interface QueryGroupMembersExistResponse_ExistsEntryProtoMsg {
    typeUrl: string;
    value: Uint8Array;
}
export interface QueryGroupMembersExistResponse_ExistsEntryAmino {
    key?: string;
    value?: boolean;
}
export interface QueryGroupMembersExistResponse_ExistsEntryAminoMsg {
    type: string;
    value: QueryGroupMembersExistResponse_ExistsEntryAmino;
}
export interface QueryGroupMembersExistResponse_ExistsEntrySDKType {
    key: string;
    value: boolean;
}
export interface QueryGroupMembersExistResponse {
    exists: {
        [key: string]: boolean;
    };
}
export interface QueryGroupMembersExistResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryGroupMembersExistResponse";
    value: Uint8Array;
}
export interface QueryGroupMembersExistResponseAmino {
    exists?: {
        [key: string]: boolean;
    };
}
export interface QueryGroupMembersExistResponseAminoMsg {
    type: "/greenfield.storage.QueryGroupMembersExistResponse";
    value: QueryGroupMembersExistResponseAmino;
}
export interface QueryGroupMembersExistResponseSDKType {
    exists: {
        [key: string]: boolean;
    };
}
export interface QueryGroupsExistRequest {
    groupOwner: string;
    groupNames: string[];
}
export interface QueryGroupsExistRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryGroupsExistRequest";
    value: Uint8Array;
}
export interface QueryGroupsExistRequestAmino {
    group_owner?: string;
    group_names?: string[];
}
export interface QueryGroupsExistRequestAminoMsg {
    type: "/greenfield.storage.QueryGroupsExistRequest";
    value: QueryGroupsExistRequestAmino;
}
export interface QueryGroupsExistRequestSDKType {
    group_owner: string;
    group_names: string[];
}
export interface QueryGroupsExistByIdRequest {
    groupIds: string[];
}
export interface QueryGroupsExistByIdRequestProtoMsg {
    typeUrl: "/greenfield.storage.QueryGroupsExistByIdRequest";
    value: Uint8Array;
}
export interface QueryGroupsExistByIdRequestAmino {
    group_ids?: string[];
}
export interface QueryGroupsExistByIdRequestAminoMsg {
    type: "/greenfield.storage.QueryGroupsExistByIdRequest";
    value: QueryGroupsExistByIdRequestAmino;
}
export interface QueryGroupsExistByIdRequestSDKType {
    group_ids: string[];
}
export interface QueryGroupsExistResponse_ExistsEntry {
    key: string;
    value: boolean;
}
export interface QueryGroupsExistResponse_ExistsEntryProtoMsg {
    typeUrl: string;
    value: Uint8Array;
}
export interface QueryGroupsExistResponse_ExistsEntryAmino {
    key?: string;
    value?: boolean;
}
export interface QueryGroupsExistResponse_ExistsEntryAminoMsg {
    type: string;
    value: QueryGroupsExistResponse_ExistsEntryAmino;
}
export interface QueryGroupsExistResponse_ExistsEntrySDKType {
    key: string;
    value: boolean;
}
export interface QueryGroupsExistResponse {
    exists: {
        [key: string]: boolean;
    };
}
export interface QueryGroupsExistResponseProtoMsg {
    typeUrl: "/greenfield.storage.QueryGroupsExistResponse";
    value: Uint8Array;
}
export interface QueryGroupsExistResponseAmino {
    exists?: {
        [key: string]: boolean;
    };
}
export interface QueryGroupsExistResponseAminoMsg {
    type: "/greenfield.storage.QueryGroupsExistResponse";
    value: QueryGroupsExistResponseAmino;
}
export interface QueryGroupsExistResponseSDKType {
    exists: {
        [key: string]: boolean;
    };
}
export declare const QueryParamsRequest: {
    typeUrl: string;
    encode(_: QueryParamsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsRequest;
    fromJSON(_: any): QueryParamsRequest;
    toJSON(_: QueryParamsRequest): unknown;
    fromPartial<I extends {} & {} & Record<Exclude<keyof I, never>, never>>(_: I): QueryParamsRequest;
    fromSDK(_: QueryParamsRequestSDKType): QueryParamsRequest;
    toSDK(_: QueryParamsRequest): QueryParamsRequestSDKType;
    fromAmino(_: QueryParamsRequestAmino): QueryParamsRequest;
    toAmino(_: QueryParamsRequest): QueryParamsRequestAmino;
    fromAminoMsg(object: QueryParamsRequestAminoMsg): QueryParamsRequest;
    fromProtoMsg(message: QueryParamsRequestProtoMsg): QueryParamsRequest;
    toProto(message: QueryParamsRequest): Uint8Array;
    toProtoMsg(message: QueryParamsRequest): QueryParamsRequestProtoMsg;
};
export declare const QueryParamsResponse: {
    typeUrl: string;
    encode(message: QueryParamsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsResponse;
    fromJSON(object: any): QueryParamsResponse;
    toJSON(message: QueryParamsResponse): unknown;
    fromPartial<I extends {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        };
    } & {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            } & {
                maxSegmentSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["maxSegmentSize"], keyof Long.Long>, never>);
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["minChargeSize"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>;
            maxPayloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxPayloadSize"], keyof Long.Long>, never>);
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueCountingWindow"], keyof Long.Long>, never>);
            discontinueObjectMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueObjectMax"], keyof Long.Long>, never>);
            discontinueBucketMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueBucketMax"], keyof Long.Long>, never>);
            discontinueConfirmPeriod?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueConfirmPeriod"], keyof Long.Long>, never>);
            discontinueDeletionMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueDeletionMax"], keyof Long.Long>, never>);
            stalePolicyCleanupMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["stalePolicyCleanupMax"], keyof Long.Long>, never>);
            minQuotaUpdateInterval?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["minQuotaUpdateInterval"], keyof Long.Long>, never>);
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsResponse;
    fromSDK(object: QueryParamsResponseSDKType): QueryParamsResponse;
    toSDK(message: QueryParamsResponse): QueryParamsResponseSDKType;
    fromAmino(object: QueryParamsResponseAmino): QueryParamsResponse;
    toAmino(message: QueryParamsResponse): QueryParamsResponseAmino;
    fromAminoMsg(object: QueryParamsResponseAminoMsg): QueryParamsResponse;
    fromProtoMsg(message: QueryParamsResponseProtoMsg): QueryParamsResponse;
    toProto(message: QueryParamsResponse): Uint8Array;
    toProtoMsg(message: QueryParamsResponse): QueryParamsResponseProtoMsg;
};
export declare const QueryParamsByTimestampRequest: {
    typeUrl: string;
    encode(message: QueryParamsByTimestampRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsByTimestampRequest;
    fromJSON(object: any): QueryParamsByTimestampRequest;
    toJSON(message: QueryParamsByTimestampRequest): unknown;
    fromPartial<I extends {
        timestamp?: string | number | Long.Long;
    } & {
        timestamp?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["timestamp"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, "timestamp">, never>>(object: I): QueryParamsByTimestampRequest;
    fromSDK(object: QueryParamsByTimestampRequestSDKType): QueryParamsByTimestampRequest;
    toSDK(message: QueryParamsByTimestampRequest): QueryParamsByTimestampRequestSDKType;
    fromAmino(object: QueryParamsByTimestampRequestAmino): QueryParamsByTimestampRequest;
    toAmino(message: QueryParamsByTimestampRequest): QueryParamsByTimestampRequestAmino;
    fromAminoMsg(object: QueryParamsByTimestampRequestAminoMsg): QueryParamsByTimestampRequest;
    fromProtoMsg(message: QueryParamsByTimestampRequestProtoMsg): QueryParamsByTimestampRequest;
    toProto(message: QueryParamsByTimestampRequest): Uint8Array;
    toProtoMsg(message: QueryParamsByTimestampRequest): QueryParamsByTimestampRequestProtoMsg;
};
export declare const QueryParamsByTimestampResponse: {
    typeUrl: string;
    encode(message: QueryParamsByTimestampResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryParamsByTimestampResponse;
    fromJSON(object: any): QueryParamsByTimestampResponse;
    toJSON(message: QueryParamsByTimestampResponse): unknown;
    fromPartial<I extends {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        };
    } & {
        params?: {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            };
            maxPayloadSize?: string | number | Long.Long;
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | Long.Long;
            discontinueObjectMax?: string | number | Long.Long;
            discontinueBucketMax?: string | number | Long.Long;
            discontinueConfirmPeriod?: string | number | Long.Long;
            discontinueDeletionMax?: string | number | Long.Long;
            stalePolicyCleanupMax?: string | number | Long.Long;
            minQuotaUpdateInterval?: string | number | Long.Long;
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & {
            versionedParams?: {
                maxSegmentSize?: string | number | Long.Long;
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | Long.Long;
            } & {
                maxSegmentSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["maxSegmentSize"], keyof Long.Long>, never>);
                redundantDataChunkNum?: number;
                redundantParityChunkNum?: number;
                minChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["params"]["versionedParams"]["minChargeSize"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["params"]["versionedParams"], keyof import("./params").VersionedParams>, never>;
            maxPayloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["maxPayloadSize"], keyof Long.Long>, never>);
            bscMirrorBucketRelayerFee?: string;
            bscMirrorBucketAckRelayerFee?: string;
            bscMirrorObjectRelayerFee?: string;
            bscMirrorObjectAckRelayerFee?: string;
            bscMirrorGroupRelayerFee?: string;
            bscMirrorGroupAckRelayerFee?: string;
            maxBucketsPerAccount?: number;
            discontinueCountingWindow?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueCountingWindow"], keyof Long.Long>, never>);
            discontinueObjectMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueObjectMax"], keyof Long.Long>, never>);
            discontinueBucketMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueBucketMax"], keyof Long.Long>, never>);
            discontinueConfirmPeriod?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueConfirmPeriod"], keyof Long.Long>, never>);
            discontinueDeletionMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["discontinueDeletionMax"], keyof Long.Long>, never>);
            stalePolicyCleanupMax?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["stalePolicyCleanupMax"], keyof Long.Long>, never>);
            minQuotaUpdateInterval?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["params"]["minQuotaUpdateInterval"], keyof Long.Long>, never>);
            maxLocalVirtualGroupNumPerBucket?: number;
            opMirrorBucketRelayerFee?: string;
            opMirrorBucketAckRelayerFee?: string;
            opMirrorObjectRelayerFee?: string;
            opMirrorObjectAckRelayerFee?: string;
            opMirrorGroupRelayerFee?: string;
            opMirrorGroupAckRelayerFee?: string;
        } & Record<Exclude<keyof I["params"], keyof Params>, never>;
    } & Record<Exclude<keyof I, "params">, never>>(object: I): QueryParamsByTimestampResponse;
    fromSDK(object: QueryParamsByTimestampResponseSDKType): QueryParamsByTimestampResponse;
    toSDK(message: QueryParamsByTimestampResponse): QueryParamsByTimestampResponseSDKType;
    fromAmino(object: QueryParamsByTimestampResponseAmino): QueryParamsByTimestampResponse;
    toAmino(message: QueryParamsByTimestampResponse): QueryParamsByTimestampResponseAmino;
    fromAminoMsg(object: QueryParamsByTimestampResponseAminoMsg): QueryParamsByTimestampResponse;
    fromProtoMsg(message: QueryParamsByTimestampResponseProtoMsg): QueryParamsByTimestampResponse;
    toProto(message: QueryParamsByTimestampResponse): Uint8Array;
    toProtoMsg(message: QueryParamsByTimestampResponse): QueryParamsByTimestampResponseProtoMsg;
};
export declare const QueryHeadBucketRequest: {
    typeUrl: string;
    encode(message: QueryHeadBucketRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketRequest;
    fromJSON(object: any): QueryHeadBucketRequest;
    toJSON(message: QueryHeadBucketRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryHeadBucketRequest;
    fromSDK(object: QueryHeadBucketRequestSDKType): QueryHeadBucketRequest;
    toSDK(message: QueryHeadBucketRequest): QueryHeadBucketRequestSDKType;
    fromAmino(object: QueryHeadBucketRequestAmino): QueryHeadBucketRequest;
    toAmino(message: QueryHeadBucketRequest): QueryHeadBucketRequestAmino;
    fromAminoMsg(object: QueryHeadBucketRequestAminoMsg): QueryHeadBucketRequest;
    fromProtoMsg(message: QueryHeadBucketRequestProtoMsg): QueryHeadBucketRequest;
    toProto(message: QueryHeadBucketRequest): Uint8Array;
    toProtoMsg(message: QueryHeadBucketRequest): QueryHeadBucketRequestProtoMsg;
};
export declare const QueryHeadBucketByIdRequest: {
    typeUrl: string;
    encode(message: QueryHeadBucketByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketByIdRequest;
    fromJSON(object: any): QueryHeadBucketByIdRequest;
    toJSON(message: QueryHeadBucketByIdRequest): unknown;
    fromPartial<I extends {
        bucketId?: string;
    } & {
        bucketId?: string;
    } & Record<Exclude<keyof I, "bucketId">, never>>(object: I): QueryHeadBucketByIdRequest;
    fromSDK(object: QueryHeadBucketByIdRequestSDKType): QueryHeadBucketByIdRequest;
    toSDK(message: QueryHeadBucketByIdRequest): QueryHeadBucketByIdRequestSDKType;
    fromAmino(object: QueryHeadBucketByIdRequestAmino): QueryHeadBucketByIdRequest;
    toAmino(message: QueryHeadBucketByIdRequest): QueryHeadBucketByIdRequestAmino;
    fromAminoMsg(object: QueryHeadBucketByIdRequestAminoMsg): QueryHeadBucketByIdRequest;
    fromProtoMsg(message: QueryHeadBucketByIdRequestProtoMsg): QueryHeadBucketByIdRequest;
    toProto(message: QueryHeadBucketByIdRequest): Uint8Array;
    toProtoMsg(message: QueryHeadBucketByIdRequest): QueryHeadBucketByIdRequestProtoMsg;
};
export declare const QueryHeadBucketResponse: {
    typeUrl: string;
    encode(message: QueryHeadBucketResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketResponse;
    fromJSON(object: any): QueryHeadBucketResponse;
    toJSON(message: QueryHeadBucketResponse): unknown;
    fromPartial<I extends {
        bucketInfo?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        };
    } & {
        bucketInfo?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        } & {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfo"]["createAt"], keyof Long.Long>, never>);
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfo"]["chargedReadQuota"], keyof Long.Long>, never>);
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            } & {
                tags?: {
                    key?: string;
                    value?: string;
                }[] & ({
                    key?: string;
                    value?: string;
                } & {
                    key?: string;
                    value?: string;
                } & Record<Exclude<keyof I["bucketInfo"]["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["bucketInfo"]["tags"]["tags"], keyof {
                    key?: string;
                    value?: string;
                }[]>, never>;
            } & Record<Exclude<keyof I["bucketInfo"]["tags"], "tags">, never>;
        } & Record<Exclude<keyof I["bucketInfo"], keyof BucketInfo>, never>;
    } & Record<Exclude<keyof I, "bucketInfo">, never>>(object: I): QueryHeadBucketResponse;
    fromSDK(object: QueryHeadBucketResponseSDKType): QueryHeadBucketResponse;
    toSDK(message: QueryHeadBucketResponse): QueryHeadBucketResponseSDKType;
    fromAmino(object: QueryHeadBucketResponseAmino): QueryHeadBucketResponse;
    toAmino(message: QueryHeadBucketResponse): QueryHeadBucketResponseAmino;
    fromAminoMsg(object: QueryHeadBucketResponseAminoMsg): QueryHeadBucketResponse;
    fromProtoMsg(message: QueryHeadBucketResponseProtoMsg): QueryHeadBucketResponse;
    toProto(message: QueryHeadBucketResponse): Uint8Array;
    toProtoMsg(message: QueryHeadBucketResponse): QueryHeadBucketResponseProtoMsg;
};
export declare const QueryHeadObjectRequest: {
    typeUrl: string;
    encode(message: QueryHeadObjectRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectRequest;
    fromJSON(object: any): QueryHeadObjectRequest;
    toJSON(message: QueryHeadObjectRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
        objectName?: string;
    } & {
        bucketName?: string;
        objectName?: string;
    } & Record<Exclude<keyof I, keyof QueryHeadObjectRequest>, never>>(object: I): QueryHeadObjectRequest;
    fromSDK(object: QueryHeadObjectRequestSDKType): QueryHeadObjectRequest;
    toSDK(message: QueryHeadObjectRequest): QueryHeadObjectRequestSDKType;
    fromAmino(object: QueryHeadObjectRequestAmino): QueryHeadObjectRequest;
    toAmino(message: QueryHeadObjectRequest): QueryHeadObjectRequestAmino;
    fromAminoMsg(object: QueryHeadObjectRequestAminoMsg): QueryHeadObjectRequest;
    fromProtoMsg(message: QueryHeadObjectRequestProtoMsg): QueryHeadObjectRequest;
    toProto(message: QueryHeadObjectRequest): Uint8Array;
    toProtoMsg(message: QueryHeadObjectRequest): QueryHeadObjectRequestProtoMsg;
};
export declare const QueryHeadObjectByIdRequest: {
    typeUrl: string;
    encode(message: QueryHeadObjectByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectByIdRequest;
    fromJSON(object: any): QueryHeadObjectByIdRequest;
    toJSON(message: QueryHeadObjectByIdRequest): unknown;
    fromPartial<I extends {
        objectId?: string;
    } & {
        objectId?: string;
    } & Record<Exclude<keyof I, "objectId">, never>>(object: I): QueryHeadObjectByIdRequest;
    fromSDK(object: QueryHeadObjectByIdRequestSDKType): QueryHeadObjectByIdRequest;
    toSDK(message: QueryHeadObjectByIdRequest): QueryHeadObjectByIdRequestSDKType;
    fromAmino(object: QueryHeadObjectByIdRequestAmino): QueryHeadObjectByIdRequest;
    toAmino(message: QueryHeadObjectByIdRequest): QueryHeadObjectByIdRequestAmino;
    fromAminoMsg(object: QueryHeadObjectByIdRequestAminoMsg): QueryHeadObjectByIdRequest;
    fromProtoMsg(message: QueryHeadObjectByIdRequestProtoMsg): QueryHeadObjectByIdRequest;
    toProto(message: QueryHeadObjectByIdRequest): Uint8Array;
    toProtoMsg(message: QueryHeadObjectByIdRequest): QueryHeadObjectByIdRequestProtoMsg;
};
export declare const QueryHeadObjectResponse: {
    typeUrl: string;
    encode(message: QueryHeadObjectResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadObjectResponse;
    fromJSON(object: any): QueryHeadObjectResponse;
    toJSON(message: QueryHeadObjectResponse): unknown;
    fromPartial<I extends {
        objectInfo?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        };
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | Long.Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        };
    } & {
        objectInfo?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        } & {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfo"]["payloadSize"], keyof Long.Long>, never>);
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfo"]["createAt"], keyof Long.Long>, never>);
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["objectInfo"]["checksums"], keyof Uint8Array[]>, never>;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            } & {
                tags?: {
                    key?: string;
                    value?: string;
                }[] & ({
                    key?: string;
                    value?: string;
                } & {
                    key?: string;
                    value?: string;
                } & Record<Exclude<keyof I["objectInfo"]["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["objectInfo"]["tags"]["tags"], keyof {
                    key?: string;
                    value?: string;
                }[]>, never>;
            } & Record<Exclude<keyof I["objectInfo"]["tags"], "tags">, never>;
        } & Record<Exclude<keyof I["objectInfo"], keyof ObjectInfo>, never>;
        globalVirtualGroup?: {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[];
            storedSize?: string | number | Long.Long;
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & {
            id?: number;
            familyId?: number;
            primarySpId?: number;
            secondarySpIds?: number[] & number[] & Record<Exclude<keyof I["globalVirtualGroup"]["secondarySpIds"], keyof number[]>, never>;
            storedSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["globalVirtualGroup"]["storedSize"], keyof Long.Long>, never>);
            virtualPaymentAddress?: string;
            totalDeposit?: string;
        } & Record<Exclude<keyof I["globalVirtualGroup"], keyof GlobalVirtualGroup>, never>;
    } & Record<Exclude<keyof I, keyof QueryHeadObjectResponse>, never>>(object: I): QueryHeadObjectResponse;
    fromSDK(object: QueryHeadObjectResponseSDKType): QueryHeadObjectResponse;
    toSDK(message: QueryHeadObjectResponse): QueryHeadObjectResponseSDKType;
    fromAmino(object: QueryHeadObjectResponseAmino): QueryHeadObjectResponse;
    toAmino(message: QueryHeadObjectResponse): QueryHeadObjectResponseAmino;
    fromAminoMsg(object: QueryHeadObjectResponseAminoMsg): QueryHeadObjectResponse;
    fromProtoMsg(message: QueryHeadObjectResponseProtoMsg): QueryHeadObjectResponse;
    toProto(message: QueryHeadObjectResponse): Uint8Array;
    toProtoMsg(message: QueryHeadObjectResponse): QueryHeadObjectResponseProtoMsg;
};
export declare const QueryListBucketsRequest: {
    typeUrl: string;
    encode(message: QueryListBucketsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListBucketsRequest;
    fromJSON(object: any): QueryListBucketsRequest;
    toJSON(message: QueryListBucketsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, "pagination">, never>>(object: I): QueryListBucketsRequest;
    fromSDK(object: QueryListBucketsRequestSDKType): QueryListBucketsRequest;
    toSDK(message: QueryListBucketsRequest): QueryListBucketsRequestSDKType;
    fromAmino(object: QueryListBucketsRequestAmino): QueryListBucketsRequest;
    toAmino(message: QueryListBucketsRequest): QueryListBucketsRequestAmino;
    fromAminoMsg(object: QueryListBucketsRequestAminoMsg): QueryListBucketsRequest;
    fromProtoMsg(message: QueryListBucketsRequestProtoMsg): QueryListBucketsRequest;
    toProto(message: QueryListBucketsRequest): Uint8Array;
    toProtoMsg(message: QueryListBucketsRequest): QueryListBucketsRequestProtoMsg;
};
export declare const QueryListBucketsResponse: {
    typeUrl: string;
    encode(message: QueryListBucketsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListBucketsResponse;
    fromJSON(object: any): QueryListBucketsResponse;
    toJSON(message: QueryListBucketsResponse): unknown;
    fromPartial<I extends {
        bucketInfos?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        bucketInfos?: {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[] & ({
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        } & {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfos"][number]["createAt"], keyof Long.Long>, never>);
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["bucketInfos"][number]["chargedReadQuota"], keyof Long.Long>, never>);
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            } & {
                tags?: {
                    key?: string;
                    value?: string;
                }[] & ({
                    key?: string;
                    value?: string;
                } & {
                    key?: string;
                    value?: string;
                } & Record<Exclude<keyof I["bucketInfos"][number]["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["bucketInfos"][number]["tags"]["tags"], keyof {
                    key?: string;
                    value?: string;
                }[]>, never>;
            } & Record<Exclude<keyof I["bucketInfos"][number]["tags"], "tags">, never>;
        } & Record<Exclude<keyof I["bucketInfos"][number], keyof BucketInfo>, never>)[] & Record<Exclude<keyof I["bucketInfos"], keyof {
            owner?: string;
            bucketName?: string;
            visibility?: import("./common").VisibilityType;
            id?: string;
            sourceType?: import("./common").SourceType;
            createAt?: string | number | Long.Long;
            paymentAddress?: string;
            globalVirtualGroupFamilyId?: number;
            chargedReadQuota?: string | number | Long.Long;
            bucketStatus?: import("./common").BucketStatus;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryListBucketsResponse>, never>>(object: I): QueryListBucketsResponse;
    fromSDK(object: QueryListBucketsResponseSDKType): QueryListBucketsResponse;
    toSDK(message: QueryListBucketsResponse): QueryListBucketsResponseSDKType;
    fromAmino(object: QueryListBucketsResponseAmino): QueryListBucketsResponse;
    toAmino(message: QueryListBucketsResponse): QueryListBucketsResponseAmino;
    fromAminoMsg(object: QueryListBucketsResponseAminoMsg): QueryListBucketsResponse;
    fromProtoMsg(message: QueryListBucketsResponseProtoMsg): QueryListBucketsResponse;
    toProto(message: QueryListBucketsResponse): Uint8Array;
    toProtoMsg(message: QueryListBucketsResponse): QueryListBucketsResponseProtoMsg;
};
export declare const QueryListObjectsRequest: {
    typeUrl: string;
    encode(message: QueryListObjectsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsRequest;
    fromJSON(object: any): QueryListObjectsRequest;
    toJSON(message: QueryListObjectsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
        bucketName?: string;
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
        bucketName?: string;
    } & Record<Exclude<keyof I, keyof QueryListObjectsRequest>, never>>(object: I): QueryListObjectsRequest;
    fromSDK(object: QueryListObjectsRequestSDKType): QueryListObjectsRequest;
    toSDK(message: QueryListObjectsRequest): QueryListObjectsRequestSDKType;
    fromAmino(object: QueryListObjectsRequestAmino): QueryListObjectsRequest;
    toAmino(message: QueryListObjectsRequest): QueryListObjectsRequestAmino;
    fromAminoMsg(object: QueryListObjectsRequestAminoMsg): QueryListObjectsRequest;
    fromProtoMsg(message: QueryListObjectsRequestProtoMsg): QueryListObjectsRequest;
    toProto(message: QueryListObjectsRequest): Uint8Array;
    toProtoMsg(message: QueryListObjectsRequest): QueryListObjectsRequestProtoMsg;
};
export declare const QueryListObjectsByBucketIdRequest: {
    typeUrl: string;
    encode(message: QueryListObjectsByBucketIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsByBucketIdRequest;
    fromJSON(object: any): QueryListObjectsByBucketIdRequest;
    toJSON(message: QueryListObjectsByBucketIdRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
        bucketId?: string;
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
        bucketId?: string;
    } & Record<Exclude<keyof I, keyof QueryListObjectsByBucketIdRequest>, never>>(object: I): QueryListObjectsByBucketIdRequest;
    fromSDK(object: QueryListObjectsByBucketIdRequestSDKType): QueryListObjectsByBucketIdRequest;
    toSDK(message: QueryListObjectsByBucketIdRequest): QueryListObjectsByBucketIdRequestSDKType;
    fromAmino(object: QueryListObjectsByBucketIdRequestAmino): QueryListObjectsByBucketIdRequest;
    toAmino(message: QueryListObjectsByBucketIdRequest): QueryListObjectsByBucketIdRequestAmino;
    fromAminoMsg(object: QueryListObjectsByBucketIdRequestAminoMsg): QueryListObjectsByBucketIdRequest;
    fromProtoMsg(message: QueryListObjectsByBucketIdRequestProtoMsg): QueryListObjectsByBucketIdRequest;
    toProto(message: QueryListObjectsByBucketIdRequest): Uint8Array;
    toProtoMsg(message: QueryListObjectsByBucketIdRequest): QueryListObjectsByBucketIdRequestProtoMsg;
};
export declare const QueryListObjectsResponse: {
    typeUrl: string;
    encode(message: QueryListObjectsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListObjectsResponse;
    fromJSON(object: any): QueryListObjectsResponse;
    toJSON(message: QueryListObjectsResponse): unknown;
    fromPartial<I extends {
        objectInfos?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
    } & {
        objectInfos?: {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[] & ({
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        } & {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfos"][number]["payloadSize"], keyof Long.Long>, never>);
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["objectInfos"][number]["createAt"], keyof Long.Long>, never>);
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[] & Uint8Array[] & Record<Exclude<keyof I["objectInfos"][number]["checksums"], keyof Uint8Array[]>, never>;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            } & {
                tags?: {
                    key?: string;
                    value?: string;
                }[] & ({
                    key?: string;
                    value?: string;
                } & {
                    key?: string;
                    value?: string;
                } & Record<Exclude<keyof I["objectInfos"][number]["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["objectInfos"][number]["tags"]["tags"], keyof {
                    key?: string;
                    value?: string;
                }[]>, never>;
            } & Record<Exclude<keyof I["objectInfos"][number]["tags"], "tags">, never>;
        } & Record<Exclude<keyof I["objectInfos"][number], keyof ObjectInfo>, never>)[] & Record<Exclude<keyof I["objectInfos"], keyof {
            owner?: string;
            creator?: string;
            bucketName?: string;
            objectName?: string;
            id?: string;
            localVirtualGroupId?: number;
            payloadSize?: string | number | Long.Long;
            visibility?: import("./common").VisibilityType;
            contentType?: string;
            createAt?: string | number | Long.Long;
            objectStatus?: import("./common").ObjectStatus;
            redundancyType?: import("./common").RedundancyType;
            sourceType?: import("./common").SourceType;
            checksums?: Uint8Array[];
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryListObjectsResponse>, never>>(object: I): QueryListObjectsResponse;
    fromSDK(object: QueryListObjectsResponseSDKType): QueryListObjectsResponse;
    toSDK(message: QueryListObjectsResponse): QueryListObjectsResponseSDKType;
    fromAmino(object: QueryListObjectsResponseAmino): QueryListObjectsResponse;
    toAmino(message: QueryListObjectsResponse): QueryListObjectsResponseAmino;
    fromAminoMsg(object: QueryListObjectsResponseAminoMsg): QueryListObjectsResponse;
    fromProtoMsg(message: QueryListObjectsResponseProtoMsg): QueryListObjectsResponse;
    toProto(message: QueryListObjectsResponse): Uint8Array;
    toProtoMsg(message: QueryListObjectsResponse): QueryListObjectsResponseProtoMsg;
};
export declare const QueryNFTRequest: {
    typeUrl: string;
    encode(message: QueryNFTRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryNFTRequest;
    fromJSON(object: any): QueryNFTRequest;
    toJSON(message: QueryNFTRequest): unknown;
    fromPartial<I extends {
        tokenId?: string;
    } & {
        tokenId?: string;
    } & Record<Exclude<keyof I, "tokenId">, never>>(object: I): QueryNFTRequest;
    fromSDK(object: QueryNFTRequestSDKType): QueryNFTRequest;
    toSDK(message: QueryNFTRequest): QueryNFTRequestSDKType;
    fromAmino(object: QueryNFTRequestAmino): QueryNFTRequest;
    toAmino(message: QueryNFTRequest): QueryNFTRequestAmino;
    fromAminoMsg(object: QueryNFTRequestAminoMsg): QueryNFTRequest;
    fromProtoMsg(message: QueryNFTRequestProtoMsg): QueryNFTRequest;
    toProto(message: QueryNFTRequest): Uint8Array;
    toProtoMsg(message: QueryNFTRequest): QueryNFTRequestProtoMsg;
};
export declare const QueryBucketNFTResponse: {
    typeUrl: string;
    encode(message: QueryBucketNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryBucketNFTResponse;
    fromJSON(object: any): QueryBucketNFTResponse;
    toJSON(message: QueryBucketNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string;
            externalUrl?: string;
            bucketName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        };
    } & {
        metaData?: {
            description?: string;
            externalUrl?: string;
            bucketName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        } & {
            description?: string;
            externalUrl?: string;
            bucketName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[] & ({
                traitType?: string;
                value?: string;
            } & {
                traitType?: string;
                value?: string;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["metaData"], keyof BucketMetaData>, never>;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryBucketNFTResponse;
    fromSDK(object: QueryBucketNFTResponseSDKType): QueryBucketNFTResponse;
    toSDK(message: QueryBucketNFTResponse): QueryBucketNFTResponseSDKType;
    fromAmino(object: QueryBucketNFTResponseAmino): QueryBucketNFTResponse;
    toAmino(message: QueryBucketNFTResponse): QueryBucketNFTResponseAmino;
    fromAminoMsg(object: QueryBucketNFTResponseAminoMsg): QueryBucketNFTResponse;
    fromProtoMsg(message: QueryBucketNFTResponseProtoMsg): QueryBucketNFTResponse;
    toProto(message: QueryBucketNFTResponse): Uint8Array;
    toProtoMsg(message: QueryBucketNFTResponse): QueryBucketNFTResponseProtoMsg;
};
export declare const QueryObjectNFTResponse: {
    typeUrl: string;
    encode(message: QueryObjectNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryObjectNFTResponse;
    fromJSON(object: any): QueryObjectNFTResponse;
    toJSON(message: QueryObjectNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string;
            externalUrl?: string;
            objectName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        };
    } & {
        metaData?: {
            description?: string;
            externalUrl?: string;
            objectName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        } & {
            description?: string;
            externalUrl?: string;
            objectName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[] & ({
                traitType?: string;
                value?: string;
            } & {
                traitType?: string;
                value?: string;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["metaData"], keyof ObjectMetaData>, never>;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryObjectNFTResponse;
    fromSDK(object: QueryObjectNFTResponseSDKType): QueryObjectNFTResponse;
    toSDK(message: QueryObjectNFTResponse): QueryObjectNFTResponseSDKType;
    fromAmino(object: QueryObjectNFTResponseAmino): QueryObjectNFTResponse;
    toAmino(message: QueryObjectNFTResponse): QueryObjectNFTResponseAmino;
    fromAminoMsg(object: QueryObjectNFTResponseAminoMsg): QueryObjectNFTResponse;
    fromProtoMsg(message: QueryObjectNFTResponseProtoMsg): QueryObjectNFTResponse;
    toProto(message: QueryObjectNFTResponse): Uint8Array;
    toProtoMsg(message: QueryObjectNFTResponse): QueryObjectNFTResponseProtoMsg;
};
export declare const QueryGroupNFTResponse: {
    typeUrl: string;
    encode(message: QueryGroupNFTResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupNFTResponse;
    fromJSON(object: any): QueryGroupNFTResponse;
    toJSON(message: QueryGroupNFTResponse): unknown;
    fromPartial<I extends {
        metaData?: {
            description?: string;
            externalUrl?: string;
            groupName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        };
    } & {
        metaData?: {
            description?: string;
            externalUrl?: string;
            groupName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[];
        } & {
            description?: string;
            externalUrl?: string;
            groupName?: string;
            image?: string;
            attributes?: {
                traitType?: string;
                value?: string;
            }[] & ({
                traitType?: string;
                value?: string;
            } & {
                traitType?: string;
                value?: string;
            } & Record<Exclude<keyof I["metaData"]["attributes"][number], keyof import("./types").Trait>, never>)[] & Record<Exclude<keyof I["metaData"]["attributes"], keyof {
                traitType?: string;
                value?: string;
            }[]>, never>;
        } & Record<Exclude<keyof I["metaData"], keyof GroupMetaData>, never>;
    } & Record<Exclude<keyof I, "metaData">, never>>(object: I): QueryGroupNFTResponse;
    fromSDK(object: QueryGroupNFTResponseSDKType): QueryGroupNFTResponse;
    toSDK(message: QueryGroupNFTResponse): QueryGroupNFTResponseSDKType;
    fromAmino(object: QueryGroupNFTResponseAmino): QueryGroupNFTResponse;
    toAmino(message: QueryGroupNFTResponse): QueryGroupNFTResponseAmino;
    fromAminoMsg(object: QueryGroupNFTResponseAminoMsg): QueryGroupNFTResponse;
    fromProtoMsg(message: QueryGroupNFTResponseProtoMsg): QueryGroupNFTResponse;
    toProto(message: QueryGroupNFTResponse): Uint8Array;
    toProtoMsg(message: QueryGroupNFTResponse): QueryGroupNFTResponseProtoMsg;
};
export declare const QueryPolicyForAccountRequest: {
    typeUrl: string;
    encode(message: QueryPolicyForAccountRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForAccountRequest;
    fromJSON(object: any): QueryPolicyForAccountRequest;
    toJSON(message: QueryPolicyForAccountRequest): unknown;
    fromPartial<I extends {
        resource?: string;
        principalAddress?: string;
    } & {
        resource?: string;
        principalAddress?: string;
    } & Record<Exclude<keyof I, keyof QueryPolicyForAccountRequest>, never>>(object: I): QueryPolicyForAccountRequest;
    fromSDK(object: QueryPolicyForAccountRequestSDKType): QueryPolicyForAccountRequest;
    toSDK(message: QueryPolicyForAccountRequest): QueryPolicyForAccountRequestSDKType;
    fromAmino(object: QueryPolicyForAccountRequestAmino): QueryPolicyForAccountRequest;
    toAmino(message: QueryPolicyForAccountRequest): QueryPolicyForAccountRequestAmino;
    fromAminoMsg(object: QueryPolicyForAccountRequestAminoMsg): QueryPolicyForAccountRequest;
    fromProtoMsg(message: QueryPolicyForAccountRequestProtoMsg): QueryPolicyForAccountRequest;
    toProto(message: QueryPolicyForAccountRequest): Uint8Array;
    toProtoMsg(message: QueryPolicyForAccountRequest): QueryPolicyForAccountRequestProtoMsg;
};
export declare const QueryPolicyForAccountResponse: {
    typeUrl: string;
    encode(message: QueryPolicyForAccountResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForAccountResponse;
    fromJSON(object: any): QueryPolicyForAccountResponse;
    toJSON(message: QueryPolicyForAccountResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>;
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[] & ({
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            } & {
                effect?: Effect;
                actions?: ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>;
                resources?: string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>;
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                } & {
                    seconds?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                    nanos?: number;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
                limitSize?: {
                    value?: string | number | Long.Long;
                } & {
                    value?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>);
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[]>, never>;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyForAccountResponse;
    fromSDK(object: QueryPolicyForAccountResponseSDKType): QueryPolicyForAccountResponse;
    toSDK(message: QueryPolicyForAccountResponse): QueryPolicyForAccountResponseSDKType;
    fromAmino(object: QueryPolicyForAccountResponseAmino): QueryPolicyForAccountResponse;
    toAmino(message: QueryPolicyForAccountResponse): QueryPolicyForAccountResponseAmino;
    fromAminoMsg(object: QueryPolicyForAccountResponseAminoMsg): QueryPolicyForAccountResponse;
    fromProtoMsg(message: QueryPolicyForAccountResponseProtoMsg): QueryPolicyForAccountResponse;
    toProto(message: QueryPolicyForAccountResponse): Uint8Array;
    toProtoMsg(message: QueryPolicyForAccountResponse): QueryPolicyForAccountResponseProtoMsg;
};
export declare const QueryVerifyPermissionRequest: {
    typeUrl: string;
    encode(message: QueryVerifyPermissionRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerifyPermissionRequest;
    fromJSON(object: any): QueryVerifyPermissionRequest;
    toJSON(message: QueryVerifyPermissionRequest): unknown;
    fromPartial<I extends {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        actionType?: ActionType;
    } & {
        operator?: string;
        bucketName?: string;
        objectName?: string;
        actionType?: ActionType;
    } & Record<Exclude<keyof I, keyof QueryVerifyPermissionRequest>, never>>(object: I): QueryVerifyPermissionRequest;
    fromSDK(object: QueryVerifyPermissionRequestSDKType): QueryVerifyPermissionRequest;
    toSDK(message: QueryVerifyPermissionRequest): QueryVerifyPermissionRequestSDKType;
    fromAmino(object: QueryVerifyPermissionRequestAmino): QueryVerifyPermissionRequest;
    toAmino(message: QueryVerifyPermissionRequest): QueryVerifyPermissionRequestAmino;
    fromAminoMsg(object: QueryVerifyPermissionRequestAminoMsg): QueryVerifyPermissionRequest;
    fromProtoMsg(message: QueryVerifyPermissionRequestProtoMsg): QueryVerifyPermissionRequest;
    toProto(message: QueryVerifyPermissionRequest): Uint8Array;
    toProtoMsg(message: QueryVerifyPermissionRequest): QueryVerifyPermissionRequestProtoMsg;
};
export declare const QueryVerifyPermissionResponse: {
    typeUrl: string;
    encode(message: QueryVerifyPermissionResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryVerifyPermissionResponse;
    fromJSON(object: any): QueryVerifyPermissionResponse;
    toJSON(message: QueryVerifyPermissionResponse): unknown;
    fromPartial<I extends {
        effect?: Effect;
    } & {
        effect?: Effect;
    } & Record<Exclude<keyof I, "effect">, never>>(object: I): QueryVerifyPermissionResponse;
    fromSDK(object: QueryVerifyPermissionResponseSDKType): QueryVerifyPermissionResponse;
    toSDK(message: QueryVerifyPermissionResponse): QueryVerifyPermissionResponseSDKType;
    fromAmino(object: QueryVerifyPermissionResponseAmino): QueryVerifyPermissionResponse;
    toAmino(message: QueryVerifyPermissionResponse): QueryVerifyPermissionResponseAmino;
    fromAminoMsg(object: QueryVerifyPermissionResponseAminoMsg): QueryVerifyPermissionResponse;
    fromProtoMsg(message: QueryVerifyPermissionResponseProtoMsg): QueryVerifyPermissionResponse;
    toProto(message: QueryVerifyPermissionResponse): Uint8Array;
    toProtoMsg(message: QueryVerifyPermissionResponse): QueryVerifyPermissionResponseProtoMsg;
};
export declare const QueryHeadGroupRequest: {
    typeUrl: string;
    encode(message: QueryHeadGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupRequest;
    fromJSON(object: any): QueryHeadGroupRequest;
    toJSON(message: QueryHeadGroupRequest): unknown;
    fromPartial<I extends {
        groupOwner?: string;
        groupName?: string;
    } & {
        groupOwner?: string;
        groupName?: string;
    } & Record<Exclude<keyof I, keyof QueryHeadGroupRequest>, never>>(object: I): QueryHeadGroupRequest;
    fromSDK(object: QueryHeadGroupRequestSDKType): QueryHeadGroupRequest;
    toSDK(message: QueryHeadGroupRequest): QueryHeadGroupRequestSDKType;
    fromAmino(object: QueryHeadGroupRequestAmino): QueryHeadGroupRequest;
    toAmino(message: QueryHeadGroupRequest): QueryHeadGroupRequestAmino;
    fromAminoMsg(object: QueryHeadGroupRequestAminoMsg): QueryHeadGroupRequest;
    fromProtoMsg(message: QueryHeadGroupRequestProtoMsg): QueryHeadGroupRequest;
    toProto(message: QueryHeadGroupRequest): Uint8Array;
    toProtoMsg(message: QueryHeadGroupRequest): QueryHeadGroupRequestProtoMsg;
};
export declare const QueryHeadGroupResponse: {
    typeUrl: string;
    encode(message: QueryHeadGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupResponse;
    fromJSON(object: any): QueryHeadGroupResponse;
    toJSON(message: QueryHeadGroupResponse): unknown;
    fromPartial<I extends {
        groupInfo?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        };
    } & {
        groupInfo?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        } & {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            } & {
                tags?: {
                    key?: string;
                    value?: string;
                }[] & ({
                    key?: string;
                    value?: string;
                } & {
                    key?: string;
                    value?: string;
                } & Record<Exclude<keyof I["groupInfo"]["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["groupInfo"]["tags"]["tags"], keyof {
                    key?: string;
                    value?: string;
                }[]>, never>;
            } & Record<Exclude<keyof I["groupInfo"]["tags"], "tags">, never>;
        } & Record<Exclude<keyof I["groupInfo"], keyof GroupInfo>, never>;
    } & Record<Exclude<keyof I, "groupInfo">, never>>(object: I): QueryHeadGroupResponse;
    fromSDK(object: QueryHeadGroupResponseSDKType): QueryHeadGroupResponse;
    toSDK(message: QueryHeadGroupResponse): QueryHeadGroupResponseSDKType;
    fromAmino(object: QueryHeadGroupResponseAmino): QueryHeadGroupResponse;
    toAmino(message: QueryHeadGroupResponse): QueryHeadGroupResponseAmino;
    fromAminoMsg(object: QueryHeadGroupResponseAminoMsg): QueryHeadGroupResponse;
    fromProtoMsg(message: QueryHeadGroupResponseProtoMsg): QueryHeadGroupResponse;
    toProto(message: QueryHeadGroupResponse): Uint8Array;
    toProtoMsg(message: QueryHeadGroupResponse): QueryHeadGroupResponseProtoMsg;
};
export declare const QueryListGroupsRequest: {
    typeUrl: string;
    encode(message: QueryListGroupsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListGroupsRequest;
    fromJSON(object: any): QueryListGroupsRequest;
    toJSON(message: QueryListGroupsRequest): unknown;
    fromPartial<I extends {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
        groupOwner?: string;
    } & {
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | Long.Long;
            limit?: string | number | Long.Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof Long.Long>, never>);
            limit?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof Long.Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
        groupOwner?: string;
    } & Record<Exclude<keyof I, keyof QueryListGroupsRequest>, never>>(object: I): QueryListGroupsRequest;
    fromSDK(object: QueryListGroupsRequestSDKType): QueryListGroupsRequest;
    toSDK(message: QueryListGroupsRequest): QueryListGroupsRequestSDKType;
    fromAmino(object: QueryListGroupsRequestAmino): QueryListGroupsRequest;
    toAmino(message: QueryListGroupsRequest): QueryListGroupsRequestAmino;
    fromAminoMsg(object: QueryListGroupsRequestAminoMsg): QueryListGroupsRequest;
    fromProtoMsg(message: QueryListGroupsRequestProtoMsg): QueryListGroupsRequest;
    toProto(message: QueryListGroupsRequest): Uint8Array;
    toProtoMsg(message: QueryListGroupsRequest): QueryListGroupsRequestProtoMsg;
};
export declare const QueryListGroupsResponse: {
    typeUrl: string;
    encode(message: QueryListGroupsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryListGroupsResponse;
    fromJSON(object: any): QueryListGroupsResponse;
    toJSON(message: QueryListGroupsResponse): unknown;
    fromPartial<I extends {
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        };
        groupInfos?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[];
    } & {
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | Long.Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof Long.Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
        groupInfos?: {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[] & ({
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        } & {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            } & {
                tags?: {
                    key?: string;
                    value?: string;
                }[] & ({
                    key?: string;
                    value?: string;
                } & {
                    key?: string;
                    value?: string;
                } & Record<Exclude<keyof I["groupInfos"][number]["tags"]["tags"][number], keyof import("./types").ResourceTags_Tag>, never>)[] & Record<Exclude<keyof I["groupInfos"][number]["tags"]["tags"], keyof {
                    key?: string;
                    value?: string;
                }[]>, never>;
            } & Record<Exclude<keyof I["groupInfos"][number]["tags"], "tags">, never>;
        } & Record<Exclude<keyof I["groupInfos"][number], keyof GroupInfo>, never>)[] & Record<Exclude<keyof I["groupInfos"], keyof {
            owner?: string;
            groupName?: string;
            sourceType?: import("./common").SourceType;
            id?: string;
            extra?: string;
            tags?: {
                tags?: {
                    key?: string;
                    value?: string;
                }[];
            };
        }[]>, never>;
    } & Record<Exclude<keyof I, keyof QueryListGroupsResponse>, never>>(object: I): QueryListGroupsResponse;
    fromSDK(object: QueryListGroupsResponseSDKType): QueryListGroupsResponse;
    toSDK(message: QueryListGroupsResponse): QueryListGroupsResponseSDKType;
    fromAmino(object: QueryListGroupsResponseAmino): QueryListGroupsResponse;
    toAmino(message: QueryListGroupsResponse): QueryListGroupsResponseAmino;
    fromAminoMsg(object: QueryListGroupsResponseAminoMsg): QueryListGroupsResponse;
    fromProtoMsg(message: QueryListGroupsResponseProtoMsg): QueryListGroupsResponse;
    toProto(message: QueryListGroupsResponse): Uint8Array;
    toProtoMsg(message: QueryListGroupsResponse): QueryListGroupsResponseProtoMsg;
};
export declare const QueryHeadGroupMemberRequest: {
    typeUrl: string;
    encode(message: QueryHeadGroupMemberRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupMemberRequest;
    fromJSON(object: any): QueryHeadGroupMemberRequest;
    toJSON(message: QueryHeadGroupMemberRequest): unknown;
    fromPartial<I extends {
        member?: string;
        groupOwner?: string;
        groupName?: string;
    } & {
        member?: string;
        groupOwner?: string;
        groupName?: string;
    } & Record<Exclude<keyof I, keyof QueryHeadGroupMemberRequest>, never>>(object: I): QueryHeadGroupMemberRequest;
    fromSDK(object: QueryHeadGroupMemberRequestSDKType): QueryHeadGroupMemberRequest;
    toSDK(message: QueryHeadGroupMemberRequest): QueryHeadGroupMemberRequestSDKType;
    fromAmino(object: QueryHeadGroupMemberRequestAmino): QueryHeadGroupMemberRequest;
    toAmino(message: QueryHeadGroupMemberRequest): QueryHeadGroupMemberRequestAmino;
    fromAminoMsg(object: QueryHeadGroupMemberRequestAminoMsg): QueryHeadGroupMemberRequest;
    fromProtoMsg(message: QueryHeadGroupMemberRequestProtoMsg): QueryHeadGroupMemberRequest;
    toProto(message: QueryHeadGroupMemberRequest): Uint8Array;
    toProtoMsg(message: QueryHeadGroupMemberRequest): QueryHeadGroupMemberRequestProtoMsg;
};
export declare const QueryHeadGroupMemberResponse: {
    typeUrl: string;
    encode(message: QueryHeadGroupMemberResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadGroupMemberResponse;
    fromJSON(object: any): QueryHeadGroupMemberResponse;
    toJSON(message: QueryHeadGroupMemberResponse): unknown;
    fromPartial<I extends {
        groupMember?: {
            id?: string;
            groupId?: string;
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        groupMember?: {
            id?: string;
            groupId?: string;
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            groupId?: string;
            member?: string;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["groupMember"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["groupMember"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["groupMember"], keyof GroupMember>, never>;
    } & Record<Exclude<keyof I, "groupMember">, never>>(object: I): QueryHeadGroupMemberResponse;
    fromSDK(object: QueryHeadGroupMemberResponseSDKType): QueryHeadGroupMemberResponse;
    toSDK(message: QueryHeadGroupMemberResponse): QueryHeadGroupMemberResponseSDKType;
    fromAmino(object: QueryHeadGroupMemberResponseAmino): QueryHeadGroupMemberResponse;
    toAmino(message: QueryHeadGroupMemberResponse): QueryHeadGroupMemberResponseAmino;
    fromAminoMsg(object: QueryHeadGroupMemberResponseAminoMsg): QueryHeadGroupMemberResponse;
    fromProtoMsg(message: QueryHeadGroupMemberResponseProtoMsg): QueryHeadGroupMemberResponse;
    toProto(message: QueryHeadGroupMemberResponse): Uint8Array;
    toProtoMsg(message: QueryHeadGroupMemberResponse): QueryHeadGroupMemberResponseProtoMsg;
};
export declare const QueryPolicyForGroupRequest: {
    typeUrl: string;
    encode(message: QueryPolicyForGroupRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForGroupRequest;
    fromJSON(object: any): QueryPolicyForGroupRequest;
    toJSON(message: QueryPolicyForGroupRequest): unknown;
    fromPartial<I extends {
        resource?: string;
        principalGroupId?: string;
    } & {
        resource?: string;
        principalGroupId?: string;
    } & Record<Exclude<keyof I, keyof QueryPolicyForGroupRequest>, never>>(object: I): QueryPolicyForGroupRequest;
    fromSDK(object: QueryPolicyForGroupRequestSDKType): QueryPolicyForGroupRequest;
    toSDK(message: QueryPolicyForGroupRequest): QueryPolicyForGroupRequestSDKType;
    fromAmino(object: QueryPolicyForGroupRequestAmino): QueryPolicyForGroupRequest;
    toAmino(message: QueryPolicyForGroupRequest): QueryPolicyForGroupRequestAmino;
    fromAminoMsg(object: QueryPolicyForGroupRequestAminoMsg): QueryPolicyForGroupRequest;
    fromProtoMsg(message: QueryPolicyForGroupRequestProtoMsg): QueryPolicyForGroupRequest;
    toProto(message: QueryPolicyForGroupRequest): Uint8Array;
    toProtoMsg(message: QueryPolicyForGroupRequest): QueryPolicyForGroupRequestProtoMsg;
};
export declare const QueryPolicyForGroupResponse: {
    typeUrl: string;
    encode(message: QueryPolicyForGroupResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyForGroupResponse;
    fromJSON(object: any): QueryPolicyForGroupResponse;
    toJSON(message: QueryPolicyForGroupResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>;
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[] & ({
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            } & {
                effect?: Effect;
                actions?: ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>;
                resources?: string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>;
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                } & {
                    seconds?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                    nanos?: number;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
                limitSize?: {
                    value?: string | number | Long.Long;
                } & {
                    value?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>);
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[]>, never>;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyForGroupResponse;
    fromSDK(object: QueryPolicyForGroupResponseSDKType): QueryPolicyForGroupResponse;
    toSDK(message: QueryPolicyForGroupResponse): QueryPolicyForGroupResponseSDKType;
    fromAmino(object: QueryPolicyForGroupResponseAmino): QueryPolicyForGroupResponse;
    toAmino(message: QueryPolicyForGroupResponse): QueryPolicyForGroupResponseAmino;
    fromAminoMsg(object: QueryPolicyForGroupResponseAminoMsg): QueryPolicyForGroupResponse;
    fromProtoMsg(message: QueryPolicyForGroupResponseProtoMsg): QueryPolicyForGroupResponse;
    toProto(message: QueryPolicyForGroupResponse): Uint8Array;
    toProtoMsg(message: QueryPolicyForGroupResponse): QueryPolicyForGroupResponseProtoMsg;
};
export declare const QueryPolicyByIdRequest: {
    typeUrl: string;
    encode(message: QueryPolicyByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyByIdRequest;
    fromJSON(object: any): QueryPolicyByIdRequest;
    toJSON(message: QueryPolicyByIdRequest): unknown;
    fromPartial<I extends {
        policyId?: string;
    } & {
        policyId?: string;
    } & Record<Exclude<keyof I, "policyId">, never>>(object: I): QueryPolicyByIdRequest;
    fromSDK(object: QueryPolicyByIdRequestSDKType): QueryPolicyByIdRequest;
    toSDK(message: QueryPolicyByIdRequest): QueryPolicyByIdRequestSDKType;
    fromAmino(object: QueryPolicyByIdRequestAmino): QueryPolicyByIdRequest;
    toAmino(message: QueryPolicyByIdRequest): QueryPolicyByIdRequestAmino;
    fromAminoMsg(object: QueryPolicyByIdRequestAminoMsg): QueryPolicyByIdRequest;
    fromProtoMsg(message: QueryPolicyByIdRequestProtoMsg): QueryPolicyByIdRequest;
    toProto(message: QueryPolicyByIdRequest): Uint8Array;
    toProtoMsg(message: QueryPolicyByIdRequest): QueryPolicyByIdRequestProtoMsg;
};
export declare const QueryPolicyByIdResponse: {
    typeUrl: string;
    encode(message: QueryPolicyByIdResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryPolicyByIdResponse;
    fromJSON(object: any): QueryPolicyByIdResponse;
    toJSON(message: QueryPolicyByIdResponse): unknown;
    fromPartial<I extends {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        };
    } & {
        policy?: {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            };
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[];
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            };
        } & {
            id?: string;
            principal?: {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & {
                type?: import("../permission/common").PrincipalType;
                value?: string;
            } & Record<Exclude<keyof I["policy"]["principal"], keyof import("../permission/common").Principal>, never>;
            resourceType?: import("../resource/types").ResourceType;
            resourceId?: string;
            statements?: {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[] & ({
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            } & {
                effect?: Effect;
                actions?: ActionType[] & ActionType[] & Record<Exclude<keyof I["policy"]["statements"][number]["actions"], keyof ActionType[]>, never>;
                resources?: string[] & string[] & Record<Exclude<keyof I["policy"]["statements"][number]["resources"], keyof string[]>, never>;
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                } & {
                    seconds?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                    nanos?: number;
                } & Record<Exclude<keyof I["policy"]["statements"][number]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
                limitSize?: {
                    value?: string | number | Long.Long;
                } & {
                    value?: string | number | (Long.Long & {
                        high: number;
                        low: number;
                        unsigned: boolean;
                        add: (addend: string | number | Long.Long) => Long.Long;
                        and: (other: string | number | Long.Long) => Long.Long;
                        compare: (other: string | number | Long.Long) => number;
                        comp: (other: string | number | Long.Long) => number;
                        divide: (divisor: string | number | Long.Long) => Long.Long;
                        div: (divisor: string | number | Long.Long) => Long.Long;
                        equals: (other: string | number | Long.Long) => boolean;
                        eq: (other: string | number | Long.Long) => boolean;
                        getHighBits: () => number;
                        getHighBitsUnsigned: () => number;
                        getLowBits: () => number;
                        getLowBitsUnsigned: () => number;
                        getNumBitsAbs: () => number;
                        greaterThan: (other: string | number | Long.Long) => boolean;
                        gt: (other: string | number | Long.Long) => boolean;
                        greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                        gte: (other: string | number | Long.Long) => boolean;
                        isEven: () => boolean;
                        isNegative: () => boolean;
                        isOdd: () => boolean;
                        isPositive: () => boolean;
                        isZero: () => boolean;
                        lessThan: (other: string | number | Long.Long) => boolean;
                        lt: (other: string | number | Long.Long) => boolean;
                        lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                        lte: (other: string | number | Long.Long) => boolean;
                        modulo: (other: string | number | Long.Long) => Long.Long;
                        mod: (other: string | number | Long.Long) => Long.Long;
                        multiply: (multiplier: string | number | Long.Long) => Long.Long;
                        mul: (multiplier: string | number | Long.Long) => Long.Long;
                        negate: () => Long.Long;
                        neg: () => Long.Long;
                        not: () => Long.Long;
                        notEquals: (other: string | number | Long.Long) => boolean;
                        neq: (other: string | number | Long.Long) => boolean;
                        or: (other: string | number | Long.Long) => Long.Long;
                        shiftLeft: (numBits: number | Long.Long) => Long.Long;
                        shl: (numBits: number | Long.Long) => Long.Long;
                        shiftRight: (numBits: number | Long.Long) => Long.Long;
                        shr: (numBits: number | Long.Long) => Long.Long;
                        shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                        shru: (numBits: number | Long.Long) => Long.Long;
                        subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                        sub: (subtrahend: string | number | Long.Long) => Long.Long;
                        toInt: () => number;
                        toNumber: () => number;
                        toBytes: (le?: boolean) => number[];
                        toBytesLE: () => number[];
                        toBytesBE: () => number[];
                        toSigned: () => Long.Long;
                        toString: (radix?: number) => string;
                        toUnsigned: () => Long.Long;
                        xor: (other: string | number | Long.Long) => Long.Long;
                    } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"]["value"], keyof Long.Long>, never>);
                } & Record<Exclude<keyof I["policy"]["statements"][number]["limitSize"], "value">, never>;
            } & Record<Exclude<keyof I["policy"]["statements"][number], keyof import("../permission/common").Statement>, never>)[] & Record<Exclude<keyof I["policy"]["statements"], keyof {
                effect?: Effect;
                actions?: ActionType[];
                resources?: string[];
                expirationTime?: {
                    seconds?: string | number | Long.Long;
                    nanos?: number;
                };
                limitSize?: {
                    value?: string | number | Long.Long;
                };
            }[]>, never>;
            expirationTime?: {
                seconds?: string | number | Long.Long;
                nanos?: number;
            } & {
                seconds?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["policy"]["expirationTime"]["seconds"], keyof Long.Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["policy"]["expirationTime"], keyof import("../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["policy"], keyof Policy>, never>;
    } & Record<Exclude<keyof I, "policy">, never>>(object: I): QueryPolicyByIdResponse;
    fromSDK(object: QueryPolicyByIdResponseSDKType): QueryPolicyByIdResponse;
    toSDK(message: QueryPolicyByIdResponse): QueryPolicyByIdResponseSDKType;
    fromAmino(object: QueryPolicyByIdResponseAmino): QueryPolicyByIdResponse;
    toAmino(message: QueryPolicyByIdResponse): QueryPolicyByIdResponseAmino;
    fromAminoMsg(object: QueryPolicyByIdResponseAminoMsg): QueryPolicyByIdResponse;
    fromProtoMsg(message: QueryPolicyByIdResponseProtoMsg): QueryPolicyByIdResponse;
    toProto(message: QueryPolicyByIdResponse): Uint8Array;
    toProtoMsg(message: QueryPolicyByIdResponse): QueryPolicyByIdResponseProtoMsg;
};
export declare const QueryLockFeeRequest: {
    typeUrl: string;
    encode(message: QueryLockFeeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryLockFeeRequest;
    fromJSON(object: any): QueryLockFeeRequest;
    toJSON(message: QueryLockFeeRequest): unknown;
    fromPartial<I extends {
        primarySpAddress?: string;
        createAt?: string | number | Long.Long;
        payloadSize?: string | number | Long.Long;
    } & {
        primarySpAddress?: string;
        createAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["createAt"], keyof Long.Long>, never>);
        payloadSize?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["payloadSize"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, keyof QueryLockFeeRequest>, never>>(object: I): QueryLockFeeRequest;
    fromSDK(object: QueryLockFeeRequestSDKType): QueryLockFeeRequest;
    toSDK(message: QueryLockFeeRequest): QueryLockFeeRequestSDKType;
    fromAmino(object: QueryLockFeeRequestAmino): QueryLockFeeRequest;
    toAmino(message: QueryLockFeeRequest): QueryLockFeeRequestAmino;
    fromAminoMsg(object: QueryLockFeeRequestAminoMsg): QueryLockFeeRequest;
    fromProtoMsg(message: QueryLockFeeRequestProtoMsg): QueryLockFeeRequest;
    toProto(message: QueryLockFeeRequest): Uint8Array;
    toProtoMsg(message: QueryLockFeeRequest): QueryLockFeeRequestProtoMsg;
};
export declare const QueryLockFeeResponse: {
    typeUrl: string;
    encode(message: QueryLockFeeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryLockFeeResponse;
    fromJSON(object: any): QueryLockFeeResponse;
    toJSON(message: QueryLockFeeResponse): unknown;
    fromPartial<I extends {
        amount?: string;
    } & {
        amount?: string;
    } & Record<Exclude<keyof I, "amount">, never>>(object: I): QueryLockFeeResponse;
    fromSDK(object: QueryLockFeeResponseSDKType): QueryLockFeeResponse;
    toSDK(message: QueryLockFeeResponse): QueryLockFeeResponseSDKType;
    fromAmino(object: QueryLockFeeResponseAmino): QueryLockFeeResponse;
    toAmino(message: QueryLockFeeResponse): QueryLockFeeResponseAmino;
    fromAminoMsg(object: QueryLockFeeResponseAminoMsg): QueryLockFeeResponse;
    fromProtoMsg(message: QueryLockFeeResponseProtoMsg): QueryLockFeeResponse;
    toProto(message: QueryLockFeeResponse): Uint8Array;
    toProtoMsg(message: QueryLockFeeResponse): QueryLockFeeResponseProtoMsg;
};
export declare const QueryHeadBucketExtraRequest: {
    typeUrl: string;
    encode(message: QueryHeadBucketExtraRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketExtraRequest;
    fromJSON(object: any): QueryHeadBucketExtraRequest;
    toJSON(message: QueryHeadBucketExtraRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryHeadBucketExtraRequest;
    fromSDK(object: QueryHeadBucketExtraRequestSDKType): QueryHeadBucketExtraRequest;
    toSDK(message: QueryHeadBucketExtraRequest): QueryHeadBucketExtraRequestSDKType;
    fromAmino(object: QueryHeadBucketExtraRequestAmino): QueryHeadBucketExtraRequest;
    toAmino(message: QueryHeadBucketExtraRequest): QueryHeadBucketExtraRequestAmino;
    fromAminoMsg(object: QueryHeadBucketExtraRequestAminoMsg): QueryHeadBucketExtraRequest;
    fromProtoMsg(message: QueryHeadBucketExtraRequestProtoMsg): QueryHeadBucketExtraRequest;
    toProto(message: QueryHeadBucketExtraRequest): Uint8Array;
    toProtoMsg(message: QueryHeadBucketExtraRequest): QueryHeadBucketExtraRequestProtoMsg;
};
export declare const QueryHeadBucketExtraResponse: {
    typeUrl: string;
    encode(message: QueryHeadBucketExtraResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryHeadBucketExtraResponse;
    fromJSON(object: any): QueryHeadBucketExtraResponse;
    toJSON(message: QueryHeadBucketExtraResponse): unknown;
    fromPartial<I extends {
        extraInfo?: {
            priceTime?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
            localVirtualGroups?: {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[];
            nextLocalVirtualGroupId?: number;
        };
    } & {
        extraInfo?: {
            priceTime?: string | number | Long.Long;
            totalChargeSize?: string | number | Long.Long;
            localVirtualGroups?: {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[];
            nextLocalVirtualGroupId?: number;
        } & {
            priceTime?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["extraInfo"]["priceTime"], keyof Long.Long>, never>);
            totalChargeSize?: string | number | (Long.Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | Long.Long) => Long.Long;
                and: (other: string | number | Long.Long) => Long.Long;
                compare: (other: string | number | Long.Long) => number;
                comp: (other: string | number | Long.Long) => number;
                divide: (divisor: string | number | Long.Long) => Long.Long;
                div: (divisor: string | number | Long.Long) => Long.Long;
                equals: (other: string | number | Long.Long) => boolean;
                eq: (other: string | number | Long.Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | Long.Long) => boolean;
                gt: (other: string | number | Long.Long) => boolean;
                greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                gte: (other: string | number | Long.Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | Long.Long) => boolean;
                lt: (other: string | number | Long.Long) => boolean;
                lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                lte: (other: string | number | Long.Long) => boolean;
                modulo: (other: string | number | Long.Long) => Long.Long;
                mod: (other: string | number | Long.Long) => Long.Long;
                multiply: (multiplier: string | number | Long.Long) => Long.Long;
                mul: (multiplier: string | number | Long.Long) => Long.Long;
                negate: () => Long.Long;
                neg: () => Long.Long;
                not: () => Long.Long;
                notEquals: (other: string | number | Long.Long) => boolean;
                neq: (other: string | number | Long.Long) => boolean;
                or: (other: string | number | Long.Long) => Long.Long;
                shiftLeft: (numBits: number | Long.Long) => Long.Long;
                shl: (numBits: number | Long.Long) => Long.Long;
                shiftRight: (numBits: number | Long.Long) => Long.Long;
                shr: (numBits: number | Long.Long) => Long.Long;
                shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                shru: (numBits: number | Long.Long) => Long.Long;
                subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                sub: (subtrahend: string | number | Long.Long) => Long.Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => Long.Long;
                toString: (radix?: number) => string;
                toUnsigned: () => Long.Long;
                xor: (other: string | number | Long.Long) => Long.Long;
            } & Record<Exclude<keyof I["extraInfo"]["totalChargeSize"], keyof Long.Long>, never>);
            localVirtualGroups?: {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[] & ({
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            } & {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"][number]["storedSize"], keyof Long.Long>, never>);
                totalChargeSize?: string | number | (Long.Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | Long.Long) => Long.Long;
                    and: (other: string | number | Long.Long) => Long.Long;
                    compare: (other: string | number | Long.Long) => number;
                    comp: (other: string | number | Long.Long) => number;
                    divide: (divisor: string | number | Long.Long) => Long.Long;
                    div: (divisor: string | number | Long.Long) => Long.Long;
                    equals: (other: string | number | Long.Long) => boolean;
                    eq: (other: string | number | Long.Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | Long.Long) => boolean;
                    gt: (other: string | number | Long.Long) => boolean;
                    greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
                    gte: (other: string | number | Long.Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | Long.Long) => boolean;
                    lt: (other: string | number | Long.Long) => boolean;
                    lessThanOrEqual: (other: string | number | Long.Long) => boolean;
                    lte: (other: string | number | Long.Long) => boolean;
                    modulo: (other: string | number | Long.Long) => Long.Long;
                    mod: (other: string | number | Long.Long) => Long.Long;
                    multiply: (multiplier: string | number | Long.Long) => Long.Long;
                    mul: (multiplier: string | number | Long.Long) => Long.Long;
                    negate: () => Long.Long;
                    neg: () => Long.Long;
                    not: () => Long.Long;
                    notEquals: (other: string | number | Long.Long) => boolean;
                    neq: (other: string | number | Long.Long) => boolean;
                    or: (other: string | number | Long.Long) => Long.Long;
                    shiftLeft: (numBits: number | Long.Long) => Long.Long;
                    shl: (numBits: number | Long.Long) => Long.Long;
                    shiftRight: (numBits: number | Long.Long) => Long.Long;
                    shr: (numBits: number | Long.Long) => Long.Long;
                    shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
                    shru: (numBits: number | Long.Long) => Long.Long;
                    subtract: (subtrahend: string | number | Long.Long) => Long.Long;
                    sub: (subtrahend: string | number | Long.Long) => Long.Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => Long.Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => Long.Long;
                    xor: (other: string | number | Long.Long) => Long.Long;
                } & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"][number]["totalChargeSize"], keyof Long.Long>, never>);
            } & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"][number], keyof import("./common").LocalVirtualGroup>, never>)[] & Record<Exclude<keyof I["extraInfo"]["localVirtualGroups"], keyof {
                id?: number;
                globalVirtualGroupId?: number;
                storedSize?: string | number | Long.Long;
                totalChargeSize?: string | number | Long.Long;
            }[]>, never>;
            nextLocalVirtualGroupId?: number;
        } & Record<Exclude<keyof I["extraInfo"], keyof InternalBucketInfo>, never>;
    } & Record<Exclude<keyof I, "extraInfo">, never>>(object: I): QueryHeadBucketExtraResponse;
    fromSDK(object: QueryHeadBucketExtraResponseSDKType): QueryHeadBucketExtraResponse;
    toSDK(message: QueryHeadBucketExtraResponse): QueryHeadBucketExtraResponseSDKType;
    fromAmino(object: QueryHeadBucketExtraResponseAmino): QueryHeadBucketExtraResponse;
    toAmino(message: QueryHeadBucketExtraResponse): QueryHeadBucketExtraResponseAmino;
    fromAminoMsg(object: QueryHeadBucketExtraResponseAminoMsg): QueryHeadBucketExtraResponse;
    fromProtoMsg(message: QueryHeadBucketExtraResponseProtoMsg): QueryHeadBucketExtraResponse;
    toProto(message: QueryHeadBucketExtraResponse): Uint8Array;
    toProtoMsg(message: QueryHeadBucketExtraResponse): QueryHeadBucketExtraResponseProtoMsg;
};
export declare const QueryIsPriceChangedRequest: {
    typeUrl: string;
    encode(message: QueryIsPriceChangedRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsPriceChangedRequest;
    fromJSON(object: any): QueryIsPriceChangedRequest;
    toJSON(message: QueryIsPriceChangedRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryIsPriceChangedRequest;
    fromSDK(object: QueryIsPriceChangedRequestSDKType): QueryIsPriceChangedRequest;
    toSDK(message: QueryIsPriceChangedRequest): QueryIsPriceChangedRequestSDKType;
    fromAmino(object: QueryIsPriceChangedRequestAmino): QueryIsPriceChangedRequest;
    toAmino(message: QueryIsPriceChangedRequest): QueryIsPriceChangedRequestAmino;
    fromAminoMsg(object: QueryIsPriceChangedRequestAminoMsg): QueryIsPriceChangedRequest;
    fromProtoMsg(message: QueryIsPriceChangedRequestProtoMsg): QueryIsPriceChangedRequest;
    toProto(message: QueryIsPriceChangedRequest): Uint8Array;
    toProtoMsg(message: QueryIsPriceChangedRequest): QueryIsPriceChangedRequestProtoMsg;
};
export declare const QueryIsPriceChangedResponse: {
    typeUrl: string;
    encode(message: QueryIsPriceChangedResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryIsPriceChangedResponse;
    fromJSON(object: any): QueryIsPriceChangedResponse;
    toJSON(message: QueryIsPriceChangedResponse): unknown;
    fromPartial<I extends {
        changed?: boolean;
        currentReadPrice?: string;
        currentPrimaryStorePrice?: string;
        currentSecondaryStorePrice?: string;
        currentValidatorTaxRate?: string;
        newReadPrice?: string;
        newPrimaryStorePrice?: string;
        newSecondaryStorePrice?: string;
        newValidatorTaxRate?: string;
    } & {
        changed?: boolean;
        currentReadPrice?: string;
        currentPrimaryStorePrice?: string;
        currentSecondaryStorePrice?: string;
        currentValidatorTaxRate?: string;
        newReadPrice?: string;
        newPrimaryStorePrice?: string;
        newSecondaryStorePrice?: string;
        newValidatorTaxRate?: string;
    } & Record<Exclude<keyof I, keyof QueryIsPriceChangedResponse>, never>>(object: I): QueryIsPriceChangedResponse;
    fromSDK(object: QueryIsPriceChangedResponseSDKType): QueryIsPriceChangedResponse;
    toSDK(message: QueryIsPriceChangedResponse): QueryIsPriceChangedResponseSDKType;
    fromAmino(object: QueryIsPriceChangedResponseAmino): QueryIsPriceChangedResponse;
    toAmino(message: QueryIsPriceChangedResponse): QueryIsPriceChangedResponseAmino;
    fromAminoMsg(object: QueryIsPriceChangedResponseAminoMsg): QueryIsPriceChangedResponse;
    fromProtoMsg(message: QueryIsPriceChangedResponseProtoMsg): QueryIsPriceChangedResponse;
    toProto(message: QueryIsPriceChangedResponse): Uint8Array;
    toProtoMsg(message: QueryIsPriceChangedResponse): QueryIsPriceChangedResponseProtoMsg;
};
export declare const QueryQuoteUpdateTimeRequest: {
    typeUrl: string;
    encode(message: QueryQuoteUpdateTimeRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryQuoteUpdateTimeRequest;
    fromJSON(object: any): QueryQuoteUpdateTimeRequest;
    toJSON(message: QueryQuoteUpdateTimeRequest): unknown;
    fromPartial<I extends {
        bucketName?: string;
    } & {
        bucketName?: string;
    } & Record<Exclude<keyof I, "bucketName">, never>>(object: I): QueryQuoteUpdateTimeRequest;
    fromSDK(object: QueryQuoteUpdateTimeRequestSDKType): QueryQuoteUpdateTimeRequest;
    toSDK(message: QueryQuoteUpdateTimeRequest): QueryQuoteUpdateTimeRequestSDKType;
    fromAmino(object: QueryQuoteUpdateTimeRequestAmino): QueryQuoteUpdateTimeRequest;
    toAmino(message: QueryQuoteUpdateTimeRequest): QueryQuoteUpdateTimeRequestAmino;
    fromAminoMsg(object: QueryQuoteUpdateTimeRequestAminoMsg): QueryQuoteUpdateTimeRequest;
    fromProtoMsg(message: QueryQuoteUpdateTimeRequestProtoMsg): QueryQuoteUpdateTimeRequest;
    toProto(message: QueryQuoteUpdateTimeRequest): Uint8Array;
    toProtoMsg(message: QueryQuoteUpdateTimeRequest): QueryQuoteUpdateTimeRequestProtoMsg;
};
export declare const QueryQuoteUpdateTimeResponse: {
    typeUrl: string;
    encode(message: QueryQuoteUpdateTimeResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryQuoteUpdateTimeResponse;
    fromJSON(object: any): QueryQuoteUpdateTimeResponse;
    toJSON(message: QueryQuoteUpdateTimeResponse): unknown;
    fromPartial<I extends {
        updateAt?: string | number | Long.Long;
    } & {
        updateAt?: string | number | (Long.Long & {
            high: number;
            low: number;
            unsigned: boolean;
            add: (addend: string | number | Long.Long) => Long.Long;
            and: (other: string | number | Long.Long) => Long.Long;
            compare: (other: string | number | Long.Long) => number;
            comp: (other: string | number | Long.Long) => number;
            divide: (divisor: string | number | Long.Long) => Long.Long;
            div: (divisor: string | number | Long.Long) => Long.Long;
            equals: (other: string | number | Long.Long) => boolean;
            eq: (other: string | number | Long.Long) => boolean;
            getHighBits: () => number;
            getHighBitsUnsigned: () => number;
            getLowBits: () => number;
            getLowBitsUnsigned: () => number;
            getNumBitsAbs: () => number;
            greaterThan: (other: string | number | Long.Long) => boolean;
            gt: (other: string | number | Long.Long) => boolean;
            greaterThanOrEqual: (other: string | number | Long.Long) => boolean;
            gte: (other: string | number | Long.Long) => boolean;
            isEven: () => boolean;
            isNegative: () => boolean;
            isOdd: () => boolean;
            isPositive: () => boolean;
            isZero: () => boolean;
            lessThan: (other: string | number | Long.Long) => boolean;
            lt: (other: string | number | Long.Long) => boolean;
            lessThanOrEqual: (other: string | number | Long.Long) => boolean;
            lte: (other: string | number | Long.Long) => boolean;
            modulo: (other: string | number | Long.Long) => Long.Long;
            mod: (other: string | number | Long.Long) => Long.Long;
            multiply: (multiplier: string | number | Long.Long) => Long.Long;
            mul: (multiplier: string | number | Long.Long) => Long.Long;
            negate: () => Long.Long;
            neg: () => Long.Long;
            not: () => Long.Long;
            notEquals: (other: string | number | Long.Long) => boolean;
            neq: (other: string | number | Long.Long) => boolean;
            or: (other: string | number | Long.Long) => Long.Long;
            shiftLeft: (numBits: number | Long.Long) => Long.Long;
            shl: (numBits: number | Long.Long) => Long.Long;
            shiftRight: (numBits: number | Long.Long) => Long.Long;
            shr: (numBits: number | Long.Long) => Long.Long;
            shiftRightUnsigned: (numBits: number | Long.Long) => Long.Long;
            shru: (numBits: number | Long.Long) => Long.Long;
            subtract: (subtrahend: string | number | Long.Long) => Long.Long;
            sub: (subtrahend: string | number | Long.Long) => Long.Long;
            toInt: () => number;
            toNumber: () => number;
            toBytes: (le?: boolean) => number[];
            toBytesLE: () => number[];
            toBytesBE: () => number[];
            toSigned: () => Long.Long;
            toString: (radix?: number) => string;
            toUnsigned: () => Long.Long;
            xor: (other: string | number | Long.Long) => Long.Long;
        } & Record<Exclude<keyof I["updateAt"], keyof Long.Long>, never>);
    } & Record<Exclude<keyof I, "updateAt">, never>>(object: I): QueryQuoteUpdateTimeResponse;
    fromSDK(object: QueryQuoteUpdateTimeResponseSDKType): QueryQuoteUpdateTimeResponse;
    toSDK(message: QueryQuoteUpdateTimeResponse): QueryQuoteUpdateTimeResponseSDKType;
    fromAmino(object: QueryQuoteUpdateTimeResponseAmino): QueryQuoteUpdateTimeResponse;
    toAmino(message: QueryQuoteUpdateTimeResponse): QueryQuoteUpdateTimeResponseAmino;
    fromAminoMsg(object: QueryQuoteUpdateTimeResponseAminoMsg): QueryQuoteUpdateTimeResponse;
    fromProtoMsg(message: QueryQuoteUpdateTimeResponseProtoMsg): QueryQuoteUpdateTimeResponse;
    toProto(message: QueryQuoteUpdateTimeResponse): Uint8Array;
    toProtoMsg(message: QueryQuoteUpdateTimeResponse): QueryQuoteUpdateTimeResponseProtoMsg;
};
export declare const QueryGroupMembersExistRequest: {
    typeUrl: string;
    encode(message: QueryGroupMembersExistRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupMembersExistRequest;
    fromJSON(object: any): QueryGroupMembersExistRequest;
    toJSON(message: QueryGroupMembersExistRequest): unknown;
    fromPartial<I extends {
        groupId?: string;
        members?: string[];
    } & {
        groupId?: string;
        members?: string[] & string[] & Record<Exclude<keyof I["members"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, keyof QueryGroupMembersExistRequest>, never>>(object: I): QueryGroupMembersExistRequest;
    fromSDK(object: QueryGroupMembersExistRequestSDKType): QueryGroupMembersExistRequest;
    toSDK(message: QueryGroupMembersExistRequest): QueryGroupMembersExistRequestSDKType;
    fromAmino(object: QueryGroupMembersExistRequestAmino): QueryGroupMembersExistRequest;
    toAmino(message: QueryGroupMembersExistRequest): QueryGroupMembersExistRequestAmino;
    fromAminoMsg(object: QueryGroupMembersExistRequestAminoMsg): QueryGroupMembersExistRequest;
    fromProtoMsg(message: QueryGroupMembersExistRequestProtoMsg): QueryGroupMembersExistRequest;
    toProto(message: QueryGroupMembersExistRequest): Uint8Array;
    toProtoMsg(message: QueryGroupMembersExistRequest): QueryGroupMembersExistRequestProtoMsg;
};
export declare const QueryGroupMembersExistResponse_ExistsEntry: {
    encode(message: QueryGroupMembersExistResponse_ExistsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupMembersExistResponse_ExistsEntry;
    fromJSON(object: any): QueryGroupMembersExistResponse_ExistsEntry;
    toJSON(message: QueryGroupMembersExistResponse_ExistsEntry): unknown;
    fromPartial<I extends {
        key?: string;
        value?: boolean;
    } & {
        key?: string;
        value?: boolean;
    } & Record<Exclude<keyof I, keyof QueryGroupMembersExistResponse_ExistsEntry>, never>>(object: I): QueryGroupMembersExistResponse_ExistsEntry;
    fromSDK(object: QueryGroupMembersExistResponse_ExistsEntrySDKType): QueryGroupMembersExistResponse_ExistsEntry;
    toSDK(message: QueryGroupMembersExistResponse_ExistsEntry): QueryGroupMembersExistResponse_ExistsEntrySDKType;
    fromAmino(object: QueryGroupMembersExistResponse_ExistsEntryAmino): QueryGroupMembersExistResponse_ExistsEntry;
    toAmino(message: QueryGroupMembersExistResponse_ExistsEntry): QueryGroupMembersExistResponse_ExistsEntryAmino;
    fromAminoMsg(object: QueryGroupMembersExistResponse_ExistsEntryAminoMsg): QueryGroupMembersExistResponse_ExistsEntry;
    fromProtoMsg(message: QueryGroupMembersExistResponse_ExistsEntryProtoMsg): QueryGroupMembersExistResponse_ExistsEntry;
    toProto(message: QueryGroupMembersExistResponse_ExistsEntry): Uint8Array;
};
export declare const QueryGroupMembersExistResponse: {
    typeUrl: string;
    encode(message: QueryGroupMembersExistResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupMembersExistResponse;
    fromJSON(object: any): QueryGroupMembersExistResponse;
    toJSON(message: QueryGroupMembersExistResponse): unknown;
    fromPartial<I extends {
        exists?: {
            [x: string]: boolean;
        };
    } & {
        exists?: {
            [x: string]: boolean;
        } & {
            [x: string]: boolean;
        } & Record<Exclude<keyof I["exists"], string | number>, never>;
    } & Record<Exclude<keyof I, "exists">, never>>(object: I): QueryGroupMembersExistResponse;
    fromSDK(object: QueryGroupMembersExistResponseSDKType): QueryGroupMembersExistResponse;
    toSDK(message: QueryGroupMembersExistResponse): QueryGroupMembersExistResponseSDKType;
    fromAmino(object: QueryGroupMembersExistResponseAmino): QueryGroupMembersExistResponse;
    toAmino(message: QueryGroupMembersExistResponse): QueryGroupMembersExistResponseAmino;
    fromAminoMsg(object: QueryGroupMembersExistResponseAminoMsg): QueryGroupMembersExistResponse;
    fromProtoMsg(message: QueryGroupMembersExistResponseProtoMsg): QueryGroupMembersExistResponse;
    toProto(message: QueryGroupMembersExistResponse): Uint8Array;
    toProtoMsg(message: QueryGroupMembersExistResponse): QueryGroupMembersExistResponseProtoMsg;
};
export declare const QueryGroupsExistRequest: {
    typeUrl: string;
    encode(message: QueryGroupsExistRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistRequest;
    fromJSON(object: any): QueryGroupsExistRequest;
    toJSON(message: QueryGroupsExistRequest): unknown;
    fromPartial<I extends {
        groupOwner?: string;
        groupNames?: string[];
    } & {
        groupOwner?: string;
        groupNames?: string[] & string[] & Record<Exclude<keyof I["groupNames"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, keyof QueryGroupsExistRequest>, never>>(object: I): QueryGroupsExistRequest;
    fromSDK(object: QueryGroupsExistRequestSDKType): QueryGroupsExistRequest;
    toSDK(message: QueryGroupsExistRequest): QueryGroupsExistRequestSDKType;
    fromAmino(object: QueryGroupsExistRequestAmino): QueryGroupsExistRequest;
    toAmino(message: QueryGroupsExistRequest): QueryGroupsExistRequestAmino;
    fromAminoMsg(object: QueryGroupsExistRequestAminoMsg): QueryGroupsExistRequest;
    fromProtoMsg(message: QueryGroupsExistRequestProtoMsg): QueryGroupsExistRequest;
    toProto(message: QueryGroupsExistRequest): Uint8Array;
    toProtoMsg(message: QueryGroupsExistRequest): QueryGroupsExistRequestProtoMsg;
};
export declare const QueryGroupsExistByIdRequest: {
    typeUrl: string;
    encode(message: QueryGroupsExistByIdRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistByIdRequest;
    fromJSON(object: any): QueryGroupsExistByIdRequest;
    toJSON(message: QueryGroupsExistByIdRequest): unknown;
    fromPartial<I extends {
        groupIds?: string[];
    } & {
        groupIds?: string[] & string[] & Record<Exclude<keyof I["groupIds"], keyof string[]>, never>;
    } & Record<Exclude<keyof I, "groupIds">, never>>(object: I): QueryGroupsExistByIdRequest;
    fromSDK(object: QueryGroupsExistByIdRequestSDKType): QueryGroupsExistByIdRequest;
    toSDK(message: QueryGroupsExistByIdRequest): QueryGroupsExistByIdRequestSDKType;
    fromAmino(object: QueryGroupsExistByIdRequestAmino): QueryGroupsExistByIdRequest;
    toAmino(message: QueryGroupsExistByIdRequest): QueryGroupsExistByIdRequestAmino;
    fromAminoMsg(object: QueryGroupsExistByIdRequestAminoMsg): QueryGroupsExistByIdRequest;
    fromProtoMsg(message: QueryGroupsExistByIdRequestProtoMsg): QueryGroupsExistByIdRequest;
    toProto(message: QueryGroupsExistByIdRequest): Uint8Array;
    toProtoMsg(message: QueryGroupsExistByIdRequest): QueryGroupsExistByIdRequestProtoMsg;
};
export declare const QueryGroupsExistResponse_ExistsEntry: {
    encode(message: QueryGroupsExistResponse_ExistsEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistResponse_ExistsEntry;
    fromJSON(object: any): QueryGroupsExistResponse_ExistsEntry;
    toJSON(message: QueryGroupsExistResponse_ExistsEntry): unknown;
    fromPartial<I extends {
        key?: string;
        value?: boolean;
    } & {
        key?: string;
        value?: boolean;
    } & Record<Exclude<keyof I, keyof QueryGroupsExistResponse_ExistsEntry>, never>>(object: I): QueryGroupsExistResponse_ExistsEntry;
    fromSDK(object: QueryGroupsExistResponse_ExistsEntrySDKType): QueryGroupsExistResponse_ExistsEntry;
    toSDK(message: QueryGroupsExistResponse_ExistsEntry): QueryGroupsExistResponse_ExistsEntrySDKType;
    fromAmino(object: QueryGroupsExistResponse_ExistsEntryAmino): QueryGroupsExistResponse_ExistsEntry;
    toAmino(message: QueryGroupsExistResponse_ExistsEntry): QueryGroupsExistResponse_ExistsEntryAmino;
    fromAminoMsg(object: QueryGroupsExistResponse_ExistsEntryAminoMsg): QueryGroupsExistResponse_ExistsEntry;
    fromProtoMsg(message: QueryGroupsExistResponse_ExistsEntryProtoMsg): QueryGroupsExistResponse_ExistsEntry;
    toProto(message: QueryGroupsExistResponse_ExistsEntry): Uint8Array;
};
export declare const QueryGroupsExistResponse: {
    typeUrl: string;
    encode(message: QueryGroupsExistResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGroupsExistResponse;
    fromJSON(object: any): QueryGroupsExistResponse;
    toJSON(message: QueryGroupsExistResponse): unknown;
    fromPartial<I extends {
        exists?: {
            [x: string]: boolean;
        };
    } & {
        exists?: {
            [x: string]: boolean;
        } & {
            [x: string]: boolean;
        } & Record<Exclude<keyof I["exists"], string | number>, never>;
    } & Record<Exclude<keyof I, "exists">, never>>(object: I): QueryGroupsExistResponse;
    fromSDK(object: QueryGroupsExistResponseSDKType): QueryGroupsExistResponse;
    toSDK(message: QueryGroupsExistResponse): QueryGroupsExistResponseSDKType;
    fromAmino(object: QueryGroupsExistResponseAmino): QueryGroupsExistResponse;
    toAmino(message: QueryGroupsExistResponse): QueryGroupsExistResponseAmino;
    fromAminoMsg(object: QueryGroupsExistResponseAminoMsg): QueryGroupsExistResponse;
    fromProtoMsg(message: QueryGroupsExistResponseProtoMsg): QueryGroupsExistResponse;
    toProto(message: QueryGroupsExistResponse): Uint8Array;
    toProtoMsg(message: QueryGroupsExistResponse): QueryGroupsExistResponseProtoMsg;
};
/** Query defines the gRPC querier service. */
export interface Query {
    /** Parameters queries the parameters of the module. */
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    /** Parameters queries the parameters of the module. */
    QueryParamsByTimestamp(request: QueryParamsByTimestampRequest): Promise<QueryParamsByTimestampResponse>;
    /** Queries a bucket with specify name. */
    HeadBucket(request: QueryHeadBucketRequest): Promise<QueryHeadBucketResponse>;
    /** Queries a bucket by id */
    HeadBucketById(request: QueryHeadBucketByIdRequest): Promise<QueryHeadBucketResponse>;
    /** Queries a bucket with EIP712 standard metadata info */
    HeadBucketNFT(request: QueryNFTRequest): Promise<QueryBucketNFTResponse>;
    /** Queries a object with specify name. */
    HeadObject(request: QueryHeadObjectRequest): Promise<QueryHeadObjectResponse>;
    /** Queries an object by id */
    HeadObjectById(request: QueryHeadObjectByIdRequest): Promise<QueryHeadObjectResponse>;
    /** Queries a object with EIP712 standard metadata info */
    HeadObjectNFT(request: QueryNFTRequest): Promise<QueryObjectNFTResponse>;
    /** Queries a list of bucket items. */
    ListBuckets(request?: QueryListBucketsRequest): Promise<QueryListBucketsResponse>;
    /** Queries a list of object items under the bucket. */
    ListObjects(request: QueryListObjectsRequest): Promise<QueryListObjectsResponse>;
    /** Queries a list of object items under the bucket. */
    ListObjectsByBucketId(request: QueryListObjectsByBucketIdRequest): Promise<QueryListObjectsResponse>;
    /** Queries a group with EIP712 standard metadata info */
    HeadGroupNFT(request: QueryNFTRequest): Promise<QueryGroupNFTResponse>;
    /** Queries a policy which grants permission to account */
    QueryPolicyForAccount(request: QueryPolicyForAccountRequest): Promise<QueryPolicyForAccountResponse>;
    /** Queries a list of VerifyPermission items. */
    VerifyPermission(request: QueryVerifyPermissionRequest): Promise<QueryVerifyPermissionResponse>;
    /** Queries a group with specify owner and name . */
    HeadGroup(request: QueryHeadGroupRequest): Promise<QueryHeadGroupResponse>;
    /** Queries a list of ListGroup items. */
    ListGroups(request: QueryListGroupsRequest): Promise<QueryListGroupsResponse>;
    /** Queries a list of HeadGroupMember items. */
    HeadGroupMember(request: QueryHeadGroupMemberRequest): Promise<QueryHeadGroupMemberResponse>;
    /** Queries a policy that grants permission to a group */
    QueryPolicyForGroup(request: QueryPolicyForGroupRequest): Promise<QueryPolicyForGroupResponse>;
    /** Queries a policy by policy id */
    QueryPolicyById(request: QueryPolicyByIdRequest): Promise<QueryPolicyByIdResponse>;
    /** Queries lock fee for storing an object */
    QueryLockFee(request: QueryLockFeeRequest): Promise<QueryLockFeeResponse>;
    /** Queries a bucket extra info (with gvg bindings and price time) with specify name. */
    HeadBucketExtra(request: QueryHeadBucketExtraRequest): Promise<QueryHeadBucketExtraResponse>;
    /** Queries whether read and storage prices changed for the bucket. */
    QueryIsPriceChanged(request: QueryIsPriceChangedRequest): Promise<QueryIsPriceChangedResponse>;
    /** Queries whether read and storage prices changed for the bucket. */
    QueryQuotaUpdateTime(request: QueryQuoteUpdateTimeRequest): Promise<QueryQuoteUpdateTimeResponse>;
    /** Queries whether some members are in the group. */
    QueryGroupMembersExist(request: QueryGroupMembersExistRequest): Promise<QueryGroupMembersExistResponse>;
    /** Queries whether some groups are exist. */
    QueryGroupsExist(request: QueryGroupsExistRequest): Promise<QueryGroupsExistResponse>;
    /** Queries whether some groups are exist by id. */
    QueryGroupsExistById(request: QueryGroupsExistByIdRequest): Promise<QueryGroupsExistResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Params(request?: QueryParamsRequest): Promise<QueryParamsResponse>;
    QueryParamsByTimestamp(request: QueryParamsByTimestampRequest): Promise<QueryParamsByTimestampResponse>;
    HeadBucket(request: QueryHeadBucketRequest): Promise<QueryHeadBucketResponse>;
    HeadBucketById(request: QueryHeadBucketByIdRequest): Promise<QueryHeadBucketResponse>;
    HeadBucketNFT(request: QueryNFTRequest): Promise<QueryBucketNFTResponse>;
    HeadObject(request: QueryHeadObjectRequest): Promise<QueryHeadObjectResponse>;
    HeadObjectById(request: QueryHeadObjectByIdRequest): Promise<QueryHeadObjectResponse>;
    HeadObjectNFT(request: QueryNFTRequest): Promise<QueryObjectNFTResponse>;
    ListBuckets(request?: QueryListBucketsRequest): Promise<QueryListBucketsResponse>;
    ListObjects(request: QueryListObjectsRequest): Promise<QueryListObjectsResponse>;
    ListObjectsByBucketId(request: QueryListObjectsByBucketIdRequest): Promise<QueryListObjectsResponse>;
    HeadGroupNFT(request: QueryNFTRequest): Promise<QueryGroupNFTResponse>;
    QueryPolicyForAccount(request: QueryPolicyForAccountRequest): Promise<QueryPolicyForAccountResponse>;
    VerifyPermission(request: QueryVerifyPermissionRequest): Promise<QueryVerifyPermissionResponse>;
    HeadGroup(request: QueryHeadGroupRequest): Promise<QueryHeadGroupResponse>;
    ListGroups(request: QueryListGroupsRequest): Promise<QueryListGroupsResponse>;
    HeadGroupMember(request: QueryHeadGroupMemberRequest): Promise<QueryHeadGroupMemberResponse>;
    QueryPolicyForGroup(request: QueryPolicyForGroupRequest): Promise<QueryPolicyForGroupResponse>;
    QueryPolicyById(request: QueryPolicyByIdRequest): Promise<QueryPolicyByIdResponse>;
    QueryLockFee(request: QueryLockFeeRequest): Promise<QueryLockFeeResponse>;
    HeadBucketExtra(request: QueryHeadBucketExtraRequest): Promise<QueryHeadBucketExtraResponse>;
    QueryIsPriceChanged(request: QueryIsPriceChangedRequest): Promise<QueryIsPriceChangedResponse>;
    QueryQuotaUpdateTime(request: QueryQuoteUpdateTimeRequest): Promise<QueryQuoteUpdateTimeResponse>;
    QueryGroupMembersExist(request: QueryGroupMembersExistRequest): Promise<QueryGroupMembersExistResponse>;
    QueryGroupsExist(request: QueryGroupsExistRequest): Promise<QueryGroupsExistResponse>;
    QueryGroupsExistById(request: QueryGroupsExistByIdRequest): Promise<QueryGroupsExistResponse>;
}
