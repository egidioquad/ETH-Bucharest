import { PageRequest, PageRequestAmino, PageRequestSDKType, PageResponse, PageResponseAmino, PageResponseSDKType } from "../../base/query/v1beta1/pagination";
import { Grant, GrantAmino, GrantSDKType, GrantAuthorization, GrantAuthorizationAmino, GrantAuthorizationSDKType } from "./authz";
import * as _m0 from "protobufjs/minimal";
import { Rpc } from "../../../helpers";
export declare const protobufPackage = "cosmos.authz.v1beta1";
/** QueryGrantsRequest is the request type for the Query/Grants RPC method. */
export interface QueryGrantsRequest {
    granter: string;
    grantee: string;
    /** Optional, msg_type_url, when set, will query only grants matching given msg type. */
    msgTypeUrl: string;
    /** pagination defines an pagination for the request. */
    pagination?: PageRequest;
}
export interface QueryGrantsRequestProtoMsg {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsRequest";
    value: Uint8Array;
}
/** QueryGrantsRequest is the request type for the Query/Grants RPC method. */
export interface QueryGrantsRequestAmino {
    granter?: string;
    grantee?: string;
    /** Optional, msg_type_url, when set, will query only grants matching given msg type. */
    msg_type_url?: string;
    /** pagination defines an pagination for the request. */
    pagination?: PageRequestAmino;
}
export interface QueryGrantsRequestAminoMsg {
    type: "cosmos-sdk/QueryGrantsRequest";
    value: QueryGrantsRequestAmino;
}
/** QueryGrantsRequest is the request type for the Query/Grants RPC method. */
export interface QueryGrantsRequestSDKType {
    granter: string;
    grantee: string;
    msg_type_url: string;
    pagination?: PageRequestSDKType;
}
/** QueryGrantsResponse is the response type for the Query/Authorizations RPC method. */
export interface QueryGrantsResponse {
    /** authorizations is a list of grants granted for grantee by granter. */
    grants: Grant[];
    /** pagination defines an pagination for the response. */
    pagination?: PageResponse;
}
export interface QueryGrantsResponseProtoMsg {
    typeUrl: "/cosmos.authz.v1beta1.QueryGrantsResponse";
    value: Uint8Array;
}
/** QueryGrantsResponse is the response type for the Query/Authorizations RPC method. */
export interface QueryGrantsResponseAmino {
    /** authorizations is a list of grants granted for grantee by granter. */
    grants?: GrantAmino[];
    /** pagination defines an pagination for the response. */
    pagination?: PageResponseAmino;
}
export interface QueryGrantsResponseAminoMsg {
    type: "cosmos-sdk/QueryGrantsResponse";
    value: QueryGrantsResponseAmino;
}
/** QueryGrantsResponse is the response type for the Query/Authorizations RPC method. */
export interface QueryGrantsResponseSDKType {
    grants: GrantSDKType[];
    pagination?: PageResponseSDKType;
}
/** QueryGranterGrantsRequest is the request type for the Query/GranterGrants RPC method. */
export interface QueryGranterGrantsRequest {
    granter: string;
    /** pagination defines an pagination for the request. */
    pagination?: PageRequest;
}
export interface QueryGranterGrantsRequestProtoMsg {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsRequest";
    value: Uint8Array;
}
/** QueryGranterGrantsRequest is the request type for the Query/GranterGrants RPC method. */
export interface QueryGranterGrantsRequestAmino {
    granter?: string;
    /** pagination defines an pagination for the request. */
    pagination?: PageRequestAmino;
}
export interface QueryGranterGrantsRequestAminoMsg {
    type: "cosmos-sdk/QueryGranterGrantsRequest";
    value: QueryGranterGrantsRequestAmino;
}
/** QueryGranterGrantsRequest is the request type for the Query/GranterGrants RPC method. */
export interface QueryGranterGrantsRequestSDKType {
    granter: string;
    pagination?: PageRequestSDKType;
}
/** QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method. */
export interface QueryGranterGrantsResponse {
    /** grants is a list of grants granted by the granter. */
    grants: GrantAuthorization[];
    /** pagination defines an pagination for the response. */
    pagination?: PageResponse;
}
export interface QueryGranterGrantsResponseProtoMsg {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranterGrantsResponse";
    value: Uint8Array;
}
/** QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method. */
export interface QueryGranterGrantsResponseAmino {
    /** grants is a list of grants granted by the granter. */
    grants?: GrantAuthorizationAmino[];
    /** pagination defines an pagination for the response. */
    pagination?: PageResponseAmino;
}
export interface QueryGranterGrantsResponseAminoMsg {
    type: "cosmos-sdk/QueryGranterGrantsResponse";
    value: QueryGranterGrantsResponseAmino;
}
/** QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method. */
export interface QueryGranterGrantsResponseSDKType {
    grants: GrantAuthorizationSDKType[];
    pagination?: PageResponseSDKType;
}
/** QueryGranteeGrantsRequest is the request type for the Query/IssuedGrants RPC method. */
export interface QueryGranteeGrantsRequest {
    grantee: string;
    /** pagination defines an pagination for the request. */
    pagination?: PageRequest;
}
export interface QueryGranteeGrantsRequestProtoMsg {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsRequest";
    value: Uint8Array;
}
/** QueryGranteeGrantsRequest is the request type for the Query/IssuedGrants RPC method. */
export interface QueryGranteeGrantsRequestAmino {
    grantee?: string;
    /** pagination defines an pagination for the request. */
    pagination?: PageRequestAmino;
}
export interface QueryGranteeGrantsRequestAminoMsg {
    type: "cosmos-sdk/QueryGranteeGrantsRequest";
    value: QueryGranteeGrantsRequestAmino;
}
/** QueryGranteeGrantsRequest is the request type for the Query/IssuedGrants RPC method. */
export interface QueryGranteeGrantsRequestSDKType {
    grantee: string;
    pagination?: PageRequestSDKType;
}
/** QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method. */
export interface QueryGranteeGrantsResponse {
    /** grants is a list of grants granted to the grantee. */
    grants: GrantAuthorization[];
    /** pagination defines an pagination for the response. */
    pagination?: PageResponse;
}
export interface QueryGranteeGrantsResponseProtoMsg {
    typeUrl: "/cosmos.authz.v1beta1.QueryGranteeGrantsResponse";
    value: Uint8Array;
}
/** QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method. */
export interface QueryGranteeGrantsResponseAmino {
    /** grants is a list of grants granted to the grantee. */
    grants?: GrantAuthorizationAmino[];
    /** pagination defines an pagination for the response. */
    pagination?: PageResponseAmino;
}
export interface QueryGranteeGrantsResponseAminoMsg {
    type: "cosmos-sdk/QueryGranteeGrantsResponse";
    value: QueryGranteeGrantsResponseAmino;
}
/** QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method. */
export interface QueryGranteeGrantsResponseSDKType {
    grants: GrantAuthorizationSDKType[];
    pagination?: PageResponseSDKType;
}
export declare const QueryGrantsRequest: {
    typeUrl: string;
    encode(message: QueryGrantsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGrantsRequest;
    fromJSON(object: any): QueryGrantsRequest;
    toJSON(message: QueryGrantsRequest): unknown;
    fromPartial<I extends {
        granter?: string;
        grantee?: string;
        msgTypeUrl?: string;
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        granter?: string;
        grantee?: string;
        msgTypeUrl?: string;
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>);
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, keyof QueryGrantsRequest>, never>>(object: I): QueryGrantsRequest;
    fromSDK(object: QueryGrantsRequestSDKType): QueryGrantsRequest;
    toSDK(message: QueryGrantsRequest): QueryGrantsRequestSDKType;
    fromAmino(object: QueryGrantsRequestAmino): QueryGrantsRequest;
    toAmino(message: QueryGrantsRequest): QueryGrantsRequestAmino;
    fromAminoMsg(object: QueryGrantsRequestAminoMsg): QueryGrantsRequest;
    toAminoMsg(message: QueryGrantsRequest): QueryGrantsRequestAminoMsg;
    fromProtoMsg(message: QueryGrantsRequestProtoMsg): QueryGrantsRequest;
    toProto(message: QueryGrantsRequest): Uint8Array;
    toProtoMsg(message: QueryGrantsRequest): QueryGrantsRequestProtoMsg;
};
export declare const QueryGrantsResponse: {
    typeUrl: string;
    encode(message: QueryGrantsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGrantsResponse;
    fromJSON(object: any): QueryGrantsResponse;
    toJSON(message: QueryGrantsResponse): unknown;
    fromPartial<I extends {
        grants?: {
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        };
    } & {
        grants?: {
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[] & ({
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        } & {
            authorization?: ({
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../../google/protobuf/any").Any>, never>) | ({
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } & {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[] & ({
                    denom?: string;
                    amount?: string;
                } & {
                    denom?: string;
                    amount?: string;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["spendLimit"][number], keyof import("../../base/v1beta1/coin").Coin>, never>)[] & Record<Exclude<keyof I["grants"][number]["authorization"]["spendLimit"], keyof {
                    denom?: string;
                    amount?: string;
                }[]>, never>;
                allowList?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../bank/v1beta1/authz").SendAuthorization>, never>) | ({
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } & {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                } & {
                    denom?: string;
                    amount?: string;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["maxTokens"], keyof import("../../base/v1beta1/coin").Coin>, never>;
                allowList?: {
                    address?: string[];
                } & {
                    address?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"]["address"], keyof string[]>, never>;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"], "address">, never>;
                denyList?: {
                    address?: string[];
                } & {
                    address?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["denyList"]["address"], keyof string[]>, never>;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["denyList"], "address">, never>;
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../staking/v1beta1/authz").StakeAuthorization>, never>) | ({
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            } & {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("./authz").GenericAuthorization>, never>);
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            } & {
                seconds?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["grants"][number]["expiration"]["seconds"], keyof import("long").Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["grants"][number]["expiration"], keyof import("../../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["grants"][number], keyof Grant>, never>)[] & Record<Exclude<keyof I["grants"], keyof {
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryGrantsResponse>, never>>(object: I): QueryGrantsResponse;
    fromSDK(object: QueryGrantsResponseSDKType): QueryGrantsResponse;
    toSDK(message: QueryGrantsResponse): QueryGrantsResponseSDKType;
    fromAmino(object: QueryGrantsResponseAmino): QueryGrantsResponse;
    toAmino(message: QueryGrantsResponse): QueryGrantsResponseAmino;
    fromAminoMsg(object: QueryGrantsResponseAminoMsg): QueryGrantsResponse;
    toAminoMsg(message: QueryGrantsResponse): QueryGrantsResponseAminoMsg;
    fromProtoMsg(message: QueryGrantsResponseProtoMsg): QueryGrantsResponse;
    toProto(message: QueryGrantsResponse): Uint8Array;
    toProtoMsg(message: QueryGrantsResponse): QueryGrantsResponseProtoMsg;
};
export declare const QueryGranterGrantsRequest: {
    typeUrl: string;
    encode(message: QueryGranterGrantsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGranterGrantsRequest;
    fromJSON(object: any): QueryGranterGrantsRequest;
    toJSON(message: QueryGranterGrantsRequest): unknown;
    fromPartial<I extends {
        granter?: string;
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        granter?: string;
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>);
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, keyof QueryGranterGrantsRequest>, never>>(object: I): QueryGranterGrantsRequest;
    fromSDK(object: QueryGranterGrantsRequestSDKType): QueryGranterGrantsRequest;
    toSDK(message: QueryGranterGrantsRequest): QueryGranterGrantsRequestSDKType;
    fromAmino(object: QueryGranterGrantsRequestAmino): QueryGranterGrantsRequest;
    toAmino(message: QueryGranterGrantsRequest): QueryGranterGrantsRequestAmino;
    fromAminoMsg(object: QueryGranterGrantsRequestAminoMsg): QueryGranterGrantsRequest;
    toAminoMsg(message: QueryGranterGrantsRequest): QueryGranterGrantsRequestAminoMsg;
    fromProtoMsg(message: QueryGranterGrantsRequestProtoMsg): QueryGranterGrantsRequest;
    toProto(message: QueryGranterGrantsRequest): Uint8Array;
    toProtoMsg(message: QueryGranterGrantsRequest): QueryGranterGrantsRequestProtoMsg;
};
export declare const QueryGranterGrantsResponse: {
    typeUrl: string;
    encode(message: QueryGranterGrantsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGranterGrantsResponse;
    fromJSON(object: any): QueryGranterGrantsResponse;
    toJSON(message: QueryGranterGrantsResponse): unknown;
    fromPartial<I extends {
        grants?: {
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        };
    } & {
        grants?: {
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[] & ({
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        } & {
            granter?: string;
            grantee?: string;
            authorization?: ({
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../../google/protobuf/any").Any>, never>) | ({
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } & {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[] & ({
                    denom?: string;
                    amount?: string;
                } & {
                    denom?: string;
                    amount?: string;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["spendLimit"][number], keyof import("../../base/v1beta1/coin").Coin>, never>)[] & Record<Exclude<keyof I["grants"][number]["authorization"]["spendLimit"], keyof {
                    denom?: string;
                    amount?: string;
                }[]>, never>;
                allowList?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../bank/v1beta1/authz").SendAuthorization>, never>) | ({
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } & {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                } & {
                    denom?: string;
                    amount?: string;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["maxTokens"], keyof import("../../base/v1beta1/coin").Coin>, never>;
                allowList?: {
                    address?: string[];
                } & {
                    address?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"]["address"], keyof string[]>, never>;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"], "address">, never>;
                denyList?: {
                    address?: string[];
                } & {
                    address?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["denyList"]["address"], keyof string[]>, never>;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["denyList"], "address">, never>;
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../staking/v1beta1/authz").StakeAuthorization>, never>) | ({
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            } & {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("./authz").GenericAuthorization>, never>);
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            } & {
                seconds?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["grants"][number]["expiration"]["seconds"], keyof import("long").Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["grants"][number]["expiration"], keyof import("../../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["grants"][number], keyof GrantAuthorization>, never>)[] & Record<Exclude<keyof I["grants"], keyof {
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryGranterGrantsResponse>, never>>(object: I): QueryGranterGrantsResponse;
    fromSDK(object: QueryGranterGrantsResponseSDKType): QueryGranterGrantsResponse;
    toSDK(message: QueryGranterGrantsResponse): QueryGranterGrantsResponseSDKType;
    fromAmino(object: QueryGranterGrantsResponseAmino): QueryGranterGrantsResponse;
    toAmino(message: QueryGranterGrantsResponse): QueryGranterGrantsResponseAmino;
    fromAminoMsg(object: QueryGranterGrantsResponseAminoMsg): QueryGranterGrantsResponse;
    toAminoMsg(message: QueryGranterGrantsResponse): QueryGranterGrantsResponseAminoMsg;
    fromProtoMsg(message: QueryGranterGrantsResponseProtoMsg): QueryGranterGrantsResponse;
    toProto(message: QueryGranterGrantsResponse): Uint8Array;
    toProtoMsg(message: QueryGranterGrantsResponse): QueryGranterGrantsResponseProtoMsg;
};
export declare const QueryGranteeGrantsRequest: {
    typeUrl: string;
    encode(message: QueryGranteeGrantsRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGranteeGrantsRequest;
    fromJSON(object: any): QueryGranteeGrantsRequest;
    toJSON(message: QueryGranteeGrantsRequest): unknown;
    fromPartial<I extends {
        grantee?: string;
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        };
    } & {
        grantee?: string;
        pagination?: {
            key?: Uint8Array;
            offset?: string | number | import("long").Long;
            limit?: string | number | import("long").Long;
            countTotal?: boolean;
            reverse?: boolean;
        } & {
            key?: Uint8Array;
            offset?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["offset"], keyof import("long").Long>, never>);
            limit?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["limit"], keyof import("long").Long>, never>);
            countTotal?: boolean;
            reverse?: boolean;
        } & Record<Exclude<keyof I["pagination"], keyof PageRequest>, never>;
    } & Record<Exclude<keyof I, keyof QueryGranteeGrantsRequest>, never>>(object: I): QueryGranteeGrantsRequest;
    fromSDK(object: QueryGranteeGrantsRequestSDKType): QueryGranteeGrantsRequest;
    toSDK(message: QueryGranteeGrantsRequest): QueryGranteeGrantsRequestSDKType;
    fromAmino(object: QueryGranteeGrantsRequestAmino): QueryGranteeGrantsRequest;
    toAmino(message: QueryGranteeGrantsRequest): QueryGranteeGrantsRequestAmino;
    fromAminoMsg(object: QueryGranteeGrantsRequestAminoMsg): QueryGranteeGrantsRequest;
    toAminoMsg(message: QueryGranteeGrantsRequest): QueryGranteeGrantsRequestAminoMsg;
    fromProtoMsg(message: QueryGranteeGrantsRequestProtoMsg): QueryGranteeGrantsRequest;
    toProto(message: QueryGranteeGrantsRequest): Uint8Array;
    toProtoMsg(message: QueryGranteeGrantsRequest): QueryGranteeGrantsRequestProtoMsg;
};
export declare const QueryGranteeGrantsResponse: {
    typeUrl: string;
    encode(message: QueryGranteeGrantsResponse, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QueryGranteeGrantsResponse;
    fromJSON(object: any): QueryGranteeGrantsResponse;
    toJSON(message: QueryGranteeGrantsResponse): unknown;
    fromPartial<I extends {
        grants?: {
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[];
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        };
    } & {
        grants?: {
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[] & ({
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        } & {
            granter?: string;
            grantee?: string;
            authorization?: ({
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } & {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../../google/protobuf/any").Any>, never>) | ({
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } & {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[] & ({
                    denom?: string;
                    amount?: string;
                } & {
                    denom?: string;
                    amount?: string;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["spendLimit"][number], keyof import("../../base/v1beta1/coin").Coin>, never>)[] & Record<Exclude<keyof I["grants"][number]["authorization"]["spendLimit"], keyof {
                    denom?: string;
                    amount?: string;
                }[]>, never>;
                allowList?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"], keyof string[]>, never>;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../bank/v1beta1/authz").SendAuthorization>, never>) | ({
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } & {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                } & {
                    denom?: string;
                    amount?: string;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["maxTokens"], keyof import("../../base/v1beta1/coin").Coin>, never>;
                allowList?: {
                    address?: string[];
                } & {
                    address?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"]["address"], keyof string[]>, never>;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["allowList"], "address">, never>;
                denyList?: {
                    address?: string[];
                } & {
                    address?: string[] & string[] & Record<Exclude<keyof I["grants"][number]["authorization"]["denyList"]["address"], keyof string[]>, never>;
                } & Record<Exclude<keyof I["grants"][number]["authorization"]["denyList"], "address">, never>;
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("../../staking/v1beta1/authz").StakeAuthorization>, never>) | ({
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            } & {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            } & Record<Exclude<keyof I["grants"][number]["authorization"], keyof import("./authz").GenericAuthorization>, never>);
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            } & {
                seconds?: string | number | (import("long").Long & {
                    high: number;
                    low: number;
                    unsigned: boolean;
                    add: (addend: string | number | import("long").Long) => import("long").Long;
                    and: (other: string | number | import("long").Long) => import("long").Long;
                    compare: (other: string | number | import("long").Long) => number;
                    comp: (other: string | number | import("long").Long) => number;
                    divide: (divisor: string | number | import("long").Long) => import("long").Long;
                    div: (divisor: string | number | import("long").Long) => import("long").Long;
                    equals: (other: string | number | import("long").Long) => boolean;
                    eq: (other: string | number | import("long").Long) => boolean;
                    getHighBits: () => number;
                    getHighBitsUnsigned: () => number;
                    getLowBits: () => number;
                    getLowBitsUnsigned: () => number;
                    getNumBitsAbs: () => number;
                    greaterThan: (other: string | number | import("long").Long) => boolean;
                    gt: (other: string | number | import("long").Long) => boolean;
                    greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    gte: (other: string | number | import("long").Long) => boolean;
                    isEven: () => boolean;
                    isNegative: () => boolean;
                    isOdd: () => boolean;
                    isPositive: () => boolean;
                    isZero: () => boolean;
                    lessThan: (other: string | number | import("long").Long) => boolean;
                    lt: (other: string | number | import("long").Long) => boolean;
                    lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                    lte: (other: string | number | import("long").Long) => boolean;
                    modulo: (other: string | number | import("long").Long) => import("long").Long;
                    mod: (other: string | number | import("long").Long) => import("long").Long;
                    multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                    mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                    negate: () => import("long").Long;
                    neg: () => import("long").Long;
                    not: () => import("long").Long;
                    notEquals: (other: string | number | import("long").Long) => boolean;
                    neq: (other: string | number | import("long").Long) => boolean;
                    or: (other: string | number | import("long").Long) => import("long").Long;
                    shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                    shl: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                    shr: (numBits: number | import("long").Long) => import("long").Long;
                    shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                    shru: (numBits: number | import("long").Long) => import("long").Long;
                    subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                    toInt: () => number;
                    toNumber: () => number;
                    toBytes: (le?: boolean) => number[];
                    toBytesLE: () => number[];
                    toBytesBE: () => number[];
                    toSigned: () => import("long").Long;
                    toString: (radix?: number) => string;
                    toUnsigned: () => import("long").Long;
                    xor: (other: string | number | import("long").Long) => import("long").Long;
                } & Record<Exclude<keyof I["grants"][number]["expiration"]["seconds"], keyof import("long").Long>, never>);
                nanos?: number;
            } & Record<Exclude<keyof I["grants"][number]["expiration"], keyof import("../../../google/protobuf/timestamp").Timestamp>, never>;
        } & Record<Exclude<keyof I["grants"][number], keyof GrantAuthorization>, never>)[] & Record<Exclude<keyof I["grants"], keyof {
            granter?: string;
            grantee?: string;
            authorization?: {
                $typeUrl?: "/google.protobuf.Any";
                typeUrl?: string;
                value?: Uint8Array;
            } | {
                $typeUrl?: "/cosmos.bank.v1beta1.SendAuthorization";
                spendLimit?: {
                    denom?: string;
                    amount?: string;
                }[];
                allowList?: string[];
            } | {
                $typeUrl?: "/cosmos.staking.v1beta1.StakeAuthorization";
                maxTokens?: {
                    denom?: string;
                    amount?: string;
                };
                allowList?: {
                    address?: string[];
                };
                denyList?: {
                    address?: string[];
                };
                authorizationType?: import("../../staking/v1beta1/authz").AuthorizationType;
            } | {
                $typeUrl?: "/cosmos.authz.v1beta1.GenericAuthorization";
                msg?: string;
            };
            expiration?: {
                seconds?: string | number | import("long").Long;
                nanos?: number;
            };
        }[]>, never>;
        pagination?: {
            nextKey?: Uint8Array;
            total?: string | number | import("long").Long;
        } & {
            nextKey?: Uint8Array;
            total?: string | number | (import("long").Long & {
                high: number;
                low: number;
                unsigned: boolean;
                add: (addend: string | number | import("long").Long) => import("long").Long;
                and: (other: string | number | import("long").Long) => import("long").Long;
                compare: (other: string | number | import("long").Long) => number;
                comp: (other: string | number | import("long").Long) => number;
                divide: (divisor: string | number | import("long").Long) => import("long").Long;
                div: (divisor: string | number | import("long").Long) => import("long").Long;
                equals: (other: string | number | import("long").Long) => boolean;
                eq: (other: string | number | import("long").Long) => boolean;
                getHighBits: () => number;
                getHighBitsUnsigned: () => number;
                getLowBits: () => number;
                getLowBitsUnsigned: () => number;
                getNumBitsAbs: () => number;
                greaterThan: (other: string | number | import("long").Long) => boolean;
                gt: (other: string | number | import("long").Long) => boolean;
                greaterThanOrEqual: (other: string | number | import("long").Long) => boolean;
                gte: (other: string | number | import("long").Long) => boolean;
                isEven: () => boolean;
                isNegative: () => boolean;
                isOdd: () => boolean;
                isPositive: () => boolean;
                isZero: () => boolean;
                lessThan: (other: string | number | import("long").Long) => boolean;
                lt: (other: string | number | import("long").Long) => boolean;
                lessThanOrEqual: (other: string | number | import("long").Long) => boolean;
                lte: (other: string | number | import("long").Long) => boolean;
                modulo: (other: string | number | import("long").Long) => import("long").Long;
                mod: (other: string | number | import("long").Long) => import("long").Long;
                multiply: (multiplier: string | number | import("long").Long) => import("long").Long;
                mul: (multiplier: string | number | import("long").Long) => import("long").Long;
                negate: () => import("long").Long;
                neg: () => import("long").Long;
                not: () => import("long").Long;
                notEquals: (other: string | number | import("long").Long) => boolean;
                neq: (other: string | number | import("long").Long) => boolean;
                or: (other: string | number | import("long").Long) => import("long").Long;
                shiftLeft: (numBits: number | import("long").Long) => import("long").Long;
                shl: (numBits: number | import("long").Long) => import("long").Long;
                shiftRight: (numBits: number | import("long").Long) => import("long").Long;
                shr: (numBits: number | import("long").Long) => import("long").Long;
                shiftRightUnsigned: (numBits: number | import("long").Long) => import("long").Long;
                shru: (numBits: number | import("long").Long) => import("long").Long;
                subtract: (subtrahend: string | number | import("long").Long) => import("long").Long;
                sub: (subtrahend: string | number | import("long").Long) => import("long").Long;
                toInt: () => number;
                toNumber: () => number;
                toBytes: (le?: boolean) => number[];
                toBytesLE: () => number[];
                toBytesBE: () => number[];
                toSigned: () => import("long").Long;
                toString: (radix?: number) => string;
                toUnsigned: () => import("long").Long;
                xor: (other: string | number | import("long").Long) => import("long").Long;
            } & Record<Exclude<keyof I["pagination"]["total"], keyof import("long").Long>, never>);
        } & Record<Exclude<keyof I["pagination"], keyof PageResponse>, never>;
    } & Record<Exclude<keyof I, keyof QueryGranteeGrantsResponse>, never>>(object: I): QueryGranteeGrantsResponse;
    fromSDK(object: QueryGranteeGrantsResponseSDKType): QueryGranteeGrantsResponse;
    toSDK(message: QueryGranteeGrantsResponse): QueryGranteeGrantsResponseSDKType;
    fromAmino(object: QueryGranteeGrantsResponseAmino): QueryGranteeGrantsResponse;
    toAmino(message: QueryGranteeGrantsResponse): QueryGranteeGrantsResponseAmino;
    fromAminoMsg(object: QueryGranteeGrantsResponseAminoMsg): QueryGranteeGrantsResponse;
    toAminoMsg(message: QueryGranteeGrantsResponse): QueryGranteeGrantsResponseAminoMsg;
    fromProtoMsg(message: QueryGranteeGrantsResponseProtoMsg): QueryGranteeGrantsResponse;
    toProto(message: QueryGranteeGrantsResponse): Uint8Array;
    toProtoMsg(message: QueryGranteeGrantsResponse): QueryGranteeGrantsResponseProtoMsg;
};
/** Query defines the gRPC querier service. */
export interface Query {
    /** Returns list of `Authorization`, granted to the grantee by the granter. */
    Grants(request: QueryGrantsRequest): Promise<QueryGrantsResponse>;
    /**
     * GranterGrants returns list of `GrantAuthorization`, granted by granter.
     *
     * Since: cosmos-sdk 0.46
     */
    GranterGrants(request: QueryGranterGrantsRequest): Promise<QueryGranterGrantsResponse>;
    /**
     * GranteeGrants returns a list of `GrantAuthorization` by grantee.
     *
     * Since: cosmos-sdk 0.46
     */
    GranteeGrants(request: QueryGranteeGrantsRequest): Promise<QueryGranteeGrantsResponse>;
}
export declare class QueryClientImpl implements Query {
    private readonly rpc;
    constructor(rpc: Rpc);
    Grants(request: QueryGrantsRequest): Promise<QueryGrantsResponse>;
    GranterGrants(request: QueryGranterGrantsRequest): Promise<QueryGranterGrantsResponse>;
    GranteeGrants(request: QueryGranteeGrantsRequest): Promise<QueryGranteeGrantsResponse>;
}
